{"success":true,"parcel":{"id":2500,"hash":"9c64d509ff46ffa9f941da4e378ee20685f35b72","features":[{"type":"lantern","uuid":"4a054ed4-7735-4c63-a2ec-d977c34093e0","color":"#51e63d","scale":[5.4,0.1,0.5],"version":"16168","position":[4.25,6.95,9.5],"rotation":[0,0,0],"strength":"16"},{"type":"lantern","uuid":"d2b9446b-e090-4c71-914b-0a0c93e37a1a","color":"#ff00aa","scale":[0.5,0.5,0.5],"version":"16168","position":[8.5,7.3,-9.5],"rotation":[0,0,0],"strength":"100"},{"type":"lantern","uuid":"cbf0be47-68ac-4db4-86a5-74a227c5e0ec","color":"#004cff","scale":[0.5,0.5,0.5],"version":"16168","position":[5.25,3.7,-7.5],"rotation":[0,0,0],"strength":"49"},{"type":"lantern","uuid":"e35aca75-7842-4924-a1f8-715fd0229029","color":"#ff00aa","scale":[0.5,0.5,0.5],"version":"16168","position":[7.25,3.38,1.5],"rotation":[0,0,0],"strength":"12"},{"type":"vid-screen","uuid":"b5c45afd-90de-4f9a-9474-96ec67c993f3","scale":[1,1,0],"script":"let ball, paddle, frame, blocks \n\n// Canvas Size 64*64\nlet PIXELS = 64;\n\n// Each pixel has a Red, Green & Blue sequential pixel\nlet RGB_PIXEL_SIZE = 3;\n\n// Block Grid\nlet BLOCK_ROWS = 3;\nlet BLOCK_COLS = 6;\n\nclass Color {\n  constructor(r, g, b) {\n    this.pixels = [r, g, b];\n  }\n}\n\n// COLORS\nlet RED = new Color(255, 0, 0);\nlet GREEN = new Color(0, 255, 0);\nlet BLUE = new Color(128, 128, 255);\nlet WHITE = new Color(255, 255, 255);\nlet GRAY = new Color(128, 128, 128);\n\n\n// Listeners\nfeature.on('keys', e => {\n  if (e.keys.left) {\n    paddle.moveLeft();\n  } else if (e.keys.right) {\n    paddle.moveRight();\n  } else if (e.keys.a) {\n    projectile.shoot();\n  }\n})\n\nfeature.on('start', e => {\n  reset();\n})\n\nfeature.on('frame', e => {\n  frame += 1;\n  update();\n  draw();\n})\n\n// Update/Draw/Reset\n\nfunction update() {\n  ball.update();\n}\n\nfunction draw() {\n  feature.screen.fill(GRAY);\n  \n  ball.draw();\n  paddle.draw();\n  for (j = 0; j < blocks.length; j ++) {\n    blocks[j].draw();\n  }\n}\n\nfunction reset() {\n  frame = 0;\n\n  // Ball\n  let randomX = Math.round(Math.random() * PIXELS);\n  ball = new Ball(new ColoredBlock(randomX, 32, 1, 1, GREEN));\n\n  // Paddle\n  paddle = new Paddle(new ColoredBlock(29, 60, 10, 1, BLUE));\n\n  // Blocks\n  blocks = []\n  for (let row = 0; row < BLOCK_ROWS; row++) {\n    for (let j = 0; j < BLOCK_COLS; j ++) {\n      let xPos = Math.floor(feature.screenWidth / 6 * j + 2);\n      let yPos = row * 4 + 2;\n      blocks.push(new Square(xPos, yPos, 5, 2, RED));\n    }\n  }\n\n  // Draw\n  draw()\n}\n\n// Classes\n\nclass Ball {\n  constructor(obj) {\n    this.object = obj;\n    \n    this.xVel = Math.random() > 0.5 ? 1 : -1;\n    this.yVel = 1;\n  }\n  \n  update() {\n    if (frame % 2 != 0) {\n      return\n    }\n    \n    // wall collision detection\n    if ((this.object.x + this.xVel) >= PIXELS \n      || (this.object.x + this.xVel) < 0) {\n      this.xVel *= -1;\n    }\n    if ((this.object.y + this.yVel) < 0) {\n      this.yVel *= -1;\n    }\n    if ((this.object.y + this.yVel) >= PIXELS) {\n      reset();\n    }\n    \n    // paddle collision detection\n    if ((this.object.y + this.yVel) == paddle.object.y) {\n      let nextX = this.object.x + this.xVel;\n      if (nextX >= paddle.object.x \n        && nextX <= paddle.object.x + paddle.object.width) {\n        this.yVel *= -1;\n      }\n    }\n    \n    // block collision detection\n    for (let i = 0; i < blocks.length; i++) {\n      let block = blocks[i]\n      let nextX = this.object.x + this.xVel\n      let nextY = this.object.y + this.yVel\n      \n      if (nextX >= block.x \n        && nextX < block.x + block.width \n        && nextY >= block.y \n        && nextY < block.y + block.height) {\n        if (this.object.x < block.x \n          || this.object.x > block.x + block.width - 1) {\n          this.xVel *= -1;\n        }\n        if (this.object.y < block.y \n          || this.object.y > block.y + block.height - 1) {\n          this.yVel *= -1;\n        }\n        \n        blocks.splice(i, 1)\n        break\n      }\n    }\n    \n    // update position\n        \n    this.object.x += this.xVel\n    this.object.y += this.yVel\n  }\n  \n  draw() {\n    this.object.draw();\n  }\n}\n\nclass Paddle {\n  constructor(obj) {\n    this.object = obj;\n  }\n  \n  draw() {\n    this.object.draw();\n  }\n  \n  moveLeft() {\n    if (this.object.x > 0) {\n      this.object.x -= 2;\n      draw();\n    }\n  }\n  \n  moveRight() {\n    if (this.object.x + this.object.width <= PIXELS) {\n      this.object.x += 2;\n      draw();\n    }\n  }\n}\n\nclass Square {\n  constructor(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n    this.objects = [\n      // Left Line\n      new ColoredBlock(x, y, 1, h, RED),\n      // Right Line\n      new ColoredBlock((x + w - 1), y, 1, h, RED),\n      // Top Line\n      new ColoredBlock(x, y, w, 1, RED),\n      // Bottom Line\n      new ColoredBlock(x, (y + h - 1), w, 1, RED)\n    ];\n  }\n  \n  draw() {\n    this.objects.forEach((obj) => {\n      obj.draw();\n    })\n  }\n}\n\nclass ColoredBlock {\n  constructor(x, y, w, h, c) {\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n    this.color = c;\n  }\n  \n  draw() {\n    let screen_width_in_rgb_pixels = feature.screenWidth * RGB_PIXEL_SIZE;\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        for(let rgbOffset = 0; rgbOffset < this.color.pixels.length; rgbOffset++){\n          let xPos = (this.x + i) * RGB_PIXEL_SIZE + rgbOffset;\n          let yPos = (this.y + j) * screen_width_in_rgb_pixels;\n          feature.screen[xPos + yPos] = this.color.pixels[rgbOffset];\n        }\n      }\n    }\n  }\n}","version":"18977","position":[0.25,2.25,-7.75],"rotation":[0,3.14159,0]},{"type":"lantern","uuid":"e52db9b4-7793-4e51-8957-567ca1e9ee8a","color":"#ff00aa","scale":[-0.2,0.2,9.6],"version":"16168","position":[3.5,3.5,-2],"rotation":[0,0,0],"strength":"15"},{"type":"vid-screen","uuid":"ee6404e3-92c7-4fed-b318-2ad978913ded","scale":[2,2,0],"script":"\nlet distance, playing, ground, Y, V, W;\n\nconst reset = ()=>\n{\n    Y = 0;\n    W = 22;\n    distance = V = 0;\n    playing = 1;\n}\n\nfeature.on('start', e=> \n{\n    reset();\n});\n\nfeature.on('frame', e=> \n{\n    clearScreen();\n    playing && ++distance;\n\n    // draw ground\n    for (let i=5; i--;)\n    {\n        const j = i+distance/W|0;\n        setDrawColorHSLA(j/29);\n        const g = 47-Math.cos(j*j)*15|0;\n        drawRectOutline(j*W-distance-7, g, W-3, 1e4);\n        i && (ground=g);\n    }\n\n    // sub step physics\n    for (let i=2; i--;)\n    {\n        Y -= V -= .06;\n        if (Y > ground)\n        {\n            // check for safe landing\n            V = 0;\n            Y < ground+3 ? Y = ground : playing = 0;\n        }\n    }\n    \n    // draw player\n    setDrawColorHSLA(distance/50, 1, .7);\n    drawRect(9, Y-9, 6, 9);\n\n    // draw score\n    setDrawColorHSLA(0, 0, 1);\n    drawNumber(distance/W|0, 24, 0);\n});\n\nfeature.on('keys', e=>\n{\n    // jump\n    if (e.keys.a)\n        Y-ground || (V=2);\n    if (e.keys.b)\n        reset();\n});\n\n/////////////////////////////////////////////////////////////////////////\n// vidscreen helper functions by frank force\n\nconst clamp       = (v, max=1, min=0)=> v < min ? min : v > max ? max : v;\nconst percent     = (v, a, b)=>         b-a ? clamp((v-a) / (b-a)) : 0;\nconst lerp        = (p, a, b)=>         a + clamp(p) * (b-a);\nconst clearScreen = (v=0)=>             feature.screen.fill(v);\nconst seededRand  = (seed, max=1)=>     Math.sin(seed)**2 * 1e9 % 1 * max;\n\nlet drawColor = [255, 255, 255, 1];\nconst setDrawColorRGBA = (r=0, g=0, b=0, a=1)=> drawColor = [r, g, b, a];\nconst setDrawColorHSLA = (h=0, s=1, l=.5, a=1)=>\n{\n    let r, g, b;\n    if (s)\n    {\n        const f = (p, q, t)=>\n        {\n            t = ((t%1)+1)%1;\n            return t < 1/6 ? p+(q-p)*6*t :\n                t < 1/2 ? q :\n                t < 2/3 ? p+(q-p)*(2/3-t)*6 : \n                p;\n        }\n\n        const q = l < .5 ? l*(1+s) : l+s-l*s, p = 2*l-q;\n        r = f(p, q, h + 1/3);\n        g = f(p, q, h);\n        b = f(p, q, h - 1/3);\n    }\n    else\n        r = g = b = l;\n\n    setDrawColorRGBA(r*255, g*255, b*255, a);\n}\n\nconst drawPixel = (x, y)=>\n{\n    const a = drawColor[3];\n    if (a <= 0 || x < 0 || x >= feature.screenWidth || y < 0 || y >= feature.screenHeight)\n        return;\n\n    const i = 3*((x|0) + (y|0)*feature.screenWidth);\n    if (a == 1)\n    {\n        feature.screen[i+0] = drawColor[0]|0;\n        feature.screen[i+1] = drawColor[1]|0;\n        feature.screen[i+2] = drawColor[2]|0;\n        return;\n    }\n\n    // draw pixel with alpha\n    const r = feature.screen[i+0] || 0;\n    const g = feature.screen[i+1] || 0;\n    const b = feature.screen[i+2] || 0;\n    feature.screen[i+0] = lerp(a, r, drawColor[0], 255)|0;\n    feature.screen[i+1] = lerp(a, g, drawColor[1], 255)|0;\n    feature.screen[i+2] = lerp(a, b, drawColor[2], 255)|0;\n}\n\nconst drawRect = (x, y, w, h)=>\n{\n    for (let i = x; i < x + w; ++i)\n    for (let j = y; j < y + h; ++j)\n        drawPixel(i,j);\n}\n\nconst drawRectOutline = (x, y, w, h)=>\n{\n    for (let i = x; i < x + w; ++i)\n        drawPixel(i,y), drawPixel(i,y+h-1);\n    for (let i = y; i < y + h; ++i)\n        drawPixel(x,i), drawPixel(x+w-1,i);\n}\n\nconst drawNumber = (n,x,y)=>\n{\n    n = (n|0)+'';\n    for (const j of n)\n    {\n        for (let i=7;i--;)\n            '{\u0018O\u001f<7w\u001a?'.charCodeAt(j)&2**i&&drawRect(i>4|i<3?x:x+5,y+(i%2?1:i?5:9)-1,i>2?2:7,i>2?5:1);\n        x += 9;\n    }\n}","version":"16168","position":[3.75,2.25,-6.25],"rotation":[0,1.5707963267948966,0]},{"type":"lantern","uuid":"0cdc82f6-43e8-4d5a-b8f1-8943ad13b866","color":"#3141b9","scale":[-0.2,0.2,10.1],"version":"16168","position":[-7.7,3.95,4.5],"rotation":[0,0,0],"strength":"10"}],"settings":{"sandbox":false,"hosted_scripts":false},"voxels":"eJztm9GOozAMACn34/vpq4rtQcEJJjbg4HEetkpgGhxnBFT7+nm5tn8h2/AX8J7O82MuyX5nw4vVPtaK6r/BNeBF5Pmt/Fn+G30ud4Bn5Z3jv7j3f06J+58/ePF42pXfr5GP/0a3nTJx4/ogG29q4zAO0l/8t5c/ePF4fiuP/57Ow3+2/MGLx8N/8LQ8nf/0XsR/8O7m4T94Wl42/1l2w2tzloX3vjpPnhR5eT4rjv+ezpsa/tME/uuH50Oe/ec7m7g+yMbL5j9LtiRfWWi+PCly8vAfPC0P/+kD//XBw3/wtDz8pw/81wcP/8HT8vDfsWyte+DF47WuuMzDf0/m5fRf66+B8/nw4vLs/lueHdF/8Lx4st/wnybmVXjz1jO38uyRldfqP5nX7j+Z9/0J3h28o/7TemVrgaj+25pazpNuPc7g1Y6EV+K11UNtftN+kI/crns8Xo2QlYf/dBnX7194MXj+/huH8v3GmqDx1Z28euTh4T9dxvv3QTbetf5bh9VXZ/PqkYfnbRX8By8GD/+1Rx4e/tPmqTbagw+y8fBfe+ThSZXwfuZdNvx39v6dr9KHt46MvHI9y/W9Pz/89zye3X/rIz7kJ/tPmlUk3rI/K6+tHmrzO7LXSr6KwitFXt7xNpmvZMgn+688Di8Kz8d/y+/z8FUU3l5k4r1Z+G8/R5pxeFF4+M8SmXhr/9ne/+E/eBF4+M8SmXit/vuMysf04j+//QEvEm9uml8/8F9enuX5t3f/HcmRZRze1TzferjbV/jvPF6r/+oN/8G7k4f/LJGJl/n935EcWcbhXc3Df5bIxMN/uhxZxuFdzcN/lsjE4/lXlyO5H15Mnk89LMeP7LcredMdSh7eOeux147eE/bsv+14C+Ue3vfq5OW11kV5fqP4/fJVRODNOxWevV50/pt58f1Xrrdtn7xTv3vhReIdr4e9+ZX/S1maMby+eLVqkPy3x8N/8O7k7dVzi/9K1S+9M4fXFy+f/+zhQ4F3Bs/ff+X+tvsXeJF43vXyCz6Z2v8=","owner":"0x5AB52E17133a2D545b806a468b47650b077985Dc","lightmap_status":"Baked","parcel_users":null,"description":"Research & Development of Cryptovoxel multiplayer games. ","name":"3 Quantic Expressway","label":"music","address":"3 Quantic Expressway","suburb":"Punks","island":"Origin City","x1":187,"y1":0,"z1":-468,"x2":204,"y2":8,"z2":-448,"tileset":false,"palette":["#fffcfa","#515151","#80ff80","#0000ff","#9e00db","#9e9e9e","#ff1717","#fffb96"],"is_common":false,"visible":true,"kind":"plot"}}