{"success":true,"parcel":{"id":7522,"hash":"9af2543a5119f54788e72f6f13a1b8eac6ee89b8","features":[{"type":"image","scale":[1,1,0],"url":"","position":[0,1.25,-0.25],"rotation":[0,-1.575,0],"version":"25687","uuid":"d6cccaac-23ec-42d2-8782-3a657e345cb4","script":"// Helpers\n\n/**\n * Parses ipfs:// and ar:// links and IPFS hashes to URLs.\n * @param {String} uri The ipfs:// link or IPFS hash.\n * @returns A formatted URL to the IPFS resource.\n */\n const parseProtocol = uri => {\n  if (uri.substring(0,4) === \"ipfs\") {\n    return `https://ipfs.zesty.market/ipfs/${uri.substring(7)}`;\n  } else if (uri.substring(0,4) === \"http\") {\n    return uri;\n  } else if (uri.substring(0,5) === \"https\") {\n    return uri;\n  } else if (uri.substring(0,2) === \"ar\") {\n    // get redirected url\n    fetch(`https://arweave.net/${uri.substring(5)}`)\n      .then(res => {\n        return res.url;\n      })\n      .catch(err => {\n        console.error(err);\n      })\n\n  } else {\n    // default to ipfs\n    return `https://ipfs.zesty.market/ipfs/${uri}`;\n  }\n}\n\nconst getIPFSGateway = () => {\n  const gateways = [\n    { gateway: 'https://cloudflare-ipfs.com', weight: 35 },\n    { gateway: 'https://gateway.pinata.cloud', weight: 35 },\n    { gateway: 'https://dweb.link', weight: 30 }\n  ];\n\n  const weights = [];\n  let i;\n  for (i = 0; i < gateways.length; i++) {\n    weights[i] = gateways[i].weight + (weights[i - 1] || 0);\n  }\n  const random = Math.random() * weights[weights.length - 1];\n  for (i = 0; i < weights.length; i++) {\n    if (weights[i] > random) break;\n  }\n  return gateways[i].gateway;\n}\n\n// Formats\nconst formats = {\n  'tall': {\n      width: 0.75,\n      height: 1,\n      style: {\n          'standard': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-tall.png`,\n          'minimal': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-tall-minimal.png`,\n          'transparent': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-tall-transparent.png`\n      }\n  },\n  'wide': {\n      width: 4,\n      height: 1,\n      style: {\n          'standard': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-wide.png`,\n          'minimal': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-wide-minimal.png`,\n          'transparent': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-wide-transparent.png`\n      }\n  },\n  'square': {\n      width: 1,\n      height: 1,\n      style: {\n          'standard': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-square.png`,\n          'minimal': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-square-minimal.png`,\n          'transparent': `${getIPFSGateway()}/ipns/lib.zesty.market/assets/zesty-banner-square-transparent.png`\n      }\n  }\n}\n\nconst defaultFormat = 'square';\nconst defaultStyle = 'standard';\n\n// Networking\nconst API_BASE = 'https://beacon.zesty.market'\nconst BEACON_GRAPHQL_URI = 'https://beacon2.zesty.market/zgraphql'\n\n\nconst ENDPOINTS = {\n    \"matic\": 'https://api.thegraph.com/subgraphs/name/zestymarket/zesty-market-graph-matic',\n    \"polygon\": 'https://api.thegraph.com/subgraphs/name/zestymarket/zesty-market-graph-matic',\n    \"rinkeby\": 'https://api.thegraph.com/subgraphs/name/zestymarket/zesty-market-graph-rinkeby'\n}\n\nconst DEFAULT_DATAS = {\n  \"uri\": undefined,\n}\n\nconst DEFAULT_URI_CONTENT = {\n  \"name\": \"Default banner\",\n  \"description\": \"This is the default banner that would be displayed ipsum\",\n  \"image\": \"https://ipfs.zesty.market/ipfs/QmWBNfP8roDrwz3XQo4qpu9fMxvUSTn8LB7d4JK7ybrfZ2/assets/zesty-ad-square.png\",\n  \"url\": \"https://www.zesty.market\"\n}\n\n/**\n * Queries The Graph to retrieve NFT information for the space.\n * @param {string} space The space ID\n * @param {string} creator The wallet address of the creator\n * @param {string} network The network to post metrics to\n * @returns An object with the requested space information, or a default if it cannot be retrieved.\n */\nconst fetchNFT = async (space, network = 'polygon') => {\n    const currentTime = Math.floor(Date.now() / 1000);\n    const query = {\n      query: `\n        query {\n          tokenDatas (\n            where: {\n              id: \"${space}\"\n            }\n          )\n          { \n            sellerNFTSetting {\n              sellerAuctions (\n                first: 5\n                where: {\n                  contractTimeStart_lte: ${currentTime}\n                  contractTimeEnd_gte: ${currentTime}\n                  cancelled: false\n                }\n              ) {\n                id\n                buyerCampaigns {\n                  id\n                  uri\n                }\n                buyerCampaignsApproved\n                buyerCampaignsIdList\n              }\n            }\n            id\n          }\n        }\n      `\n    };\n  return fetch(ENDPOINTS[network], {\n    method: 'POST',\n    mode: 'cors',\n    body: JSON.stringify(query)\n  })\n  .then((res) => {\n    return parseGraphResponse(res);\n  })\n  .catch((err) => {\n    console.log(err);\n    return DEFAULT_DATAS;\n  })\n};\n\n/**\n * Parses the response from The Graph to find the latest auction campaign.\n * @param {Object} res The response object from The Graph.\n * @returns An object containing either the latest auction campaign or default data.\n */\nconst parseGraphResponse = async (res) => {\n  let body = await res.json();\n  let tokenDatas = body.data.tokenDatas;\n  if (tokenDatas.length == 0) return DEFAULT_DATAS;\n\n  let sellerAuction = body.data.tokenDatas[0].sellerNFTSetting.sellerAuctions[0];\n  let latestAuction = null;\n  for (let i=0; i < sellerAuction.buyerCampaignsApproved.length; i++) {\n    if (sellerAuction.buyerCampaignsApproved[i] && sellerAuction.buyerCampaigns.length > 0) {\n      latestAuction = sellerAuction.buyerCampaigns[i];\n    }\n  }\n\n  if (latestAuction == null) {\n    return DEFAULT_DATAS\n  }\n\n  return latestAuction;\n}\n\n// Helpers for UTM parameters\nconst urlContainsUTMParams = (url) => {\n  return url.indexOf('utm_source=') !== -1 || url.indexOf('utm_campaign=') !== -1 || url.indexOf('utm_channel=') !== -1;\n}\n\nconst appendUTMParams = (url, spaceId) => {\n  let new_url = new URL(url)\n  new_url.searchParams.set('utm_source', 'ZestyMarket');\n  new_url.searchParams.set('utm_campaign', 'ZestyCampaign');\n  new_url.searchParams.set('utm_channel', `SpaceId_${spaceId}`);\n  return new_url.href;\n}\n\n/**\n * Pulls data from IPFS for the banner content.\n * @param {string} uri The IPFS URI containing the banner content.\n * @param {string} format The default banner image format to use if there is no active banner.\n * @param {string} style The default banner image style to use if there is no active banner.\n * @param {string} formatsOverride Object to override the default format object.\n * @returns An object with the requested banner content, or a default if it cannot be retrieved.\n */\n const fetchActiveBanner = async (uri, format, style, space, formatsOverride) => {\n  if (!uri) {\n    let bannerObject = { uri: 'DEFAULT_URI', data: DEFAULT_URI_CONTENT };\n    let newFormat = format || defaultFormat;\n    let newStyle = style || defaultStyle;\n    let usedFormats = formatsOverride || formats;\n    bannerObject.data.image = usedFormats[newFormat].style[newStyle];\n    return bannerObject;\n  }\n\n  let res = await fetch(parseProtocol(uri));\n  let data = await res.json();\n  let url = res.url;\n  if(!urlContainsUTMParams(res.url)) {\n    url = appendUTMParams(res.url, space);\n  }\n\n  return res.status == 200 ? { uri: url, data: data } : null\n}\n\nfunction sendOnLoadMetric(space) {\n  try {\n    const spaceCounterEndpoint = API_BASE + `/api/v1/space/${space}`\n    fetch(spaceCounterEndpoint, { method: 'PUT' });\n\n    fetch(\n      BEACON_GRAPHQL_URI,\n      { \n        method: 'POST',\n        mode: 'no-cors',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(`mutation { increment(eventType: visits, spaceId: \"${space}\") { message } }`)\n      }\n    );\n  } catch (e) {\n    console.log(\"Failed to emit onload event\", e.message)\n  }\n}\n\nconst sendOnClickMetric = async (space) => {\n  try {\n    const spaceClickEndpoint = API_BASE + `/api/v1/space/click/${space}`\n    fetch(spaceClickEndpoint, { method: 'PUT' });\n\n    fetch(\n      BEACON_GRAPHQL_URI,\n      { \n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(`mutation { increment(eventType: clicks, spaceId: \"${space}\") { message } }`)\n      }\n    );\n  } catch (e) {\n    console.log(\"Failed to emit onclick event\", e.message)\n  }\n}\n\nasync function loadBanner(space, network, format, style, beacon = true) {\n  let uri = null;\n  const activeNFT = await fetchNFT(space, network);\n  if (activeNFT) uri = activeNFT.uri;\n\n  const activeBanner = await fetchActiveBanner(uri, format, style, space);\n\n  // Need to add https:// if missing for page to open properly\n  let url = activeBanner.data.url;\n  url = url.match(/^http[s]?:\\/\\//) ? url : 'https://' + url;\n\n  if (url == 'https://www.zesty.market') {\n    url = `https://app.zesty.market/space/${space}`;\n  }\n\n  let image = activeBanner.data.image;\n  image = image.match(/^.+\\.(png|jpe?g)/i) ? image : parseProtocol(image);\n\n  if (beacon) {\n    sendOnLoadMetric(space);\n  }\n\n  feature.set({'url': image}); \n  feature.set({'link': url});\n}\n\n// Call loadBanner here. Parameters are:\n// Space ID, Network, Format, Style, Enable Beacon (optional)\nfeature.on('click', e =>{\n  sendOnClickMetric(89);\n});\n\nparcel.on('playerenter', e =>{\n  loadBanner(89, 'polygon', \"square\", \"transparent\");\n});\n","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":true,"uScale":1,"vScale":1,"blendMode":"Combine"}],"settings":{},"voxels":"eJzt3DEOgDAMBEHyc57OF1wgLUYzbq9IsXXOfaK7Buz27r7d1WTFXl2n772OvfRHSX+U9EdJf5T0R0l/lPRHSX+U9EdJf5T0R0l/lPRHSX+U9EdJf5T0R0l/lPRHSX+U9EdJf5T0R0l/lPRHSX+U9EdJf5T0R0l/lPRHSX+U9EdJf5T0R0l/lP7yT77d1t3sHnAKs4Y=","owner":"0x1ce139b73DBC1d855e4B360856aC3885558Fc5F8","lightmap_status":"None","parcel_users":[{"wallet":"0x108013ece48fecbc3dd03ff42af005e52d08fc7f","role":"contributor"}],"description":null,"name":null,"label":null,"address":"31 Corte Spritz Veneziano","suburb":"Santa Croce","island":"Venice","x1":-1890,"y1":0,"z1":-864,"x2":-1870,"y2":8,"z2":-854,"palette":["#e37c59","#888888","#000000","#db398a","#01cdfe","#05ff16","#b967ff","#fffb96"],"is_common":false,"visible":true,"kind":"plot"}}