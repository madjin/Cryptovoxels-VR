{"success":true,"parcel":{"id":958,"hash":"b64c2cdcc748021ae2b6ca8434b3f4b7686ee8a3","features":[{"url":"https://ipfs.infura.io/ipfs/QmQTtxTKHS1SZTsHJDYUaawe93rkVgsJq9TDj8K4wjp6LF","type":"image","uuid":"91c4ae62-185e-446b-986f-d940069f6409","scale":[2,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.75,3.25,5.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmQTtxTKHS1SZTsHJDYUaawe93rkVgsJq9TDj8K4wjp6LF","type":"image","uuid":"1d0e5071-6d29-43da-9911-3ec86b513b5c","scale":[2,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[8.5,6.75,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/Qmazt5f2fWs9e6AAWBsB85ds9oePzzmA4zHyr44yvweUMK","link":"https://tenfinney.com","type":"image","uuid":"97b84866-46f7-411c-9a24-2fa8760195b8","scale":[4,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.1","position":[-9.25,3.75,-1.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmTGoTZkzSmFRvDsrL835SjzCd66vRTUFSrvXhacauWffU","link":"https://www.cryptovoxels.com/play?coords=S@296E,68S","type":"image","uuid":"625c2855-0243-40d0-887e-f66f87077bab","scale":[0.5,0.5,0],"stretch":true,"version":"5.38.1","position":[0,6,7.25],"rotation":[0,0,3.14],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmU4yctBmeL2E1uzwCwx1oELuhMrc5SkYSWK6g4CHkz9SZ","type":"vox-model","uuid":"c578bd2a-8fac-4c1c-b5d4-5274421e621b","flipX":true,"scale":[13.5,0.5,39.1],"version":"5.38.1","position":[0.65,10.6,7.2],"rotation":[0,1.57,1.57]},{"url":"https://ipfs.infura.io/ipfs/QmU4yctBmeL2E1uzwCwx1oELuhMrc5SkYSWK6g4CHkz9SZ","type":"vox-model","uuid":"242313a6-69d0-40d1-ab39-59598d17f7c0","flipX":true,"scale":[13.5,1,30],"version":"5.38.1","position":[-9.2,13.3,-0.1],"rotation":[3.14,0,1.57]},{"url":"https://ipfs.infura.io/ipfs/QmU4yctBmeL2E1uzwCwx1oELuhMrc5SkYSWK6g4CHkz9SZ","type":"vox-model","uuid":"327723ae-2f35-42bb-89a6-5508befa10e6","flipX":true,"scale":[13.5,1,30],"version":"5.38.1","position":[9.6,10.55,-0.3],"rotation":[0,3.14,1.57]},{"url":"https://ipfs.infura.io/ipfs/QmTGoTZkzSmFRvDsrL835SjzCd66vRTUFSrvXhacauWffU","link":"https://www.cryptovoxels.com/play?coords=S@297E,70S,4.5U","type":"image","uuid":"24e429ae-a11e-4f71-bb19-7e4f61f55312","scale":[0.5,0.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.1","position":[-5.4,11,7],"rotation":[0,0,3.14],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"link":"https://www.cryptovoxels.com/play?coords=S@297E,70S,4.5U","text":"Down 1 Floor","type":"sign","uuid":"41075669-e9e4-4b1b-9a06-0154b949b06c","color":"#000000","scale":[0.61875,0.5,0.5],"script":"","version":"5.38.1","fontSize":"24","position":[-6,11,7],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://opensea.io/assets/0x56cb47517bac9f8ae749b528400355423d24f037/121","type":"nft-image","uuid":"6f153c94-812b-4662-ab9c-8cdee9e5889c","color":false,"scale":[4,2,0],"script":"","stretch":true,"version":"5.38.1","hasFrame":true,"inverted":false,"position":[0.5,12.1,7.1],"rotation":[0,0,0]},{"url":"https://opensea.io/assets/0x56cb47517bac9f8ae749b528400355423d24f037/119","type":"nft-image","uuid":"9eb1778b-83ce-4f8a-a00e-b02b9ca6d74b","color":false,"scale":[4,2,0],"script":"","stretch":true,"version":"5.38.1","hasFrame":true,"inverted":false,"position":[-8.95,11.6,0.25],"rotation":[0,4.71238898038469,0]},{"text":"Escape to Infinity: Beehive Set 01","type":"sign","uuid":"c2c19673-bd54-4358-b2a7-3de62798197e","color":"#000000","scale":[1.6734375,0.5,0.5],"script":"","version":"5.32.0","fontSize":"22","position":[-1.25,3.05,3.6],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmbTEmLpqfoKuXj9eyW2bxwQwd7oQiBKyBYBNoBMtkFc42","link":"https://opensea.io/accounts/tenfinney","type":"image","uuid":"08fb0578-3e3b-4b88-b12e-b16368a8df61","scale":[2.1,1.1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-0.65,2.1,-2.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"text":"Escape to Infinity: Blast Set 04","type":"sign","uuid":"74045b78-342d-4125-bd17-9d528bbd7cd6","color":"#000000","scale":[1.575,0.5,0.5],"script":"","version":"5.32.0","fontSize":"22","position":[-0.75,3,-3.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmTSyfsdHtCaxKV1688ApUYaQ8Fs9WRSSBuAwG9fCCUqji","type":"vox-model","uuid":"aed4d0d3-8860-4e6d-a586-cf4f22ebb3e0","flipX":true,"scale":[4.1,2.2,0.5],"version":"5.32.0","position":[-0.55,1.4,-2.45],"rotation":[0,1.57,0]},{"url":"https://ipfs.infura.io/ipfs/QmVDeVyDnCmXCFQTbgbc5TW8VGjMtfCVDg7bUhwRhjADNr","type":"image","uuid":"73a73b1b-0e22-41a5-8061-ef8543f6b2ac","scale":[0.6,0.6,0],"stretch":false,"version":"5.32.0","position":[-1.25,2.15,-3.9],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVDeVyDnCmXCFQTbgbc5TW8VGjMtfCVDg7bUhwRhjADNr","type":"image","uuid":"1aa3abb9-b3f9-4d22-b91c-d59436d8e487","scale":[0.6,0.6,0],"stretch":false,"version":"5.37.0","position":[-1.25,3.25,1.25],"rotation":[0,1.57,0.52],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"text":"Each NFT Includes:","type":"sign","uuid":"cfd409fc-488e-4da9-bc5d-1ea6dd472fba","color":"#000000","scale":[0.8015625,0.5,0.5],"script":"","version":"5.32.0","fontSize":"20","position":[-0.75,3.05,1.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmWoeQUyak8ctwYX7XE6nSQGfQhreMaHt8GSMdDdEiHxHU","link":"https://opensea.io/accounts/tenfinney","type":"image","uuid":"ba02532d-9c8a-4698-a574-35b4cd536f5d","scale":[2,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-0.75,1.5,2],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/Qmd9uCdHXGBGhRNdwSPGc8d9Kgxwz2DCJU5NtitpGuLnkw","link":"https://opensea.io/accounts/tenfinney","type":"image","uuid":"1c00a928-7574-47a4-a3e5-3cfac5cc7fa3","scale":[1.5,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-0.75,2.7,3.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmZqzgDcEWwiHdPFiNgCFm5hEAJsRYbxPUaPgFdWdHgV4D","link":"https://opensea.io/accounts/tenfinney","type":"image","uuid":"56a50e3f-2249-4448-8fc5-4cef7191f52c","scale":[1.4,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-0.75,1.75,4],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVDeVyDnCmXCFQTbgbc5TW8VGjMtfCVDg7bUhwRhjADNr","type":"image","uuid":"7d498b11-2d2c-4175-94bf-32c4b2563b70","scale":[0.6,0.6,0],"stretch":false,"version":"5.32.0","position":[-0.75,2.95,2],"rotation":[0,4.71,0.52],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVDeVyDnCmXCFQTbgbc5TW8VGjMtfCVDg7bUhwRhjADNr","type":"image","uuid":"a5358aa0-6ddf-48e9-ae9c-dbbed3f30231","scale":[0.5,0.5,0],"stretch":false,"version":"5.37.0","position":[-0.65,3.1,-1.65],"rotation":[0,4.71,0.52],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmZSeeopT7v5VidBZFMkdEM2L4y5Xx3je3hLWmDDmNNjrS","link":"https://tenfinney.com","type":"image","uuid":"f6d312ab-5f81-45b8-8aeb-0c36ced0f174","scale":[3,2.2,0],"script":"","uScale":1,"vScale":1,"opacity":"1.00","stretch":true,"version":"27875","position":[10.05,2.85,-5.05],"rotation":[0,4.71239,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmbJjAiKBr43gsjF3yf1mW8Qv4UWeZUJRXoUTHJ1SVZVtV","link":"https://tenfinney.com","type":"image","uuid":"b9b5f0ba-84e1-4a2f-9ac6-e35cfb2d321d","scale":[2,2.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.37.0","position":[10.25,3,2],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmSNXdyyFL6Xz35UzcFsdiBFNw5Yigb4kNgnQCKmbTB3dQ","type":"vox-model","uuid":"244826bc-c9cf-4837-a63b-7d534d71c8e3","flipX":true,"scale":[3.4,2,4],"version":"5.38.0","position":[-10.85,6.25,8.55],"rotation":[0,4.71,0]},{"url":"https://ipfs.infura.io/ipfs/Qmac8Xvj7XrS7hpSZbeRn3NshRtebj2xG3qZLKmcrg6BBQ","type":"vox-model","uuid":"8c5686e7-5278-4800-9654-09a162530555","flipX":true,"scale":[3.4,2,4],"version":"5.38.0","position":[-8.2,6.25,9.15],"rotation":[0,1.5707963267948966,0]},{"url":"https://ipfs.infura.io/ipfs/QmQdnNrcQYViS2rMvYspPDseShrvQX5Psadg246oepPg1t","type":"image","uuid":"d8acefb4-8b1e-439d-a077-51d6745b392e","scale":[1.8,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.7,6.9,8.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmQnwkUxgMdQxV2KJJDuQzZbvrpQhEWw9PtwmLM8DfXSS5","type":"image","uuid":"f1649e1b-9164-471b-afb7-6643e37f7530","scale":[1.8,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.3,6.85,8.9],"rotation":[0,4.71,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/Qmac8Xvj7XrS7hpSZbeRn3NshRtebj2xG3qZLKmcrg6BBQ","type":"vox-model","uuid":"58d2e1b5-ce4c-49d9-9cec-5e8a4f0257cb","flipX":true,"scale":[3.4,2,4],"script":"","version":"5.38.0","position":[11.05,7.5,6.2],"rotation":[3.14,0,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmSNXdyyFL6Xz35UzcFsdiBFNw5Yigb4kNgnQCKmbTB3dQ","type":"vox-model","uuid":"1bcb0775-440e-4d2d-82e0-516e00127d86","flipX":true,"scale":[3.4,2,4],"version":"5.38.0","position":[11.6,7.5,8.85],"rotation":[0,0,3.14]},{"url":"https://ipfs.infura.io/ipfs/QmQnwkUxgMdQxV2KJJDuQzZbvrpQhEWw9PtwmLM8DfXSS5","type":"image","uuid":"a0ea0232-7e90-4abe-aeea-9ce659176404","scale":[1.8,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[11.35,6.85,7.3],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmQdnNrcQYViS2rMvYspPDseShrvQX5Psadg246oepPg1t","type":"image","uuid":"858d0149-4e3c-48c5-b46a-2b5229359c6c","scale":[1.8,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[11.35,6.85,7.7],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmQnwkUxgMdQxV2KJJDuQzZbvrpQhEWw9PtwmLM8DfXSS5","type":"image","uuid":"387876c1-dde1-4bfc-8aeb-d4a043b4192b","scale":[3,1.6,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-1,5,7.8],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmPsVaDkz1aRYPaq48NjKAYLaAb1wyUSJrjorKeMsnUYQa","link":"https://tenfinney.com","type":"image","uuid":"dd0bfc16-1ec6-44b2-9b99-383cd06e3b86","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[9.75,3,2],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/Qmc1xwQYmjsCvHUdjyKfsFH3KU4CBm4zNnwwsRkoGgDLMs","link":"https://tenfinney.com","type":"image","uuid":"5b73f1f8-13c3-44f5-8b69-c5481605901b","scale":[1.5,1.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"27734","position":[2.85,2.5,7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVGcLbViFz6DVpfp3FSbNYwRAPr8wbM7S6ipHJ4pkh1cc","link":"https://tenfinney.com","type":"image","uuid":"abec7401-dd07-43ed-a5d4-3a6e959c491b","scale":[1.5,1.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"27734","position":[4.75,2.5,7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false,"opacity":"1.00"},{"url":"https://ipfs.infura.io/ipfs/QmdeUBRrz9uNEamr4LfHKrGoz9uR3mFK2947CW3CTywEBc","link":"https://tenfinney.com","type":"image","uuid":"1ba63442-0b04-45ab-afb9-37784c90a455","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[9.75,3,5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmPsVaDkz1aRYPaq48NjKAYLaAb1wyUSJrjorKeMsnUYQa","link":"https://tenfinney.com","type":"image","uuid":"e9b14b3f-4212-429e-9fa6-c38a480a6ed8","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[10.25,3,5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVGcLbViFz6DVpfp3FSbNYwRAPr8wbM7S6ipHJ4pkh1cc","link":"https://tenfinney.com","type":"image","uuid":"c32b49c3-bcdc-49c1-a0f3-796f7c503f5a","scale":[1.8,1.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"27734","position":[4.6,2.5,7.75],"rotation":[0,3.14159,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false,"opacity":"1.00"},{"url":"https://ipfs.infura.io/ipfs/QmfTkLfKjuyLpS7HVwqwcgSGRXTbgnmC5ncmFaqHpGgNYv","link":"https://tenfinney.com","type":"image","uuid":"2926dc95-e6ee-4468-a6a9-92fe9fe5085c","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.75,2.75,-4.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmbfXyJrJfF86GSKZV5fxFAQzbbw5cngHi36VZBhq1qkkJ","type":"image","uuid":"98bc3e8e-a734-4d0f-a75a-bccf035833a3","scale":[2,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.75,4.25,-4.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeid6xmqmhc5s2oev2pyftrxz3yiq3htpmqqbmc4ew7skj77tp4gjbi.ipfs.infura-ipfs.io","type":"image","uuid":"35971fef-9dc2-4925-91db-a73daf227299","scale":[1,0.8,0],"version":"6.12.8","position":[5.75,5.75,-3],"rotation":[0,1.5707963267948966,0]},{"url":"https://bafybeifu7eudc3hbjeyj3g4n3dzmzlvvffnburipc3ghj6i4unioottxca.ipfs.infura-ipfs.io","type":"image","uuid":"33c0de53-78d6-4321-b9b5-f003f608e33e","scale":[1.3,1.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[6.5,6.25,-3],"rotation":[1.57,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeicx3kh6yt4lr46w3ivvpvsybkxsiwhpyrylif3v2amnz3xxez7v24.ipfs.infura-ipfs.io","type":"image","uuid":"552833ac-415d-415c-897c-7ca57597e232","scale":[1.4,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[6.5,5.75,-2.25],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeicx3kh6yt4lr46w3ivvpvsybkxsiwhpyrylif3v2amnz3xxez7v24.ipfs.infura-ipfs.io","type":"image","uuid":"79130567-1cb6-4118-9852-c0c8c1ca1a14","scale":[1.4,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[6.5,5.75,2.75],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmQbnftWUhSthHWaWgkdzDecyosiHzLqCxmo7N7T5p38r3","type":"vox-model","uuid":"94466e14-1f69-4e38-9942-c5d2007faaf0","flipX":true,"scale":[1.5,1.5,1],"version":"7.0.5","position":[6.75,6.25,-3.25],"rotation":[0,-3.93,0]},{"url":"https://bafybeialwa63jqrxffkz2lha3bflwdumqoctqdimezknsfrm5jdgyeqjm4.ipfs.infura-ipfs.io","type":"image","uuid":"36f05cc5-f27a-45dc-81cb-061968a9a7eb","scale":[2,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[2.25,8.75,5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreigqyk66qdfssait7emtpn2rzycenmoafoygc2z6rrhvlt2vuqiaem.ipfs.infura-ipfs.io","type":"image","uuid":"0a2c2f1e-a3a9-48fb-a7e3-40f912c18c64","scale":[1.9,1.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[9.75,7.15,-5.65],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmeVwtLERkASnU6QYW8auxgenomeDrxSJts7xR7BnbJGAs","type":"megavox","uuid":"6677f121-2350-43c4-a098-0c2d8efcecd1","flipX":true,"scale":[0.6,0.8,0.6],"version":"6.12.8","position":[6.55,6.15,3.4],"rotation":[0,4.71,0]},{"url":"https://bafybeibopr3dkfuddq5mhznnzktqymrz5ghzt4rc7jxxpgl2dtgerseqyq.ipfs.infura-ipfs.io","type":"image","uuid":"389a4c50-c825-4058-a588-316d52c45c03","scale":[1,1,0],"version":"6.12.8","position":[7.25,8.5,-7.25],"rotation":[0,0,0]},{"url":"https://bafybeibopr3dkfuddq5mhznnzktqymrz5ghzt4rc7jxxpgl2dtgerseqyq.ipfs.infura-ipfs.io","type":"image","uuid":"431d6005-6070-4d1c-945d-dd20a4fca383","scale":[1,1,0],"version":"6.12.8","position":[5.75,8.5,-7.25],"rotation":[0,0,0]},{"url":"https://bafybeibopr3dkfuddq5mhznnzktqymrz5ghzt4rc7jxxpgl2dtgerseqyq.ipfs.infura-ipfs.io","type":"image","uuid":"04ac8f3e-237d-4c89-bf22-0a421d93978e","scale":[1,1,0],"version":"6.12.8","position":[4.25,8.5,-7.25],"rotation":[0,0,0]},{"url":"https://bafybeibopr3dkfuddq5mhznnzktqymrz5ghzt4rc7jxxpgl2dtgerseqyq.ipfs.infura-ipfs.io","type":"image","uuid":"1eb05021-7c72-4242-8578-4815ce1a9a7d","scale":[1,1,0],"version":"6.12.8","position":[2.75,8.5,-7.25],"rotation":[0,0,0]},{"url":"https://bafkreicussa3azuvhtk27tkbt6wq7fltsnohl6rpybfwxsxdybuxveohpm.ipfs.infura-ipfs.io","type":"image","uuid":"458fe22e-e550-4c0d-b9ec-5deeb9c34f78","scale":[2.5,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[9.75,7.5,-2.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeieb3rmye7zsqsi2ueubk65rt3bz7curxoly35ad2onhyhaybbx7ky.ipfs.infura-ipfs.io","type":"image","uuid":"4db3df53-a425-4a44-bf3d-76229d11d60a","scale":[2,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,8.75,-5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmdcHLdFnifWeBgizDZZFfn7vwJ98bcwVCdGCz74oL55eo","link":"https://tenfinney.com","type":"image","uuid":"d7dbbf50-8679-40cf-91c7-870e4823462f","scale":[1,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-1.25,2.65,-2],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"text":"Each NFT Includes:","type":"sign","uuid":"641a8a46-8a18-4805-8d51-c3b6f93f9651","color":"#000000","scale":[0.8015625,0.5,0.5],"script":"","version":"5.32.0","fontSize":"20","position":[-1.25,3.1,-3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"text":"\n\n| Magnifies        | Image    |\n| ----------- |:---------:|\n| Full-size          | 100%      |\n| Sec. 1.          | Right Tail  |\n| Sec. 2          | Southern Tail       |\n| Sec. 3.          | Channel Major       |\n\n","type":"richtext","uuid":"d040e16d-bc73-4480-a20c-bc549c4649e0","scale":[1.3,0.8,0],"script":"","version":"5.32.0","inverted":false,"position":[-1.25,2.6,-3.5],"rotation":[0,1.5707963267948966,0]},{"url":"https://opensea.io/assets/0x56cb47517bac9f8ae749b528400355423d24f037/82","type":"nft-image","uuid":"46f08c61-3492-48ef-9ac3-efd954765760","scale":[3,1.5,0],"hasGui":true,"version":"8.3.2","hasFrame":true,"position":[-1.25,2.1,2.75],"rotation":[0,1.57,0],"hasGuiResizable":false},{"link":"https://opensea.io/accounts/tenfinney","text":"Tenfinney on OpenSea","type":"sign","uuid":"4a91d0ba-a007-4caf-9b59-c9f3c868a40d","color":"#000000","scale":[0.7125,0.5,0.5],"script":"","version":"5.32.0","fontSize":"16","position":[-1.25,1.15,1.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"text":"201","type":"sign","uuid":"520a13a1-44bc-493e-aeef-1890db4f815a","color":"#1200ff","scale":[0.5,0.5,0.5],"script":"","version":"6.12.8","fontSize":"46","position":[1.75,6.5,4.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"3242b873-4b49-4cac-bad6-3264ef7189db","scale":[1.2,1.7,0],"stretch":false,"position":[-5.25,2,3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"d348f662-df20-44fd-a6fb-67316c669309","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[-5.25,3,3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"68b5c00d-9379-48a3-8d94-9ca3be170efa","scale":[1.2,1.7,0],"stretch":true,"position":[-6,2,2.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"30ab9a04-c7c0-4d8c-ab87-05fa54352d94","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[-6,3,2.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"d4b99e61-90b7-4ab9-8d57-c3b50e4b4525","flipX":true,"scale":[2,1,2],"position":[-2.15,13.5,0.45],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"23e78d91-1842-4df4-8592-f8a637757463","scale":[1.2,1.7,0],"stretch":false,"position":[4,2,3.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"3a2397be-1aaa-4116-bc7f-b5fc21a0c813","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[4,3,3.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"91dfe4c0-a34f-494e-a24e-dc90baa2853b","flipX":true,"scale":[2,1,2],"position":[8.2,13.5,0.4],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"5aba76fa-5183-40a3-a338-393a7455e368","flipX":true,"scale":[2,1,2],"position":[-7.65,13.5,-2.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"c04c1d6d-83cd-42c3-bbdc-e318091d28bc","flipX":true,"scale":[2,1,2],"position":[0.3,13.5,0.45],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmZBehqvqRGHosEM1FCS7JT322a5NiHiNmkTJqtDgTiEkY","type":"vox-model","uuid":"44988162-bdd5-4c09-997e-e5ff8fb191f0","flipX":true,"scale":[27,0.5,43.9],"position":[0.65,0.7,3.1],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"version":"27734"},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"a7025428-331d-425a-900b-ff0122e79481","flipX":true,"scale":[2,1,2],"position":[5.5,13.5,0.4],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"665c8ce6-c82b-416b-a7c2-8244422bd10b","flipX":true,"scale":[2,1,2],"position":[3,13.5,0.4],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"61c0b03a-6be6-4358-9532-606d3d247d23","scale":[1.2,1.7,0],"stretch":true,"position":[4.75,2,3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"0f2d3370-cef3-4892-8f5a-7910034bb36a","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[4.75,3,3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"ceeb1d2a-da2b-43f7-a310-6fe319fc46a4","scale":[1.2,1.7,0],"stretch":true,"position":[3.25,2,3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"27485d7a-1062-4d17-ba6c-72d112f6542d","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[3.25,3,3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"text":"204","type":"sign","uuid":"bd08debf-20b7-42a3-b305-898351ac672d","color":"#1200ff","scale":[0.5,0.5,0.5],"script":"","version":"6.12.8","fontSize":"46","position":[-1.25,8.5,-1.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"15d1b0f9-49a7-40b3-affa-2fab29dd2e82","flipX":true,"scale":[2,1,2],"position":[-5,13.5,-2.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"6d57b05d-0ae6-4ee8-ae39-af5d979d9878","scale":[1.2,1.7,0],"stretch":false,"position":[4,2,2.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"68ca294d-f0e3-46ec-8f11-c4e57e40ffab","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[4,3,2.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"450a7352-9eb8-48f9-81f5-e2a1307d2160","scale":[0.6,0.7,0],"stretch":true,"version":"5.32.0","position":[-1.25,7.2,1],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"c168b129-2b25-401c-a6e9-2e5a42b2ed09","flipX":true,"scale":[2,14,8],"position":[-9.3,9.35,-3.25],"rotation":[0,3.14,0],"animation":{"keyframes":[]}},{"text":"203","type":"sign","uuid":"7c234ae2-5243-421f-ad0c-80dac1bd58b8","color":"#1200ff","scale":[0.5,0.5,0.5],"script":"","version":"6.12.8","fontSize":"46","position":[1.75,6.75,-0.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"3588c8c2-4eef-4d25-b612-4569e0880ee5","scale":[1,0.5,0],"stretch":true,"version":"6.12.8","position":[-1.25,8.5,1.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmY1cYWe9uEqPZ1nCofmHCmBkeBvNWQaNTPkDrYa8fVBzZ","type":"image","uuid":"fa80b63a-871b-4d49-a2b9-f372161594d5","scale":[14.2,19.1,0],"stretch":true,"position":[0.25,9.75,0.3],"rotation":[-1.57,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"7a876d08-207f-4fff-8b9c-c7a068dcc593","flipX":true,"scale":[2,1,2],"position":[-7.65,13.5,-5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"145e49a1-095d-40a7-ba51-bf2ce70677eb","flipX":true,"scale":[2,1,2],"position":[-2.45,13.5,-2.3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"28416cb9-3a9e-4ef0-a7c8-5e3c0108d950","color":"#000000","scale":[0.75,0.5,0.5],"version":"5.32.0","fontSize":"16","position":[-1.25,6.7,0.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"0a6d5cf7-c2a1-487a-b00a-c2f215cf3e10","flipX":true,"scale":[2,1,2],"position":[8.25,13.5,-2.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"d184820a-cd93-4327-9fe0-812268f3f9ec","scale":[0.6,0.7,0],"stretch":true,"version":"5.32.0","position":[-1.25,7.2,0.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"ccbfc4e4-4848-4e92-bfd5-a3e7a6a49e02","flipX":true,"scale":[2,1,2],"position":[0.25,13.5,-2.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"41c111bc-6633-408f-98ee-203a53e64a80","flipX":true,"scale":[2,1,2],"position":[5.5,13.5,-2.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"4d15d0a7-5a1a-4876-84cc-73c8f95867a7","flipX":true,"scale":[2,1,2],"position":[2.9,13.5,-2.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"c5ffe25c-f282-4676-941d-5306b666ed3e","scale":[0.6,0.7,0],"stretch":true,"version":"6.12.8","position":[1.75,7.75,-0.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"02e44b29-abf9-4d0d-885d-b19f358742a4","scale":[1,0.5,0],"stretch":true,"version":"6.12.8","position":[1.75,8.5,-0.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"81a1f0b9-f376-45d1-bcc9-ef92cc44c203","flipX":true,"scale":[2,1,2],"position":[-5,13.5,-5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"fd691799-fc5e-4aa0-a0eb-baeac8e73f72","color":"#000000","scale":[0.75,0.5,0.5],"version":"6.12.8","fontSize":"16","position":[1.75,7.25,-0.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"a91b2511-f790-44de-80ae-6de7857bd1d7","scale":[0.6,0.7,0],"stretch":true,"version":"6.12.8","position":[1.75,7.75,-1],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"894b0bba-d328-49ce-a919-63ad5dab6599","flipX":true,"scale":[2,1,2],"position":[-2.35,13.5,-5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"357988bc-33da-465e-8997-210ca305f359","flipX":true,"scale":[2.1,14,8],"version":"5.38.1","position":[9.8,9.35,-3.1],"rotation":[0,0,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"1fe57029-033f-40b2-b717-253889fdb985","flipX":true,"scale":[2,1,2],"position":[8.2,13.5,-5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"ec6d8cb0-d277-488b-8931-0088bb278aa8","flipX":true,"scale":[2,1,2],"position":[0.25,13.5,-5.05],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"d13ab8cf-de2c-426c-925e-35a541e7a700","flipX":true,"scale":[2,1,2],"position":[5.5,13.5,-5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"0649a685-ee4e-4716-9da3-1a6c17a85cdf","flipX":true,"scale":[2,1,2],"position":[2.9,13.5,-4.95],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPdWSXaYTPHEqpzeC896YBFzKTF9wVR8XbcFBHA4SUUnD","type":"image","uuid":"97836a52-0586-4df9-8652-0ee657abc828","scale":[3,1,0],"stretch":true,"version":"6.12.8","position":[10.25,5.5,-5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"a0f25c80-ff43-4cb1-9b41-8d022f2b26ea","scale":[0.6,0.7,0],"stretch":true,"version":"5.32.0","position":[-0.75,7.25,-3.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"d68d9844-3690-4e2b-953c-f598f2e2b8e1","scale":[1,0.5,0],"stretch":true,"version":"6.12.8","position":[-0.75,8.5,-3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"0eda952e-c9cd-46e6-8114-287c1e6a4b59","flipX":true,"scale":[2.1,2,7.3],"version":"5.38.1","position":[-5.95,9.65,-6.8],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPdWSXaYTPHEqpzeC896YBFzKTF9wVR8XbcFBHA4SUUnD","type":"image","uuid":"e19b4aef-187f-4cff-bf5d-48fe2af554e4","scale":[3.5,1,0],"stretch":true,"version":"5.32.0","position":[-7.5,8.5,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"f4f3a9a9-9852-49b1-9ef0-636194856b27","color":"#000000","scale":[0.75,0.5,0.5],"version":"5.32.0","fontSize":"16","position":[-0.75,6.75,-4],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"0a3d11a6-c473-4b44-a573-b90ffffcfcb8","scale":[0.6,0.7,0],"stretch":true,"version":"5.32.0","position":[-0.75,7.25,-4.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"656ae8d1-7930-424a-afb8-bc0ec7904c76","scale":[1,0.5,0],"stretch":true,"version":"6.12.8","position":[1.25,8.75,-5.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"d5315178-f11d-4c8a-8758-2d117ba86eee","scale":[0.6,0.7,0],"stretch":true,"version":"6.12.8","position":[1.25,7.75,-4.75],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"fd80063f-703c-458e-b3fa-f3e2a95217fb","color":"#000000","scale":[0.75,0.5,0.5],"version":"6.12.8","fontSize":"16","position":[1.25,7.25,-5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"1a66eadb-fe86-42ec-b9e2-29c2de429201","scale":[0.6,0.7,0],"stretch":true,"position":[1.25,8,-5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"text":"205","type":"sign","uuid":"2cea0227-df02-48b4-9dcf-b19f93204b44","color":"#1200ff","scale":[0.5,0.5,0.5],"script":"","version":"6.12.8","fontSize":"46","position":[1.25,6.75,-4.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"text":"206","type":"sign","uuid":"05da0da0-75ec-4945-ba0a-b23097149444","color":"#1200ff","scale":[0.5,0.5,0.5],"script":"","version":"6.12.8","fontSize":"46","position":[-0.75,8.5,-5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"01caa762-444e-4e9a-b3d3-f783c1901893","flipX":true,"scale":[2.1,2,7.3],"version":"5.38.1","position":[6.6,9.65,-6.8],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"a3a62056-1e39-46fc-a948-c78ef81804a3","flipX":true,"scale":[2.1,2,7.3],"version":"5.38.1","position":[0.35,9.65,-6.8],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/Qmevn4LEQoh2vNLm1secB6mmPK8cMu9jy9hk2dhj5vgA5b","type":"image","uuid":"08fac04a-15e6-43b3-9940-674d24ad6148","scale":[1.6,0.4,0],"stretch":true,"version":"17431","position":[4,4,-6.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmZYsZPgeQk9S7wz3GJ4acxBUtFDURQ2h4sh6R4TjCdC2X","type":"image","uuid":"ba2e7e38-f514-4a27-b815-9b8c058ae04e","scale":[1.5,0.4,0],"stretch":true,"version":"5.38.1","position":[5.2,4,-7.25],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://bafkreickhyosiie7dhxmjkg7bvgsygomxovimieccelih2leomuknaj5dq.ipfs.infura-ipfs.io/","type":"image","uuid":"95506f74-6085-4ba1-9eb5-190012886995","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[5.9,6.25,-2.4],"rotation":[1.57,1.57,-0.79],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihfl7wpr4knhhrx233w7cxfzog3nqo7awbqwg5mat755eweid2tuq.ipfs.infura-ipfs.io/","type":"image","uuid":"88fd46f3-c687-4ae7-ac03-e1c5cc5b72de","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[6,6.25,-3.65],"rotation":[1.57,4.71,4.71],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihrvcviicleurp4hvnzgversu47i6v6sxddeqpgnn4cjo5sle65aq.ipfs.infura-ipfs.io","type":"image","uuid":"564a0f1b-d0a7-4e41-9202-f9d25f9a8023","scale":[1.3,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[6.5,5.75,-3.75],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihfl7wpr4knhhrx233w7cxfzog3nqo7awbqwg5mat755eweid2tuq.ipfs.infura-ipfs.io/","type":"image","uuid":"bbd39398-db7c-4245-8ce7-78e77dd61209","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[6,6.25,4.05],"rotation":[1.57,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreigal55ky772jllfhhhn3qws2eniwpizzzezrikls7s7h7yxmcrw3e.ipfs.infura-ipfs.io/","type":"image","uuid":"7ad33aee-3f4c-43c3-92ec-fadae49a90cd","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[5.95,6.25,2.9],"rotation":[1.57,4.71,4.71],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreibdlunzkvlk5pppyvyibn33vibxr5dse7jw4p6e4ddealmvekutki.ipfs.infura-ipfs.io/","type":"image","uuid":"b0316e76-2f98-4f60-8e34-70ac1cb325b8","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[5.75,6.05,-2.4],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreibtcbu2oebnqix6mvkem6az35lhaoagak7tbscgvczkyaghmeqdky.ipfs.infura-ipfs.io/","type":"image","uuid":"9e34b22e-4c14-4cf2-9ebb-b8100c9f7e09","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[7.85,8.55,-6.75],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreidmtudgpw6mmgsl4t2fs72rrc6dinqf7ylkmk6fcfnn4mitntyy6m.ipfs.infura-ipfs.io/","type":"image","uuid":"80c5ec06-6964-4131-8569-71852ea7e222","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[9.75,8,-4.75],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreicinbeesadxqsaxwcoqtb6pm7xv2tbnm6xnrgmz5gd4ho22ag4uza.ipfs.infura-ipfs.io/","type":"image","uuid":"4f79134a-0cab-4eb9-95ea-4e5844940c8b","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[9.75,8,-1.25],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreidv6czfay26uxqvn64whnriusp7hxwskanonzhrlhmrc6g2stdcai.ipfs.infura-ipfs.io/","type":"image","uuid":"1e87a1e1-3675-4319-94c4-84c3e0e6486a","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[9.7,8.25,3.5],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihojaqelh6fydyrkxxqdlceafsritwdd6w42xndomihhcbymrncri.ipfs.infura-ipfs.io/","type":"image","uuid":"8219e865-1dc5-4ce6-a041-32d5f84b5444","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[2.25,8,6.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreiamonn2yk4sf7vvfck7htwimj6glttzxhkpnb5gb5v27wfio6zqtu.ipfs.infura-ipfs.io/","type":"image","uuid":"96d8af4a-999e-409c-9feb-67ed970f7b18","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[2.25,8.75,1.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreieulirnbkwkq7vr72vsmnrmm6myxrwickojmpfcndzn7ng7ztrmsa.ipfs.infura-ipfs.io/","type":"image","uuid":"bddf8f1e-541d-40c5-b232-aa8e102bcf03","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.5","position":[2.25,8.3,-2.1],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreicxegkth5tyg44co62q57xoa7bpq7ipledhh3fharcd5hemwp7mly.ipfs.infura-ipfs.io/","type":"image","uuid":"5d6d925f-3f4f-42d3-aaaf-716c01ef9acc","scale":[0.2,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"7.0.4","position":[1.75,7.15,-6.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"link":"https://www.cryptovoxels.com/play?coords=NW@385E,126S,0.5F","text":"Return to Start","type":"sign","uuid":"fb32cce8-a398-43d6-8b11-09a982d6e4c9","color":"#0003ff","scale":[0.84375,0.5,0.5],"script":"","version":"7.0.0","fontSize":"30","position":[5.75,6,7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://bafybeialwa63jqrxffkz2lha3bflwdumqoctqdimezknsfrm5jdgyeqjm4.ipfs.infura-ipfs.io","type":"image","uuid":"04ec822a-bb6e-4570-86a6-c6c6846bd4a6","scale":[3.1,1.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[8,8.35,7.8],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"text":"Calendar","type":"sign","uuid":"7f792156-25f7-404d-a5c3-c915d954794a","color":"#000bff","scale":[0.54375,0.5,0.5],"script":"","version":"7.0.4","fontSize":"30","position":[2.25,7.8,6.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://bafybeic6uhhxq6c34gjwypqm6qyzexihuobiycdjfrg2txfx4ockjgvabu.ipfs.infura-ipfs.io","type":"image","uuid":"505a0a28-3a8f-4d21-bb3f-30ee4591f8ad","scale":[0.9,1.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[2.25,7,6.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihrvcviicleurp4hvnzgversu47i6v6sxddeqpgnn4cjo5sle65aq.ipfs.infura-ipfs.io","type":"image","uuid":"5c6e63cd-ce0d-4e04-b76a-9ba235ad4c60","scale":[1.3,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[6.5,5.75,4.25],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreibd42pkh6hyfxviozke4lq5tnox4my5cbtyovjhzv3gq3qihr4ii4.ipfs.infura-ipfs.io","type":"image","uuid":"6eef0edf-b1ba-41a4-a630-ea1afb29f5fa","scale":[1.4,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[7.25,5.75,-3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeibplpl5eh5z5xmtgt5bxrywywz4lctb7e5scp7ar7tuze6jh326ba.ipfs.infura-ipfs.io","type":"image","uuid":"c491c7c1-ec32-4a26-9a25-a21458f384cf","scale":[0.9,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[5.75,5.75,3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"text":"Artist: Katy Arrington","type":"sign","uuid":"4e61c775-0b44-40c2-8e0f-d29f242181e0","color":"#000000","scale":[0.88,0.5,0.5],"fontSize":"16","position":[4.05,2,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff","version":"27734"},{"text":"Alice in Water","type":"sign","uuid":"89a41fed-2fe3-45f4-beb3-7375d12872ff","color":"#000000","scale":[0.56,0.5,0.5],"fontSize":"16","position":[4.05,2.1,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff","version":"27734"},{"url":"https://opensea.io/assets/0x2a46f2ffd99e19a89476e2f62270e0a35bbf0756/24922","type":"nft-image","uuid":"1f8aba34-e939-4bd3-881f-715eb87e3aa5","color":false,"scale":[1,1,0],"hasGui":true,"stretch":false,"version":"27734","hasFrame":true,"inverted":false,"position":[5.15,2,-7.3],"rotation":[0,0,0],"transparent":false,"hasGuiResizable":false,"emissiveColorIntensity":"0.50"},{"url":"https://opensea.io/assets/0x14896536904a202629fa125159c2d88703b09b88/2","type":"nft-image","uuid":"c4c0be77-c947-4e2a-8bee-e4b414b1c5e7","color":false,"scale":[2,1,0],"hasGui":true,"stretch":true,"version":"27734","hasFrame":true,"inverted":false,"position":[2.25,2,-7.3],"rotation":[0,0,0],"transparent":false,"hasGuiResizable":false,"emissiveColorIntensity":"0.50","nftFrameStyle":"classic"},{"text":"Waiting Room 41","type":"sign","uuid":"c69a7168-9caf-4c61-bbe1-3235332810bd","color":"#000000","scale":[0.703125,0.5,0.5],"fontSize":"20","position":[-3.25,1.85,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://opensea.io/assets/0xd0c402bcbcb5e70157635c41b2810b42fe592bb0/3","type":"nft-image","uuid":"3737d6c0-67e3-453d-920e-fbbbb1cdc1bb","color":false,"scale":[2.3,1,0],"stretch":true,"inverted":false,"position":[-5.1,2,-7.3],"rotation":[0,0,0]},{"text":"Artist: Alotta Money","type":"sign","uuid":"26235149-8289-4d6a-a7ca-cbaafb79f150","color":"#000000","scale":[1.5,0.5,0.5],"fontSize":"16","position":[-3.25,1.75,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPdWSXaYTPHEqpzeC896YBFzKTF9wVR8XbcFBHA4SUUnD","type":"image","uuid":"8cc239da-949e-4700-ae99-da798bbd60b9","scale":[20,10,0],"stretch":true,"position":[0.9,14.5,0.2],"rotation":[1.57,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVNwUSbTYjdTGGpUB1tJ4fQVNJWHfVSF7TdeoSqLTKqgh","type":"image","uuid":"b125529b-53a5-44fc-8ca6-dd42d1c3ed71","scale":[1,1,0],"stretch":true,"version":"5.32.0","position":[-8.75,8.9,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"3a2f29a9-2dfe-469f-b433-bf5fe366f23d","flipX":true,"scale":[2,1,2],"position":[-7.5,13.5,5.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"411d0b6a-e772-40fd-bc34-94de2f62a189","flipX":true,"scale":[2,14,7.3],"position":[-6.05,9.35,7.3],"rotation":[0,4.71,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"66fd818b-1989-443b-ae7d-b02db44f8aee","flipX":true,"scale":[2,1,2],"position":[-5,13.5,5.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/Qmcsn6rQQy1yifoQBQRrZGA5wgqsLh9V7GKEFtTRhxrcyR","type":"image","uuid":"8a2ce8e3-b1c5-4b42-8fa6-4eb4ec96cf45","scale":[19,4.6,0],"stretch":true,"version":"5.38.1","position":[0.25,12.05,7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"90bcce55-9298-49ae-a2d3-909f9be1899c","scale":[1.8,0.7,0],"stretch":true,"version":"27979","position":[-3.75,1.75,7.75],"rotation":[0,3.14159,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://www.cryptovoxels.com/play?coords=S@296E,68S","text":"Go to 1st Floor","type":"sign","uuid":"d5f26e1a-cf96-461c-98a8-2bfb680b01bd","color":"#000000","scale":[0.84375,0.5,0.5],"version":"5.38.1","fontSize":"24","position":[-8,11,6.85],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmTGoTZkzSmFRvDsrL835SjzCd66vRTUFSrvXhacauWffU","link":"https://www.cryptovoxels.com/play?coords=S@296E,65S","type":"image","uuid":"6d1aa0fd-b4cb-4533-bbdb-8f0ba4968cc7","scale":[0.5,0.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.1","position":[-7.35,11,6.85],"rotation":[0,0,3.14],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmPdWSXaYTPHEqpzeC896YBFzKTF9wVR8XbcFBHA4SUUnD","type":"image","uuid":"63756886-0f86-4d01-ae99-2dadba7a9a97","scale":[3,0.6,0],"stretch":true,"version":"6.12.8","position":[9.2,5.85,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPdWSXaYTPHEqpzeC896YBFzKTF9wVR8XbcFBHA4SUUnD","type":"image","uuid":"4bf50580-3e2e-4e3c-966b-a8d0acdd082a","scale":[4,0.6,0],"stretch":true,"version":"5.32.0","position":[-9.75,8.9,5.55],"rotation":[0,7.85,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"f15ca9a4-c8e0-419e-817c-968008be4f9e","flipX":true,"scale":[2,1,2],"position":[-2.5,13.5,5.7],"rotation":[0,6.28,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"2dc4a2c3-3699-4515-b1e1-db049d51dc6c","flipX":true,"scale":[2,1,2],"position":[8.2,13.5,5.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"0c90d4e0-e13d-45ec-a2c2-2c46461501b6","flipX":true,"scale":[2,14,7.3],"position":[0.2,9.35,7.3],"rotation":[0,4.71,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"5fb1851e-227a-480d-b993-96d0249b9027","flipX":true,"scale":[2,14,7.3],"position":[6.4,9.35,7.3],"rotation":[0,4.71,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"d19da3d5-4241-4b39-bfbb-fa96d9bb3a86","flipX":true,"scale":[2,1,2],"position":[0.25,13.5,5.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmQ4PmBZMiKkmKKPPkN3pEDFHtBCaVBrk4QCpWCQ7cTQ2r","type":"vox-model","uuid":"652c15a8-53a3-4648-a033-d1ff483ed36b","flipX":true,"scale":[34,33,3],"position":[-8.65,14.15,2.65],"rotation":[1.57,1.57,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"2601dc9f-deda-4b04-a80b-6a78c5820a05","flipX":true,"scale":[2,1,2],"position":[5.5,13.5,5.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"2f76d822-eb70-4ad7-85d1-f56bc7414284","flipX":true,"scale":[2,1,2],"position":[2.9,13.5,5.85],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmTGoTZkzSmFRvDsrL835SjzCd66vRTUFSrvXhacauWffU","link":"https://www.cryptovoxels.com/play?coords=S@297E,71S,9F","type":"image","uuid":"23fd2de4-01bf-48ed-b7c4-dbadd260a072","scale":[0.5,0.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.1","position":[0.75,6,7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"69f4dc08-fcf3-4506-9a63-cf6cab27ba51","flipX":true,"scale":[2,1,2],"position":[-7.5,13.5,3.15],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"d3c3228e-b162-4947-abf5-d46e25f46294","scale":[0.6,0.7,0],"stretch":true,"version":"5.32.0","position":[-1.25,7,6.9],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"cdc05258-677f-415a-a6b6-ca3519c8bab7","flipX":true,"scale":[2,14,8],"position":[-9.3,9.35,3.65],"rotation":[0,3.14,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"b7ad9c2f-d6d0-4913-9bf9-e5ba107b7884","scale":[1,0.5,0],"stretch":true,"version":"5.32.0","position":[-1.25,7.75,6.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"2f42c5c5-ad07-4c7b-8af5-05b64d3a4435","scale":[0.6,0.7,0],"stretch":true,"version":"6.12.8","position":[1.75,7.25,4.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"005654de-5ccc-4019-8284-c70f58467835","color":"#000000","scale":[0.75,0.5,0.5],"version":"5.32.0","fontSize":"16","position":[-1.25,6.5,6.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPXhSesYvtvQt1Wpbfqsra7iJo97crRMbwqdqD8SZkYND","type":"image","uuid":"c6c89f5d-c8fb-458c-a9fa-aafc07e67afb","scale":[1,0.5,0],"stretch":true,"version":"6.12.8","position":[1.75,8,3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"92425a8d-65a7-45aa-b477-d5e0d711f69e","scale":[0.6,0.7,0],"stretch":true,"version":"5.32.0","position":[-1.25,7,6.15],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"3b13cf6d-adf0-4c2a-95a8-5b4d1bc2cdb5","color":"#000000","scale":[0.75,0.5,0.5],"version":"6.12.8","fontSize":"16","position":[1.75,6.75,3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmUAWtR12UujsbCcXCA6bAzAoVHy1hccS3KbSES96SpHaq","link":"https://tenfinney.com","type":"image","uuid":"bcdb7870-eef6-4d91-83f5-edb1565aca23","scale":[1,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-1.25,1.85,-2.35],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmeeZY9JGNShvaATwqtLAJa6rq1sBx1JYet8ktFQF8WTsg","link":"https://tenfinney.com","type":"image","uuid":"b7fc7ac6-cb91-40b1-9f7b-83350a452da0","scale":[1,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-1.25,1.4,-3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreiaexajmztz5p4lqmae7ww7fxtvmysht7mf6dpf5mw6u7247eip7rm","type":"image","uuid":"ffcbeae7-41ef-42a8-bc45-c57d8bf476e8","scale":[3.5,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[10.25,5.25,-1.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/Qmac9UtKo1Z8ybnkNgJsPVbvcKTUns5DrFhJm5i1h1DAde","type":"image","uuid":"111713c4-6071-45f2-8301-7561207fc108","scale":[1,1,0],"script":"<style type=\"text/css\">\n  html,\n  body {\n    padding: 0;\n    margin: 0;\n  }\n  body {\n    background: #000;\n    color: white;\n    font-family: Arial, Helvetica, Sans-serif;\n  }\n  a:hover {\n    text-decoration: none;\n  }\n  canvas {\n    position: absolute;\n  }\n</style>\n\n<canvas id=\"theCanvas\" width=\"803\" height=\"400\"></canvas>\n<canvas id=\"interactionCanvas\" width=\"803\" height=\"400\"></canvas>\n\n\n<script>\n  //     D3.js 2.11\n  //     https://d3js.org/d3.v2.js\n  //     Copyright 2020 Mike Bostock\n  //     D3.js is distributed under the BSD license.\n\n  (function () {\n    function d3_class(ctor, properties) {\n      try {\n        for (var key in properties) {\n          Object.defineProperty(ctor.prototype, key, {\n            value: properties[key],\n            enumerable: false,\n          });\n        }\n      } catch (e) {\n        ctor.prototype = properties;\n      }\n    }\n    function d3_arrayCopy(pseudoarray) {\n      var i = -1,\n        n = pseudoarray.length,\n        array = [];\n      while (++i < n) array.push(pseudoarray[i]);\n      return array;\n    }\n    function d3_arraySlice(pseudoarray) {\n      return Array.prototype.slice.call(pseudoarray);\n    }\n    function d3_Map() {}\n    function d3_identity(d) {\n      return d;\n    }\n    function d3_this() {\n      return this;\n    }\n    function d3_true() {\n      return true;\n    }\n    function d3_functor(v) {\n      return typeof v === \"function\"\n        ? v\n        : function () {\n            return v;\n          };\n    }\n    function d3_rebind(target, source, method) {\n      return function () {\n        var value = method.apply(source, arguments);\n        return arguments.length ? target : value;\n      };\n    }\n    function d3_number(x) {\n      return x != null && !isNaN(x);\n    }\n    function d3_zipLength(d) {\n      return d.length;\n    }\n    function d3_splitter(d) {\n      return d == null;\n    }\n    function d3_collapse(s) {\n      return s.trim().replace(/\\s+/g, \" \");\n    }\n    function d3_range_integerScale(x) {\n      var k = 1;\n      while ((x * k) % 1) k *= 10;\n      return k;\n    }\n    function d3_dispatch() {}\n    function d3_dispatch_event(dispatch) {\n      function event() {\n        var z = listeners,\n          i = -1,\n          n = z.length,\n          l;\n        while (++i < n) if ((l = z[i].on)) l.apply(this, arguments);\n        return dispatch;\n      }\n      var listeners = [],\n        listenerByName = new d3_Map();\n      event.on = function (name, listener) {\n        var l = listenerByName.get(name),\n          i;\n        if (arguments.length < 2) return l && l.on;\n        if (l) {\n          l.on = null;\n          listeners = listeners\n            .slice(0, (i = listeners.indexOf(l)))\n            .concat(listeners.slice(i + 1));\n          listenerByName.remove(name);\n        }\n        if (listener)\n          listeners.push(\n            listenerByName.set(name, {\n              on: listener,\n            })\n          );\n        return dispatch;\n      };\n      return event;\n    }\n    function d3_format_precision(x, p) {\n      return (\n        p -\n        (x\n          ? 1 +\n            Math.floor(\n              Math.log(\n                x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)\n              ) / Math.LN10\n            )\n          : 1)\n      );\n    }\n    function d3_format_typeDefault(x) {\n      return x + \"\";\n    }\n    function d3_format_group(value) {\n      var i = value.lastIndexOf(\".\"),\n        f = i >= 0 ? value.substring(i) : ((i = value.length), \"\"),\n        t = [];\n      while (i > 0) t.push(value.substring((i -= 3), i + 3));\n      return t.reverse().join(\",\") + f;\n    }\n    function d3_formatPrefix(d, i) {\n      var k = Math.pow(10, Math.abs(8 - i) * 3);\n      return {\n        scale:\n          i > 8\n            ? function (d) {\n                return d / k;\n              }\n            : function (d) {\n                return d * k;\n              },\n        symbol: d,\n      };\n    }\n    function d3_ease_clamp(f) {\n      return function (t) {\n        return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n      };\n    }\n    function d3_ease_reverse(f) {\n      return function (t) {\n        return 1 - f(1 - t);\n      };\n    }\n    function d3_ease_reflect(f) {\n      return function (t) {\n        return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));\n      };\n    }\n    function d3_ease_identity(t) {\n      return t;\n    }\n    function d3_ease_poly(e) {\n      return function (t) {\n        return Math.pow(t, e);\n      };\n    }\n    function d3_ease_sin(t) {\n      return 1 - Math.cos((t * Math.PI) / 2);\n    }\n    function d3_ease_exp(t) {\n      return Math.pow(2, 10 * (t - 1));\n    }\n    function d3_ease_circle(t) {\n      return 1 - Math.sqrt(1 - t * t);\n    }\n    function d3_ease_elastic(a, p) {\n      var s;\n      if (arguments.length < 2) p = 0.45;\n      if (arguments.length < 1) {\n        a = 1;\n        s = p / 4;\n      } else s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n      return function (t) {\n        return (\n          1 + a * Math.pow(2, 10 * -t) * Math.sin(((t - s) * 2 * Math.PI) / p)\n        );\n      };\n    }\n    function d3_ease_back(s) {\n      if (!s) s = 1.70158;\n      return function (t) {\n        return t * t * ((s + 1) * t - s);\n      };\n    }\n    function d3_ease_bounce(t) {\n      return t < 1 / 2.75\n        ? 7.5625 * t * t\n        : t < 2 / 2.75\n        ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75\n        : t < 2.5 / 2.75\n        ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375\n        : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n    }\n    function d3_eventCancel() {\n      d3.event.stopPropagation();\n      d3.event.preventDefault();\n    }\n    function d3_eventSource() {\n      var e = d3.event,\n        s;\n      while ((s = e.sourceEvent)) e = s;\n      return e;\n    }\n    function d3_eventDispatch(target) {\n      var dispatch = new d3_dispatch(),\n        i = 0,\n        n = arguments.length;\n      while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n      dispatch.of = function (thiz, argumentz) {\n        return function (e1) {\n          try {\n            var e0 = (e1.sourceEvent = d3.event);\n            e1.target = target;\n            d3.event = e1;\n            dispatch[e1.type].apply(thiz, argumentz);\n          } finally {\n            d3.event = e0;\n          }\n        };\n      };\n      return dispatch;\n    }\n    function d3_transform(m) {\n      var r0 = [m.a, m.b],\n        r1 = [m.c, m.d],\n        kx = d3_transformNormalize(r0),\n        kz = d3_transformDot(r0, r1),\n        ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n      if (r0[0] * r1[1] < r1[0] * r0[1]) {\n        r0[0] *= -1;\n        r0[1] *= -1;\n        kx *= -1;\n        kz *= -1;\n      }\n      this.rotate =\n        (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) *\n        d3_transformDegrees;\n      this.translate = [m.e, m.f];\n      this.scale = [kx, ky];\n      this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;\n    }\n    function d3_transformDot(a, b) {\n      return a[0] * b[0] + a[1] * b[1];\n    }\n    function d3_transformNormalize(a) {\n      var k = Math.sqrt(d3_transformDot(a, a));\n      if (k) {\n        a[0] /= k;\n        a[1] /= k;\n      }\n      return k;\n    }\n    function d3_transformCombine(a, b, k) {\n      a[0] += k * b[0];\n      a[1] += k * b[1];\n      return a;\n    }\n    function d3_interpolateByName(name) {\n      return name == \"transform\" ? d3.interpolateTransform : d3.interpolate;\n    }\n    function d3_uninterpolateNumber(a, b) {\n      b = b - (a = +a) ? 1 / (b - a) : 0;\n      return function (x) {\n        return (x - a) * b;\n      };\n    }\n    function d3_uninterpolateClamp(a, b) {\n      b = b - (a = +a) ? 1 / (b - a) : 0;\n      return function (x) {\n        return Math.max(0, Math.min(1, (x - a) * b));\n      };\n    }\n    function d3_Color() {}\n    function d3_rgb(r, g, b) {\n      return new d3_Rgb(r, g, b);\n    }\n    function d3_Rgb(r, g, b) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n    }\n    function d3_rgb_hex(v) {\n      return v < 16\n        ? \"0\" + Math.max(0, v).toString(16)\n        : Math.min(255, v).toString(16);\n    }\n    function d3_rgb_parse(format, rgb, hsl) {\n      var r = 0,\n        g = 0,\n        b = 0,\n        m1,\n        m2,\n        name;\n      m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n      if (m1) {\n        m2 = m1[2].split(\",\");\n        switch (m1[1]) {\n          case \"hsl\": {\n            return hsl(\n              parseFloat(m2[0]),\n              parseFloat(m2[1]) / 100,\n              parseFloat(m2[2]) / 100\n            );\n          }\n          case \"rgb\": {\n            return rgb(\n              d3_rgb_parseNumber(m2[0]),\n              d3_rgb_parseNumber(m2[1]),\n              d3_rgb_parseNumber(m2[2])\n            );\n          }\n        }\n      }\n      if ((name = d3_rgb_names.get(format))) return rgb(name.r, name.g, name.b);\n      if (format != null && format.charAt(0) === \"#\") {\n        if (format.length === 4) {\n          r = format.charAt(1);\n          r += r;\n          g = format.charAt(2);\n          g += g;\n          b = format.charAt(3);\n          b += b;\n        } else if (format.length === 7) {\n          r = format.substring(1, 3);\n          g = format.substring(3, 5);\n          b = format.substring(5, 7);\n        }\n        r = parseInt(r, 16);\n        g = parseInt(g, 16);\n        b = parseInt(b, 16);\n      }\n      return rgb(r, g, b);\n    }\n    function d3_rgb_hsl(r, g, b) {\n      var min = Math.min((r /= 255), (g /= 255), (b /= 255)),\n        max = Math.max(r, g, b),\n        d = max - min,\n        h,\n        s,\n        l = (max + min) / 2;\n      if (d) {\n        s = l < 0.5 ? d / (max + min) : d / (2 - max - min);\n        if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n        else if (g == max) h = (b - r) / d + 2;\n        else h = (r - g) / d + 4;\n        h *= 60;\n      } else {\n        s = h = 0;\n      }\n      return d3_hsl(h, s, l);\n    }\n    function d3_rgb_lab(r, g, b) {\n      r = d3_rgb_xyz(r);\n      g = d3_rgb_xyz(g);\n      b = d3_rgb_xyz(b);\n      var x = d3_xyz_lab(\n          (0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X\n        ),\n        y = d3_xyz_lab(\n          (0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y\n        ),\n        z = d3_xyz_lab(\n          (0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z\n        );\n      return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n    }\n    function d3_rgb_xyz(r) {\n      return (r /= 255) <= 0.04045\n        ? r / 12.92\n        : Math.pow((r + 0.055) / 1.055, 2.4);\n    }\n    function d3_rgb_parseNumber(c) {\n      var f = parseFloat(c);\n      return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n    }\n    function d3_hsl(h, s, l) {\n      return new d3_Hsl(h, s, l);\n    }\n    function d3_Hsl(h, s, l) {\n      this.h = h;\n      this.s = s;\n      this.l = l;\n    }\n    function d3_hsl_rgb(h, s, l) {\n      function v(h) {\n        if (h > 360) h -= 360;\n        else if (h < 0) h += 360;\n        if (h < 60) return m1 + ((m2 - m1) * h) / 60;\n        if (h < 180) return m2;\n        if (h < 240) return m1 + ((m2 - m1) * (240 - h)) / 60;\n        return m1;\n      }\n      function vv(h) {\n        return Math.round(v(h) * 255);\n      }\n      var m1, m2;\n      h = h % 360;\n      if (h < 0) h += 360;\n      s = s < 0 ? 0 : s > 1 ? 1 : s;\n      l = l < 0 ? 0 : l > 1 ? 1 : l;\n      m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      m1 = 2 * l - m2;\n      return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n    }\n    function d3_hcl(h, c, l) {\n      return new d3_Hcl(h, c, l);\n    }\n    function d3_Hcl(h, c, l) {\n      this.h = h;\n      this.c = c;\n      this.l = l;\n    }\n    function d3_hcl_lab(h, c, l) {\n      return d3_lab(l, Math.cos((h *= Math.PI / 180)) * c, Math.sin(h) * c);\n    }\n    function d3_lab(l, a, b) {\n      return new d3_Lab(l, a, b);\n    }\n    function d3_Lab(l, a, b) {\n      this.l = l;\n      this.a = a;\n      this.b = b;\n    }\n    function d3_lab_rgb(l, a, b) {\n      var y = (l + 16) / 116,\n        x = y + a / 500,\n        z = y - b / 200;\n      x = d3_lab_xyz(x) * d3_lab_X;\n      y = d3_lab_xyz(y) * d3_lab_Y;\n      z = d3_lab_xyz(z) * d3_lab_Z;\n      return d3_rgb(\n        d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z),\n        d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z),\n        d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n      );\n    }\n    function d3_lab_hcl(l, a, b) {\n      return d3_hcl(\n        (Math.atan2(b, a) / Math.PI) * 180,\n        Math.sqrt(a * a + b * b),\n        l\n      );\n    }\n    function d3_lab_xyz(x) {\n      return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n    }\n    function d3_xyz_lab(x) {\n      return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n    }\n    function d3_xyz_rgb(r) {\n      return Math.round(\n        255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055)\n      );\n    }\n    function d3_selection(groups) {\n      d3_arraySubclass(groups, d3_selectionPrototype);\n      return groups;\n    }\n    function d3_selection_selector(selector) {\n      return function () {\n        return d3_select(selector, this);\n      };\n    }\n    function d3_selection_selectorAll(selector) {\n      return function () {\n        return d3_selectAll(selector, this);\n      };\n    }\n    function d3_selection_attr(name, value) {\n      function attrNull() {\n        this.removeAttribute(name);\n      }\n      function attrNullNS() {\n        this.removeAttributeNS(name.space, name.local);\n      }\n      function attrConstant() {\n        this.setAttribute(name, value);\n      }\n      function attrConstantNS() {\n        this.setAttributeNS(name.space, name.local, value);\n      }\n      function attrFunction() {\n        var x = value.apply(this, arguments);\n        if (x == null) this.removeAttribute(name);\n        else this.setAttribute(name, x);\n      }\n      function attrFunctionNS() {\n        var x = value.apply(this, arguments);\n        if (x == null) this.removeAttributeNS(name.space, name.local);\n        else this.setAttributeNS(name.space, name.local, x);\n      }\n      name = d3.ns.qualify(name);\n      return value == null\n        ? name.local\n          ? attrNullNS\n          : attrNull\n        : typeof value === \"function\"\n        ? name.local\n          ? attrFunctionNS\n          : attrFunction\n        : name.local\n        ? attrConstantNS\n        : attrConstant;\n    }\n    function d3_selection_classedRe(name) {\n      return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n    }\n    function d3_selection_classed(name, value) {\n      function classedConstant() {\n        var i = -1;\n        while (++i < n) name[i](this, value);\n      }\n      function classedFunction() {\n        var i = -1,\n          x = value.apply(this, arguments);\n        while (++i < n) name[i](this, x);\n      }\n      name = name.trim().split(/\\s+/).map(d3_selection_classedName);\n      var n = name.length;\n      return typeof value === \"function\" ? classedFunction : classedConstant;\n    }\n    function d3_selection_classedName(name) {\n      var re = d3_selection_classedRe(name);\n      return function (node, value) {\n        if ((c = node.classList)) return value ? c.add(name) : c.remove(name);\n        var c = node.className,\n          cb = c.baseVal != null,\n          cv = cb ? c.baseVal : c;\n        if (value) {\n          re.lastIndex = 0;\n          if (!re.test(cv)) {\n            cv = d3_collapse(cv + \" \" + name);\n            if (cb) c.baseVal = cv;\n            else node.className = cv;\n          }\n        } else if (cv) {\n          cv = d3_collapse(cv.replace(re, \" \"));\n          if (cb) c.baseVal = cv;\n          else node.className = cv;\n        }\n      };\n    }\n    function d3_selection_style(name, value, priority) {\n      function styleNull() {\n        this.style.removeProperty(name);\n      }\n      function styleConstant() {\n        this.style.setProperty(name, value, priority);\n      }\n      function styleFunction() {\n        var x = value.apply(this, arguments);\n        if (x == null) this.style.removeProperty(name);\n        else this.style.setProperty(name, x, priority);\n      }\n      return value == null\n        ? styleNull\n        : typeof value === \"function\"\n        ? styleFunction\n        : styleConstant;\n    }\n    function d3_selection_property(name, value) {\n      function propertyNull() {\n        delete this[name];\n      }\n      function propertyConstant() {\n        this[name] = value;\n      }\n      function propertyFunction() {\n        var x = value.apply(this, arguments);\n        if (x == null) delete this[name];\n        else this[name] = x;\n      }\n      return value == null\n        ? propertyNull\n        : typeof value === \"function\"\n        ? propertyFunction\n        : propertyConstant;\n    }\n    function d3_selection_dataNode(data) {\n      return {\n        __data__: data,\n      };\n    }\n    function d3_selection_filter(selector) {\n      return function () {\n        return d3_selectMatches(this, selector);\n      };\n    }\n    function d3_selection_sortComparator(comparator) {\n      if (!arguments.length) comparator = d3.ascending;\n      return function (a, b) {\n        return comparator(a && a.__data__, b && b.__data__);\n      };\n    }\n    function d3_selection_on(type, listener, capture) {\n      function onRemove() {\n        var wrapper = this[name];\n        if (wrapper) {\n          this.removeEventListener(type, wrapper, wrapper.$);\n          delete this[name];\n        }\n      }\n      function onAdd() {\n        function wrapper(e) {\n          var o = d3.event;\n          d3.event = e;\n          args[0] = node.__data__;\n          try {\n            listener.apply(node, args);\n          } finally {\n            d3.event = o;\n          }\n        }\n        var node = this,\n          args = arguments;\n        onRemove.call(this);\n        this.addEventListener(\n          type,\n          (this[name] = wrapper),\n          (wrapper.$ = capture)\n        );\n        wrapper._ = listener;\n      }\n      var name = \"__on\" + type,\n        i = type.indexOf(\".\");\n      if (i > 0) type = type.substring(0, i);\n      return listener ? onAdd : onRemove;\n    }\n    function d3_selection_each(groups, callback) {\n      for (var j = 0, m = groups.length; j < m; j++) {\n        for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n          if ((node = group[i])) callback(node, i, j);\n        }\n      }\n      return groups;\n    }\n    function d3_selection_enter(selection) {\n      d3_arraySubclass(selection, d3_selection_enterPrototype);\n      return selection;\n    }\n    function d3_transition(groups, id, time) {\n      d3_arraySubclass(groups, d3_transitionPrototype);\n      var tweens = new d3_Map(),\n        event = d3.dispatch(\"start\", \"end\"),\n        ease = d3_transitionEase;\n      groups.id = id;\n      groups.time = time;\n      groups.tween = function (name, tween) {\n        if (arguments.length < 2) return tweens.get(name);\n        if (tween == null) tweens.remove(name);\n        else tweens.set(name, tween);\n        return groups;\n      };\n      groups.ease = function (value) {\n        if (!arguments.length) return ease;\n        ease =\n          typeof value === \"function\" ? value : d3.ease.apply(d3, arguments);\n        return groups;\n      };\n      groups.each = function (type, listener) {\n        if (arguments.length < 2) return d3_transition_each.call(groups, type);\n        event.on(type, listener);\n        return groups;\n      };\n      d3.timer(\n        function (elapsed) {\n          return d3_selection_each(groups, function (node, i, j) {\n            function start(elapsed) {\n              if (lock.active > id) return stop();\n              lock.active = id;\n              tweens.forEach(function (key, value) {\n                if ((value = value.call(node, d, i))) {\n                  tweened.push(value);\n                }\n              });\n              event.start.call(node, d, i);\n              if (!tick(elapsed)) d3.timer(tick, 0, time);\n              return 1;\n            }\n            function tick(elapsed) {\n              if (lock.active !== id) return stop();\n              var t = (elapsed - delay) / duration,\n                e = ease(t),\n                n = tweened.length;\n              while (n > 0) {\n                tweened[--n].call(node, e);\n              }\n              if (t >= 1) {\n                stop();\n                d3_transitionId = id;\n                event.end.call(node, d, i);\n                d3_transitionId = 0;\n                return 1;\n              }\n            }\n            function stop() {\n              if (!--lock.count) delete node.__transition__;\n              return 1;\n            }\n            var tweened = [],\n              delay = node.delay,\n              duration = node.duration,\n              lock =\n                (node = node.node).__transition__ ||\n                (node.__transition__ = {\n                  active: 0,\n                  count: 0,\n                }),\n              d = node.__data__;\n            ++lock.count;\n            delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);\n          });\n        },\n        0,\n        time\n      );\n      return groups;\n    }\n    function d3_transition_each(callback) {\n      var id = d3_transitionId,\n        ease = d3_transitionEase,\n        delay = d3_transitionDelay,\n        duration = d3_transitionDuration;\n      d3_transitionId = this.id;\n      d3_transitionEase = this.ease();\n      d3_selection_each(this, function (node, i, j) {\n        d3_transitionDelay = node.delay;\n        d3_transitionDuration = node.duration;\n        callback.call((node = node.node), node.__data__, i, j);\n      });\n      d3_transitionId = id;\n      d3_transitionEase = ease;\n      d3_transitionDelay = delay;\n      d3_transitionDuration = duration;\n      return this;\n    }\n    function d3_tweenNull(d, i, a) {\n      return a != \"\" && d3_tweenRemove;\n    }\n    function d3_tweenByName(b, name) {\n      return d3.tween(b, d3_interpolateByName(name));\n    }\n    function d3_timer_step() {\n      var elapsed,\n        now = Date.now(),\n        t1 = d3_timer_queue;\n      while (t1) {\n        elapsed = now - t1.then;\n        if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);\n        t1 = t1.next;\n      }\n      var delay = d3_timer_flush() - now;\n      if (delay > 24) {\n        if (isFinite(delay)) {\n          clearTimeout(d3_timer_timeout);\n          d3_timer_timeout = setTimeout(d3_timer_step, delay);\n        }\n        d3_timer_interval = 0;\n      } else {\n        d3_timer_interval = 1;\n        d3_timer_frame(d3_timer_step);\n      }\n    }\n    function d3_timer_flush() {\n      var t0 = null,\n        t1 = d3_timer_queue,\n        then = Infinity;\n      while (t1) {\n        if (t1.flush) {\n          delete d3_timer_byId[t1.callback.id];\n          t1 = t0 ? (t0.next = t1.next) : (d3_timer_queue = t1.next);\n        } else {\n          then = Math.min(then, t1.then + t1.delay);\n          t1 = (t0 = t1).next;\n        }\n      }\n      return then;\n    }\n    function d3_mousePoint(container, e) {\n      var svg = container.ownerSVGElement || container;\n      if (svg.createSVGPoint) {\n        var point = svg.createSVGPoint();\n        if (d3_mouse_bug44083 < 0 && (window.scrollX || window.scrollY)) {\n          svg = d3\n            .select(document.body)\n            .append(\"svg\")\n            .style(\"position\", \"absolute\")\n            .style(\"top\", 0)\n            .style(\"left\", 0);\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n        if (d3_mouse_bug44083) {\n          point.x = e.pageX;\n          point.y = e.pageY;\n        } else {\n          point.x = e.clientX;\n          point.y = e.clientY;\n        }\n        point = point.matrixTransform(container.getScreenCTM().inverse());\n        return [point.x, point.y];\n      }\n      var rect = container.getBoundingClientRect();\n      return [\n        e.clientX - rect.left - container.clientLeft,\n        e.clientY - rect.top - container.clientTop,\n      ];\n    }\n    function d3_noop() {}\n    function d3_scaleExtent(domain) {\n      var start = domain[0],\n        stop = domain[domain.length - 1];\n      return start < stop ? [start, stop] : [stop, start];\n    }\n    function d3_scaleRange(scale) {\n      return scale.rangeExtent\n        ? scale.rangeExtent()\n        : d3_scaleExtent(scale.range());\n    }\n    function d3_scale_nice(domain, nice) {\n      var i0 = 0,\n        i1 = domain.length - 1,\n        x0 = domain[i0],\n        x1 = domain[i1],\n        dx;\n      if (x1 < x0) {\n        (dx = i0), (i0 = i1), (i1 = dx);\n        (dx = x0), (x0 = x1), (x1 = dx);\n      }\n      if ((nice = nice(x1 - x0))) {\n        domain[i0] = nice.floor(x0);\n        domain[i1] = nice.ceil(x1);\n      }\n      return domain;\n    }\n    function d3_scale_niceDefault() {\n      return Math;\n    }\n    function d3_scale_linear(domain, range, interpolate, clamp) {\n      function rescale() {\n        var linear =\n            Math.min(domain.length, range.length) > 2\n              ? d3_scale_polylinear\n              : d3_scale_bilinear,\n          uninterpolate = clamp\n            ? d3_uninterpolateClamp\n            : d3_uninterpolateNumber;\n        output = linear(domain, range, uninterpolate, interpolate);\n        input = linear(range, domain, uninterpolate, d3.interpolate);\n        return scale;\n      }\n      function scale(x) {\n        return output(x);\n      }\n      var output, input;\n      scale.invert = function (y) {\n        return input(y);\n      };\n      scale.domain = function (x) {\n        if (!arguments.length) return domain;\n        domain = x.map(Number);\n        return rescale();\n      };\n      scale.range = function (x) {\n        if (!arguments.length) return range;\n        range = x;\n        return rescale();\n      };\n      scale.rangeRound = function (x) {\n        return scale.range(x).interpolate(d3.interpolateRound);\n      };\n      scale.clamp = function (x) {\n        if (!arguments.length) return clamp;\n        clamp = x;\n        return rescale();\n      };\n      scale.interpolate = function (x) {\n        if (!arguments.length) return interpolate;\n        interpolate = x;\n        return rescale();\n      };\n      scale.ticks = function (m) {\n        return d3_scale_linearTicks(domain, m);\n      };\n      scale.tickFormat = function (m) {\n        return d3_scale_linearTickFormat(domain, m);\n      };\n      scale.nice = function () {\n        d3_scale_nice(domain, d3_scale_linearNice);\n        return rescale();\n      };\n      scale.copy = function () {\n        return d3_scale_linear(domain, range, interpolate, clamp);\n      };\n      return rescale();\n    }\n    function d3_scale_linearRebind(scale, linear) {\n      return d3.rebind(\n        scale,\n        linear,\n        \"range\",\n        \"rangeRound\",\n        \"interpolate\",\n        \"clamp\"\n      );\n    }\n    function d3_scale_linearNice(dx) {\n      dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\n      return (\n        dx && {\n          floor: function (x) {\n            return Math.floor(x / dx) * dx;\n          },\n          ceil: function (x) {\n            return Math.ceil(x / dx) * dx;\n          },\n        }\n      );\n    }\n    function d3_scale_linearTickRange(domain, m) {\n      var extent = d3_scaleExtent(domain),\n        span = extent[1] - extent[0],\n        step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n        err = (m / span) * step;\n      if (err <= 0.15) step *= 10;\n      else if (err <= 0.35) step *= 5;\n      else if (err <= 0.75) step *= 2;\n      extent[0] = Math.ceil(extent[0] / step) * step;\n      extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;\n      extent[2] = step;\n      return extent;\n    }\n    function d3_scale_linearTicks(domain, m) {\n      return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n    }\n    function d3_scale_linearTickFormat(domain, m) {\n      return d3.format(\n        \",.\" +\n          Math.max(\n            0,\n            -Math.floor(\n              Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 +\n                0.01\n            )\n          ) +\n          \"f\"\n      );\n    }\n    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n      var u = uninterpolate(domain[0], domain[1]),\n        i = interpolate(range[0], range[1]);\n      return function (x) {\n        return i(u(x));\n      };\n    }\n    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n      var u = [],\n        i = [],\n        j = 0,\n        k = Math.min(domain.length, range.length) - 1;\n      if (domain[k] < domain[0]) {\n        domain = domain.slice().reverse();\n        range = range.slice().reverse();\n      }\n      while (++j <= k) {\n        u.push(uninterpolate(domain[j - 1], domain[j]));\n        i.push(interpolate(range[j - 1], range[j]));\n      }\n      return function (x) {\n        var j = d3.bisect(domain, x, 1, k) - 1;\n        return i[j](u[j](x));\n      };\n    }\n    function d3_scale_log(linear, log) {\n      function scale(x) {\n        return linear(log(x));\n      }\n      var pow = log.pow;\n      scale.invert = function (x) {\n        return pow(linear.invert(x));\n      };\n      scale.domain = function (x) {\n        if (!arguments.length) return linear.domain().map(pow);\n        log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;\n        pow = log.pow;\n        linear.domain(x.map(log));\n        return scale;\n      };\n      scale.nice = function () {\n        linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\n        return scale;\n      };\n      scale.ticks = function () {\n        var extent = d3_scaleExtent(linear.domain()),\n          ticks = [];\n        if (extent.every(isFinite)) {\n          var i = Math.floor(extent[0]),\n            j = Math.ceil(extent[1]),\n            u = pow(extent[0]),\n            v = pow(extent[1]);\n          if (log === d3_scale_logn) {\n            ticks.push(pow(i));\n            for (; i++ < j; )\n              for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\n          } else {\n            for (; i < j; i++)\n              for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\n            ticks.push(pow(i));\n          }\n          for (i = 0; ticks[i] < u; i++) {}\n          for (j = ticks.length; ticks[j - 1] > v; j--) {}\n          ticks = ticks.slice(i, j);\n        }\n        return ticks;\n      };\n      scale.tickFormat = function (n, format) {\n        if (arguments.length < 2) format = d3_scale_logFormat;\n        if (arguments.length < 1) return format;\n        var k = Math.max(0.1, n / scale.ticks().length),\n          f =\n            log === d3_scale_logn\n              ? ((e = -1e-12), Math.floor)\n              : ((e = 1e-12), Math.ceil),\n          e;\n        return function (d) {\n          return d / pow(f(log(d) + e)) <= k ? format(d) : \"\";\n        };\n      };\n      scale.copy = function () {\n        return d3_scale_log(linear.copy(), log);\n      };\n      return d3_scale_linearRebind(scale, linear);\n    }\n    function d3_scale_logp(x) {\n      return Math.log(x < 0 ? 0 : x) / Math.LN10;\n    }\n    function d3_scale_logn(x) {\n      return -Math.log(x > 0 ? 0 : -x) / Math.LN10;\n    }\n    function d3_scale_pow(linear, exponent) {\n      function scale(x) {\n        return linear(powp(x));\n      }\n      var powp = d3_scale_powPow(exponent),\n        powb = d3_scale_powPow(1 / exponent);\n      scale.invert = function (x) {\n        return powb(linear.invert(x));\n      };\n      scale.domain = function (x) {\n        if (!arguments.length) return linear.domain().map(powb);\n        linear.domain(x.map(powp));\n        return scale;\n      };\n      scale.ticks = function (m) {\n        return d3_scale_linearTicks(scale.domain(), m);\n      };\n      scale.tickFormat = function (m) {\n        return d3_scale_linearTickFormat(scale.domain(), m);\n      };\n      scale.nice = function () {\n        return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\n      };\n      scale.exponent = function (x) {\n        if (!arguments.length) return exponent;\n        var domain = scale.domain();\n        powp = d3_scale_powPow((exponent = x));\n        powb = d3_scale_powPow(1 / exponent);\n        return scale.domain(domain);\n      };\n      scale.copy = function () {\n        return d3_scale_pow(linear.copy(), exponent);\n      };\n      return d3_scale_linearRebind(scale, linear);\n    }\n    function d3_scale_powPow(e) {\n      return function (x) {\n        return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n      };\n    }\n    function d3_scale_ordinal(domain, ranger) {\n      function scale(x) {\n        return range[\n          ((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length\n        ];\n      }\n      function steps(start, step) {\n        return d3.range(domain.length).map(function (i) {\n          return start + step * i;\n        });\n      }\n      var index, range, rangeBand;\n      scale.domain = function (x) {\n        if (!arguments.length) return domain;\n        domain = [];\n        index = new d3_Map();\n        var i = -1,\n          n = x.length,\n          xi;\n        while (++i < n)\n          if (!index.has((xi = x[i]))) index.set(xi, domain.push(xi));\n        return scale[ranger.t].apply(scale, ranger.a);\n      };\n      scale.range = function (x) {\n        if (!arguments.length) return range;\n        range = x;\n        rangeBand = 0;\n        ranger = {\n          t: \"range\",\n          a: arguments,\n        };\n        return scale;\n      };\n      scale.rangePoints = function (x, padding) {\n        if (arguments.length < 2) padding = 0;\n        var start = x[0],\n          stop = x[1],\n          step = (stop - start) / (Math.max(1, domain.length - 1) + padding);\n        range = steps(\n          domain.length < 2 ? (start + stop) / 2 : start + (step * padding) / 2,\n          step\n        );\n        rangeBand = 0;\n        ranger = {\n          t: \"rangePoints\",\n          a: arguments,\n        };\n        return scale;\n      };\n      scale.rangeBands = function (x, padding, outerPadding) {\n        if (arguments.length < 2) padding = 0;\n        if (arguments.length < 3) outerPadding = padding;\n        var reverse = x[1] < x[0],\n          start = x[reverse - 0],\n          stop = x[1 - reverse],\n          step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n        range = steps(start + step * outerPadding, step);\n        if (reverse) range.reverse();\n        rangeBand = step * (1 - padding);\n        ranger = {\n          t: \"rangeBands\",\n          a: arguments,\n        };\n        return scale;\n      };\n      scale.rangeRoundBands = function (x, padding, outerPadding) {\n        if (arguments.length < 2) padding = 0;\n        if (arguments.length < 3) outerPadding = padding;\n        var reverse = x[1] < x[0],\n          start = x[reverse - 0],\n          stop = x[1 - reverse],\n          step = Math.floor(\n            (stop - start) / (domain.length - padding + 2 * outerPadding)\n          ),\n          error = stop - start - (domain.length - padding) * step;\n        range = steps(start + Math.round(error / 2), step);\n        if (reverse) range.reverse();\n        rangeBand = Math.round(step * (1 - padding));\n        ranger = {\n          t: \"rangeRoundBands\",\n          a: arguments,\n        };\n        return scale;\n      };\n      scale.rangeBand = function () {\n        return rangeBand;\n      };\n      scale.rangeExtent = function () {\n        return d3_scaleExtent(ranger.a[0]);\n      };\n      scale.copy = function () {\n        return d3_scale_ordinal(domain, ranger);\n      };\n      return scale.domain(domain);\n    }\n    function d3_scale_quantile(domain, range) {\n      function rescale() {\n        var k = 0,\n          n = domain.length,\n          q = range.length;\n        thresholds = [];\n        while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n        return scale;\n      }\n      function scale(x) {\n        if (isNaN((x = +x))) return NaN;\n        return range[d3.bisect(thresholds, x)];\n      }\n      var thresholds;\n      scale.domain = function (x) {\n        if (!arguments.length) return domain;\n        domain = x\n          .filter(function (d) {\n            return !isNaN(d);\n          })\n          .sort(d3.ascending);\n        return rescale();\n      };\n      scale.range = function (x) {\n        if (!arguments.length) return range;\n        range = x;\n        return rescale();\n      };\n      scale.quantiles = function () {\n        return thresholds;\n      };\n      scale.copy = function () {\n        return d3_scale_quantile(domain, range);\n      };\n      return rescale();\n    }\n    function d3_scale_quantize(x0, x1, range) {\n      function scale(x) {\n        return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n      }\n      function rescale() {\n        kx = range.length / (x1 - x0);\n        i = range.length - 1;\n        return scale;\n      }\n      var kx, i;\n      scale.domain = function (x) {\n        if (!arguments.length) return [x0, x1];\n        x0 = +x[0];\n        x1 = +x[x.length - 1];\n        return rescale();\n      };\n      scale.range = function (x) {\n        if (!arguments.length) return range;\n        range = x;\n        return rescale();\n      };\n      scale.copy = function () {\n        return d3_scale_quantize(x0, x1, range);\n      };\n      return rescale();\n    }\n    function d3_scale_threshold(domain, range) {\n      function scale(x) {\n        return range[d3.bisect(domain, x)];\n      }\n      scale.domain = function (_) {\n        if (!arguments.length) return domain;\n        domain = _;\n        return scale;\n      };\n      scale.range = function (_) {\n        if (!arguments.length) return range;\n        range = _;\n        return scale;\n      };\n      scale.copy = function () {\n        return d3_scale_threshold(domain, range);\n      };\n      return scale;\n    }\n    function d3_scale_identity(domain) {\n      function identity(x) {\n        return +x;\n      }\n      identity.invert = identity;\n      identity.domain = identity.range = function (x) {\n        if (!arguments.length) return domain;\n        domain = x.map(identity);\n        return identity;\n      };\n      identity.ticks = function (m) {\n        return d3_scale_linearTicks(domain, m);\n      };\n      identity.tickFormat = function (m) {\n        return d3_scale_linearTickFormat(domain, m);\n      };\n      identity.copy = function () {\n        return d3_scale_identity(domain);\n      };\n      return identity;\n    }\n    function d3_svg_arcInnerRadius(d) {\n      return d.innerRadius;\n    }\n    function d3_svg_arcOuterRadius(d) {\n      return d.outerRadius;\n    }\n    function d3_svg_arcStartAngle(d) {\n      return d.startAngle;\n    }\n    function d3_svg_arcEndAngle(d) {\n      return d.endAngle;\n    }\n    function d3_svg_line(projection) {\n      function line(data) {\n        function segment() {\n          segments.push(\"M\", interpolate(projection(points), tension));\n        }\n        var segments = [],\n          points = [],\n          i = -1,\n          n = data.length,\n          d,\n          fx = d3_functor(x),\n          fy = d3_functor(y);\n        while (++i < n) {\n          if (defined.call(this, (d = data[i]), i)) {\n            points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);\n          } else if (points.length) {\n            segment();\n            points = [];\n          }\n        }\n        if (points.length) segment();\n        return segments.length ? segments.join(\"\") : null;\n      }\n      var x = d3_svg_lineX,\n        y = d3_svg_lineY,\n        defined = d3_true,\n        interpolate = d3_svg_lineLinear,\n        interpolateKey = interpolate.key,\n        tension = 0.7;\n      line.x = function (_) {\n        if (!arguments.length) return x;\n        x = _;\n        return line;\n      };\n      line.y = function (_) {\n        if (!arguments.length) return y;\n        y = _;\n        return line;\n      };\n      line.defined = function (_) {\n        if (!arguments.length) return defined;\n        defined = _;\n        return line;\n      };\n      line.interpolate = function (_) {\n        if (!arguments.length) return interpolateKey;\n        if (typeof _ === \"function\") interpolateKey = interpolate = _;\n        else\n          interpolateKey = (interpolate =\n            d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n        return line;\n      };\n      line.tension = function (_) {\n        if (!arguments.length) return tension;\n        tension = _;\n        return line;\n      };\n      return line;\n    }\n    function d3_svg_lineX(d) {\n      return d[0];\n    }\n    function d3_svg_lineY(d) {\n      return d[1];\n    }\n    function d3_svg_lineLinear(points) {\n      return points.join(\"L\");\n    }\n    function d3_svg_lineLinearClosed(points) {\n      return d3_svg_lineLinear(points) + \"Z\";\n    }\n    function d3_svg_lineStepBefore(points) {\n      var i = 0,\n        n = points.length,\n        p = points[0],\n        path = [p[0], \",\", p[1]];\n      while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n      return path.join(\"\");\n    }\n    function d3_svg_lineStepAfter(points) {\n      var i = 0,\n        n = points.length,\n        p = points[0],\n        path = [p[0], \",\", p[1]];\n      while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n      return path.join(\"\");\n    }\n    function d3_svg_lineCardinalOpen(points, tension) {\n      return points.length < 4\n        ? d3_svg_lineLinear(points)\n        : points[1] +\n            d3_svg_lineHermite(\n              points.slice(1, points.length - 1),\n              d3_svg_lineCardinalTangents(points, tension)\n            );\n    }\n    function d3_svg_lineCardinalClosed(points, tension) {\n      return points.length < 3\n        ? d3_svg_lineLinear(points)\n        : points[0] +\n            d3_svg_lineHermite(\n              (points.push(points[0]), points),\n              d3_svg_lineCardinalTangents(\n                [points[points.length - 2]].concat(points, [points[1]]),\n                tension\n              )\n            );\n    }\n    function d3_svg_lineCardinal(points, tension, closed) {\n      return points.length < 3\n        ? d3_svg_lineLinear(points)\n        : points[0] +\n            d3_svg_lineHermite(\n              points,\n              d3_svg_lineCardinalTangents(points, tension)\n            );\n    }\n    function d3_svg_lineHermite(points, tangents) {\n      if (\n        tangents.length < 1 ||\n        (points.length != tangents.length &&\n          points.length != tangents.length + 2)\n      ) {\n        return d3_svg_lineLinear(points);\n      }\n      var quad = points.length != tangents.length,\n        path = \"\",\n        p0 = points[0],\n        p = points[1],\n        t0 = tangents[0],\n        t = t0,\n        pi = 1;\n      if (quad) {\n        path +=\n          \"Q\" +\n          (p[0] - (t0[0] * 2) / 3) +\n          \",\" +\n          (p[1] - (t0[1] * 2) / 3) +\n          \",\" +\n          p[0] +\n          \",\" +\n          p[1];\n        p0 = points[1];\n        pi = 2;\n      }\n      if (tangents.length > 1) {\n        t = tangents[1];\n        p = points[pi];\n        pi++;\n        path +=\n          \"C\" +\n          (p0[0] + t0[0]) +\n          \",\" +\n          (p0[1] + t0[1]) +\n          \",\" +\n          (p[0] - t[0]) +\n          \",\" +\n          (p[1] - t[1]) +\n          \",\" +\n          p[0] +\n          \",\" +\n          p[1];\n        for (var i = 2; i < tangents.length; i++, pi++) {\n          p = points[pi];\n          t = tangents[i];\n          path +=\n            \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n        }\n      }\n      if (quad) {\n        var lp = points[pi];\n        path +=\n          \"Q\" +\n          (p[0] + (t[0] * 2) / 3) +\n          \",\" +\n          (p[1] + (t[1] * 2) / 3) +\n          \",\" +\n          lp[0] +\n          \",\" +\n          lp[1];\n      }\n      return path;\n    }\n    function d3_svg_lineCardinalTangents(points, tension) {\n      var tangents = [],\n        a = (1 - tension) / 2,\n        p0,\n        p1 = points[0],\n        p2 = points[1],\n        i = 1,\n        n = points.length;\n      while (++i < n) {\n        p0 = p1;\n        p1 = p2;\n        p2 = points[i];\n        tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n      }\n      return tangents;\n    }\n    function d3_svg_lineBasis(points) {\n      if (points.length < 3) return d3_svg_lineLinear(points);\n      var i = 1,\n        n = points.length,\n        pi = points[0],\n        x0 = pi[0],\n        y0 = pi[1],\n        px = [x0, x0, x0, (pi = points[1])[0]],\n        py = [y0, y0, y0, pi[1]],\n        path = [x0, \",\", y0];\n      d3_svg_lineBasisBezier(path, px, py);\n      while (++i < n) {\n        pi = points[i];\n        px.shift();\n        px.push(pi[0]);\n        py.shift();\n        py.push(pi[1]);\n        d3_svg_lineBasisBezier(path, px, py);\n      }\n      i = -1;\n      while (++i < 2) {\n        px.shift();\n        px.push(pi[0]);\n        py.shift();\n        py.push(pi[1]);\n        d3_svg_lineBasisBezier(path, px, py);\n      }\n      return path.join(\"\");\n    }\n    function d3_svg_lineBasisOpen(points) {\n      if (points.length < 4) return d3_svg_lineLinear(points);\n      var path = [],\n        i = -1,\n        n = points.length,\n        pi,\n        px = [0],\n        py = [0];\n      while (++i < 3) {\n        pi = points[i];\n        px.push(pi[0]);\n        py.push(pi[1]);\n      }\n      path.push(\n        d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) +\n          \",\" +\n          d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)\n      );\n      --i;\n      while (++i < n) {\n        pi = points[i];\n        px.shift();\n        px.push(pi[0]);\n        py.shift();\n        py.push(pi[1]);\n        d3_svg_lineBasisBezier(path, px, py);\n      }\n      return path.join(\"\");\n    }\n    function d3_svg_lineBasisClosed(points) {\n      var path,\n        i = -1,\n        n = points.length,\n        m = n + 4,\n        pi,\n        px = [],\n        py = [];\n      while (++i < 4) {\n        pi = points[i % n];\n        px.push(pi[0]);\n        py.push(pi[1]);\n      }\n      path = [\n        d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),\n        \",\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier3, py),\n      ];\n      --i;\n      while (++i < m) {\n        pi = points[i % n];\n        px.shift();\n        px.push(pi[0]);\n        py.shift();\n        py.push(pi[1]);\n        d3_svg_lineBasisBezier(path, px, py);\n      }\n      return path.join(\"\");\n    }\n    function d3_svg_lineBundle(points, tension) {\n      var n = points.length - 1;\n      if (n) {\n        var x0 = points[0][0],\n          y0 = points[0][1],\n          dx = points[n][0] - x0,\n          dy = points[n][1] - y0,\n          i = -1,\n          p,\n          t;\n        while (++i <= n) {\n          p = points[i];\n          t = i / n;\n          p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n          p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n        }\n      }\n      return d3_svg_lineBasis(points);\n    }\n    function d3_svg_lineDot4(a, b) {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n    }\n    function d3_svg_lineBasisBezier(path, x, y) {\n      path.push(\n        \"C\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),\n        \",\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),\n        \",\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),\n        \",\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),\n        \",\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),\n        \",\",\n        d3_svg_lineDot4(d3_svg_lineBasisBezier3, y)\n      );\n    }\n    function d3_svg_lineSlope(p0, p1) {\n      return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n    }\n    function d3_svg_lineFiniteDifferences(points) {\n      var i = 0,\n        j = points.length - 1,\n        m = [],\n        p0 = points[0],\n        p1 = points[1],\n        d = (m[0] = d3_svg_lineSlope(p0, p1));\n      while (++i < j) {\n        m[i] =\n          (d + (d = d3_svg_lineSlope((p0 = p1), (p1 = points[i + 1])))) / 2;\n      }\n      m[i] = d;\n      return m;\n    }\n    function d3_svg_lineMonotoneTangents(points) {\n      var tangents = [],\n        d,\n        a,\n        b,\n        s,\n        m = d3_svg_lineFiniteDifferences(points),\n        i = -1,\n        j = points.length - 1;\n      while (++i < j) {\n        d = d3_svg_lineSlope(points[i], points[i + 1]);\n        if (Math.abs(d) < 1e-6) {\n          m[i] = m[i + 1] = 0;\n        } else {\n          a = m[i] / d;\n          b = m[i + 1] / d;\n          s = a * a + b * b;\n          if (s > 9) {\n            s = (d * 3) / Math.sqrt(s);\n            m[i] = s * a;\n            m[i + 1] = s * b;\n          }\n        }\n      }\n      i = -1;\n      while (++i <= j) {\n        s =\n          (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) /\n          (6 * (1 + m[i] * m[i]));\n        tangents.push([s || 0, m[i] * s || 0]);\n      }\n      return tangents;\n    }\n    function d3_svg_lineMonotone(points) {\n      return points.length < 3\n        ? d3_svg_lineLinear(points)\n        : points[0] +\n            d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n    }\n    function d3_svg_lineRadial(points) {\n      var point,\n        i = -1,\n        n = points.length,\n        r,\n        a;\n      while (++i < n) {\n        point = points[i];\n        r = point[0];\n        a = point[1] + d3_svg_arcOffset;\n        point[0] = r * Math.cos(a);\n        point[1] = r * Math.sin(a);\n      }\n      return points;\n    }\n    function d3_svg_area(projection) {\n      function area(data) {\n        function segment() {\n          segments.push(\n            \"M\",\n            interpolate(projection(points1), tension),\n            L,\n            interpolateReverse(projection(points0.reverse()), tension),\n            \"Z\"\n          );\n        }\n        var segments = [],\n          points0 = [],\n          points1 = [],\n          i = -1,\n          n = data.length,\n          d,\n          fx0 = d3_functor(x0),\n          fy0 = d3_functor(y0),\n          fx1 =\n            x0 === x1\n              ? function () {\n                  return x;\n                }\n              : d3_functor(x1),\n          fy1 =\n            y0 === y1\n              ? function () {\n                  return y;\n                }\n              : d3_functor(y1),\n          x,\n          y;\n        while (++i < n) {\n          if (defined.call(this, (d = data[i]), i)) {\n            points0.push([\n              (x = +fx0.call(this, d, i)),\n              (y = +fy0.call(this, d, i)),\n            ]);\n            points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);\n          } else if (points0.length) {\n            segment();\n            points0 = [];\n            points1 = [];\n          }\n        }\n        if (points0.length) segment();\n        return segments.length ? segments.join(\"\") : null;\n      }\n      var x0 = d3_svg_lineX,\n        x1 = d3_svg_lineX,\n        y0 = 0,\n        y1 = d3_svg_lineY,\n        defined = d3_true,\n        interpolate = d3_svg_lineLinear,\n        interpolateKey = interpolate.key,\n        interpolateReverse = interpolate,\n        L = \"L\",\n        tension = 0.7;\n      area.x = function (_) {\n        if (!arguments.length) return x1;\n        x0 = x1 = _;\n        return area;\n      };\n      area.x0 = function (_) {\n        if (!arguments.length) return x0;\n        x0 = _;\n        return area;\n      };\n      area.x1 = function (_) {\n        if (!arguments.length) return x1;\n        x1 = _;\n        return area;\n      };\n      area.y = function (_) {\n        if (!arguments.length) return y1;\n        y0 = y1 = _;\n        return area;\n      };\n      area.y0 = function (_) {\n        if (!arguments.length) return y0;\n        y0 = _;\n        return area;\n      };\n      area.y1 = function (_) {\n        if (!arguments.length) return y1;\n        y1 = _;\n        return area;\n      };\n      area.defined = function (_) {\n        if (!arguments.length) return defined;\n        defined = _;\n        return area;\n      };\n      area.interpolate = function (_) {\n        if (!arguments.length) return interpolateKey;\n        if (typeof _ === \"function\") interpolateKey = interpolate = _;\n        else\n          interpolateKey = (interpolate =\n            d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n        interpolateReverse = interpolate.reverse || interpolate;\n        L = interpolate.closed ? \"M\" : \"L\";\n        return area;\n      };\n      area.tension = function (_) {\n        if (!arguments.length) return tension;\n        tension = _;\n        return area;\n      };\n      return area;\n    }\n    function d3_svg_chordSource(d) {\n      return d.source;\n    }\n    function d3_svg_chordTarget(d) {\n      return d.target;\n    }\n    function d3_svg_chordRadius(d) {\n      return d.radius;\n    }\n    function d3_svg_chordStartAngle(d) {\n      return d.startAngle;\n    }\n    function d3_svg_chordEndAngle(d) {\n      return d.endAngle;\n    }\n    function d3_svg_diagonalProjection(d) {\n      return [d.x, d.y];\n    }\n    function d3_svg_diagonalRadialProjection(projection) {\n      return function () {\n        var d = projection.apply(this, arguments),\n          r = d[0],\n          a = d[1] + d3_svg_arcOffset;\n        return [r * Math.cos(a), r * Math.sin(a)];\n      };\n    }\n    function d3_svg_symbolSize() {\n      return 64;\n    }\n    function d3_svg_symbolType() {\n      return \"circle\";\n    }\n    function d3_svg_symbolCircle(size) {\n      var r = Math.sqrt(size / Math.PI);\n      return (\n        \"M0,\" +\n        r +\n        \"A\" +\n        r +\n        \",\" +\n        r +\n        \" 0 1,1 0,\" +\n        -r +\n        \"A\" +\n        r +\n        \",\" +\n        r +\n        \" 0 1,1 0,\" +\n        r +\n        \"Z\"\n      );\n    }\n    function d3_svg_axisX(selection, x) {\n      selection.attr(\"transform\", function (d) {\n        return \"translate(\" + x(d) + \",0)\";\n      });\n    }\n    function d3_svg_axisY(selection, y) {\n      selection.attr(\"transform\", function (d) {\n        return \"translate(0,\" + y(d) + \")\";\n      });\n    }\n    function d3_svg_axisSubdivide(scale, ticks, m) {\n      subticks = [];\n      if (m && ticks.length > 1) {\n        var extent = d3_scaleExtent(scale.domain()),\n          subticks,\n          i = -1,\n          n = ticks.length,\n          d = (ticks[1] - ticks[0]) / ++m,\n          j,\n          v;\n        while (++i < n) {\n          for (j = m; --j > 0; ) {\n            if ((v = +ticks[i] - j * d) >= extent[0]) {\n              subticks.push(v);\n            }\n          }\n        }\n        for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {\n          subticks.push(v);\n        }\n      }\n      return subticks;\n    }\n    function d3_behavior_zoomDelta() {\n      if (!d3_behavior_zoomDiv) {\n        d3_behavior_zoomDiv = d3\n          .select(\"body\")\n          .append(\"div\")\n          .style(\"visibility\", \"hidden\")\n          .style(\"top\", 0)\n          .style(\"height\", 0)\n          .style(\"width\", 0)\n          .style(\"overflow-y\", \"scroll\")\n          .append(\"div\")\n          .style(\"height\", \"2000px\")\n          .node().parentNode;\n      }\n      var e = d3.event,\n        delta;\n      try {\n        d3_behavior_zoomDiv.scrollTop = 1e3;\n        d3_behavior_zoomDiv.dispatchEvent(e);\n        delta = 1e3 - d3_behavior_zoomDiv.scrollTop;\n      } catch (error) {\n        delta = e.wheelDelta || -e.detail * 5;\n      }\n      return delta;\n    }\n    function d3_layout_bundlePath(link) {\n      var start = link.source,\n        end = link.target,\n        lca = d3_layout_bundleLeastCommonAncestor(start, end),\n        points = [start];\n      while (start !== lca) {\n        start = start.parent;\n        points.push(start);\n      }\n      var k = points.length;\n      while (end !== lca) {\n        points.splice(k, 0, end);\n        end = end.parent;\n      }\n      return points;\n    }\n    function d3_layout_bundleAncestors(node) {\n      var ancestors = [],\n        parent = node.parent;\n      while (parent != null) {\n        ancestors.push(node);\n        node = parent;\n        parent = parent.parent;\n      }\n      ancestors.push(node);\n      return ancestors;\n    }\n    function d3_layout_bundleLeastCommonAncestor(a, b) {\n      if (a === b) return a;\n      var aNodes = d3_layout_bundleAncestors(a),\n        bNodes = d3_layout_bundleAncestors(b),\n        aNode = aNodes.pop(),\n        bNode = bNodes.pop(),\n        sharedNode = null;\n      while (aNode === bNode) {\n        sharedNode = aNode;\n        aNode = aNodes.pop();\n        bNode = bNodes.pop();\n      }\n      return sharedNode;\n    }\n    function d3_layout_forceDragstart(d) {\n      d.fixed |= 2;\n    }\n    function d3_layout_forceDragend(d) {\n      d.fixed &= 1;\n    }\n    function d3_layout_forceMouseover(d) {\n      d.fixed |= 4;\n    }\n    function d3_layout_forceMouseout(d) {\n      d.fixed &= 3;\n    }\n    function d3_layout_forceAccumulate(quad, alpha, charges) {\n      var cx = 0,\n        cy = 0;\n      quad.charge = 0;\n      if (!quad.leaf) {\n        var nodes = quad.nodes,\n          n = nodes.length,\n          i = -1,\n          c;\n        while (++i < n) {\n          c = nodes[i];\n          if (c == null) continue;\n          d3_layout_forceAccumulate(c, alpha, charges);\n          quad.charge += c.charge;\n          cx += c.charge * c.cx;\n          cy += c.charge * c.cy;\n        }\n      }\n      if (quad.point) {\n        if (!quad.leaf) {\n          quad.point.x += Math.random() - 0.5;\n          quad.point.y += Math.random() - 0.5;\n        }\n        var k = alpha * charges[quad.point.index];\n        quad.charge += quad.pointCharge = k;\n        cx += k * quad.point.x;\n        cy += k * quad.point.y;\n      }\n      quad.cx = cx / quad.charge;\n      quad.cy = cy / quad.charge;\n    }\n    function d3_layout_forceLinkDistance(link) {\n      return 20;\n    }\n    function d3_layout_forceLinkStrength(link) {\n      return 1;\n    }\n    function d3_layout_stackX(d) {\n      return d.x;\n    }\n    function d3_layout_stackY(d) {\n      return d.y;\n    }\n    function d3_layout_stackOut(d, y0, y) {\n      d.y0 = y0;\n      d.y = y;\n    }\n    function d3_layout_stackOrderDefault(data) {\n      return d3.range(data.length);\n    }\n    function d3_layout_stackOffsetZero(data) {\n      var j = -1,\n        m = data[0].length,\n        y0 = [];\n      while (++j < m) y0[j] = 0;\n      return y0;\n    }\n    function d3_layout_stackMaxIndex(array) {\n      var i = 1,\n        j = 0,\n        v = array[0][1],\n        k,\n        n = array.length;\n      for (; i < n; ++i) {\n        if ((k = array[i][1]) > v) {\n          j = i;\n          v = k;\n        }\n      }\n      return j;\n    }\n    function d3_layout_stackReduceSum(d) {\n      return d.reduce(d3_layout_stackSum, 0);\n    }\n    function d3_layout_stackSum(p, d) {\n      return p + d[1];\n    }\n    function d3_layout_histogramBinSturges(range, values) {\n      return d3_layout_histogramBinFixed(\n        range,\n        Math.ceil(Math.log(values.length) / Math.LN2 + 1)\n      );\n    }\n    function d3_layout_histogramBinFixed(range, n) {\n      var x = -1,\n        b = +range[0],\n        m = (range[1] - b) / n,\n        f = [];\n      while (++x <= n) f[x] = m * x + b;\n      return f;\n    }\n    function d3_layout_histogramRange(values) {\n      return [d3.min(values), d3.max(values)];\n    }\n    function d3_layout_hierarchyRebind(object, hierarchy) {\n      d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n      object.links = d3_layout_hierarchyLinks;\n      object.nodes = function (d) {\n        d3_layout_hierarchyInline = true;\n        return (object.nodes = object)(d);\n      };\n      return object;\n    }\n    function d3_layout_hierarchyChildren(d) {\n      return d.children;\n    }\n    function d3_layout_hierarchyValue(d) {\n      return d.value;\n    }\n    function d3_layout_hierarchySort(a, b) {\n      return b.value - a.value;\n    }\n    function d3_layout_hierarchyLinks(nodes) {\n      return d3.merge(\n        nodes.map(function (parent) {\n          return (parent.children || []).map(function (child) {\n            return {\n              source: parent,\n              target: child,\n            };\n          });\n        })\n      );\n    }\n    function d3_layout_packSort(a, b) {\n      return a.value - b.value;\n    }\n    function d3_layout_packInsert(a, b) {\n      var c = a._pack_next;\n      a._pack_next = b;\n      b._pack_prev = a;\n      b._pack_next = c;\n      c._pack_prev = b;\n    }\n    function d3_layout_packSplice(a, b) {\n      a._pack_next = b;\n      b._pack_prev = a;\n    }\n    function d3_layout_packIntersects(a, b) {\n      var dx = b.x - a.x,\n        dy = b.y - a.y,\n        dr = a.r + b.r;\n      return dr * dr - dx * dx - dy * dy > 0.001;\n    }\n    function d3_layout_packSiblings(node) {\n      function bound(node) {\n        xMin = Math.min(node.x - node.r, xMin);\n        xMax = Math.max(node.x + node.r, xMax);\n        yMin = Math.min(node.y - node.r, yMin);\n        yMax = Math.max(node.y + node.r, yMax);\n      }\n      if (!(nodes = node.children) || !(n = nodes.length)) return;\n      var nodes,\n        xMin = Infinity,\n        xMax = -Infinity,\n        yMin = Infinity,\n        yMax = -Infinity,\n        a,\n        b,\n        c,\n        i,\n        j,\n        k,\n        n;\n      nodes.forEach(d3_layout_packLink);\n      a = nodes[0];\n      a.x = -a.r;\n      a.y = 0;\n      bound(a);\n      if (n > 1) {\n        b = nodes[1];\n        b.x = b.r;\n        b.y = 0;\n        bound(b);\n        if (n > 2) {\n          c = nodes[2];\n          d3_layout_packPlace(a, b, c);\n          bound(c);\n          d3_layout_packInsert(a, c);\n          a._pack_prev = c;\n          d3_layout_packInsert(c, b);\n          b = a._pack_next;\n          for (i = 3; i < n; i++) {\n            d3_layout_packPlace(a, b, (c = nodes[i]));\n            var isect = 0,\n              s1 = 1,\n              s2 = 1;\n            for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n              if (d3_layout_packIntersects(j, c)) {\n                isect = 1;\n                break;\n              }\n            }\n            if (isect == 1) {\n              for (\n                k = a._pack_prev;\n                k !== j._pack_prev;\n                k = k._pack_prev, s2++\n              ) {\n                if (d3_layout_packIntersects(k, c)) {\n                  break;\n                }\n              }\n            }\n            if (isect) {\n              if (s1 < s2 || (s1 == s2 && b.r < a.r))\n                d3_layout_packSplice(a, (b = j));\n              else d3_layout_packSplice((a = k), b);\n              i--;\n            } else {\n              d3_layout_packInsert(a, c);\n              b = c;\n              bound(c);\n            }\n          }\n        }\n      }\n      var cx = (xMin + xMax) / 2,\n        cy = (yMin + yMax) / 2,\n        cr = 0;\n      for (i = 0; i < n; i++) {\n        c = nodes[i];\n        c.x -= cx;\n        c.y -= cy;\n        cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n      }\n      node.r = cr;\n      nodes.forEach(d3_layout_packUnlink);\n    }\n    function d3_layout_packLink(node) {\n      node._pack_next = node._pack_prev = node;\n    }\n    function d3_layout_packUnlink(node) {\n      delete node._pack_next;\n      delete node._pack_prev;\n    }\n    function d3_layout_packTransform(node, x, y, k) {\n      var children = node.children;\n      node.x = x += k * node.x;\n      node.y = y += k * node.y;\n      node.r *= k;\n      if (children) {\n        var i = -1,\n          n = children.length;\n        while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n      }\n    }\n    function d3_layout_packPlace(a, b, c) {\n      var db = a.r + c.r,\n        dx = b.x - a.x,\n        dy = b.y - a.y;\n      if (db && (dx || dy)) {\n        var da = b.r + c.r,\n          dc = dx * dx + dy * dy;\n        da *= da;\n        db *= db;\n        var x = 0.5 + (db - da) / (2 * dc),\n          y =\n            Math.sqrt(\n              Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)\n            ) /\n            (2 * dc);\n        c.x = a.x + x * dx + y * dy;\n        c.y = a.y + x * dy - y * dx;\n      } else {\n        c.x = a.x + db;\n        c.y = a.y;\n      }\n    }\n    function d3_layout_clusterY(children) {\n      return (\n        1 +\n        d3.max(children, function (child) {\n          return child.y;\n        })\n      );\n    }\n    function d3_layout_clusterX(children) {\n      return (\n        children.reduce(function (x, child) {\n          return x + child.x;\n        }, 0) / children.length\n      );\n    }\n    function d3_layout_clusterLeft(node) {\n      var children = node.children;\n      return children && children.length\n        ? d3_layout_clusterLeft(children[0])\n        : node;\n    }\n    function d3_layout_clusterRight(node) {\n      var children = node.children,\n        n;\n      return children && (n = children.length)\n        ? d3_layout_clusterRight(children[n - 1])\n        : node;\n    }\n    function d3_layout_treeSeparation(a, b) {\n      return a.parent == b.parent ? 1 : 2;\n    }\n    function d3_layout_treeLeft(node) {\n      var children = node.children;\n      return children && children.length ? children[0] : node._tree.thread;\n    }\n    function d3_layout_treeRight(node) {\n      var children = node.children,\n        n;\n      return children && (n = children.length)\n        ? children[n - 1]\n        : node._tree.thread;\n    }\n    function d3_layout_treeSearch(node, compare) {\n      var children = node.children;\n      if (children && (n = children.length)) {\n        var child,\n          n,\n          i = -1;\n        while (++i < n) {\n          if (\n            compare(\n              (child = d3_layout_treeSearch(children[i], compare)),\n              node\n            ) > 0\n          ) {\n            node = child;\n          }\n        }\n      }\n      return node;\n    }\n    function d3_layout_treeRightmost(a, b) {\n      return a.x - b.x;\n    }\n    function d3_layout_treeLeftmost(a, b) {\n      return b.x - a.x;\n    }\n    function d3_layout_treeDeepest(a, b) {\n      return a.depth - b.depth;\n    }\n    function d3_layout_treeVisitAfter(node, callback) {\n      function visit(node, previousSibling) {\n        var children = node.children;\n        if (children && (n = children.length)) {\n          var child,\n            previousChild = null,\n            i = -1,\n            n;\n          while (++i < n) {\n            child = children[i];\n            visit(child, previousChild);\n            previousChild = child;\n          }\n        }\n        callback(node, previousSibling);\n      }\n      visit(node, null);\n    }\n    function d3_layout_treeShift(node) {\n      var shift = 0,\n        change = 0,\n        children = node.children,\n        i = children.length,\n        child;\n      while (--i >= 0) {\n        child = children[i]._tree;\n        child.prelim += shift;\n        child.mod += shift;\n        shift += child.shift + (change += child.change);\n      }\n    }\n    function d3_layout_treeMove(ancestor, node, shift) {\n      ancestor = ancestor._tree;\n      node = node._tree;\n      var change = shift / (node.number - ancestor.number);\n      ancestor.change += change;\n      node.change -= change;\n      node.shift += shift;\n      node.prelim += shift;\n      node.mod += shift;\n    }\n    function d3_layout_treeAncestor(vim, node, ancestor) {\n      return vim._tree.ancestor.parent == node.parent\n        ? vim._tree.ancestor\n        : ancestor;\n    }\n    function d3_layout_treemapPadNull(node) {\n      return {\n        x: node.x,\n        y: node.y,\n        dx: node.dx,\n        dy: node.dy,\n      };\n    }\n    function d3_layout_treemapPad(node, padding) {\n      var x = node.x + padding[3],\n        y = node.y + padding[0],\n        dx = node.dx - padding[1] - padding[3],\n        dy = node.dy - padding[0] - padding[2];\n      if (dx < 0) {\n        x += dx / 2;\n        dx = 0;\n      }\n      if (dy < 0) {\n        y += dy / 2;\n        dy = 0;\n      }\n      return {\n        x: x,\n        y: y,\n        dx: dx,\n        dy: dy,\n      };\n    }\n    function d3_dsv(delimiter, mimeType) {\n      function dsv(url, callback) {\n        d3.text(url, mimeType, function (text) {\n          callback(text && dsv.parse(text));\n        });\n      }\n      function formatRow(row) {\n        return row.map(formatValue).join(delimiter);\n      }\n      function formatValue(text) {\n        return reFormat.test(text)\n          ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"'\n          : text;\n      }\n      var reParse = new RegExp(\"\\r\\n|[\" + delimiter + \"\\r\\n]\", \"g\"),\n        reFormat = new RegExp('[\"' + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n      dsv.parse = function (text) {\n        var header;\n        return dsv.parseRows(text, function (row, i) {\n          if (i) {\n            var o = {},\n              j = -1,\n              m = header.length;\n            while (++j < m) o[header[j]] = row[j];\n            return o;\n          } else {\n            header = row;\n            return null;\n          }\n        });\n      };\n      dsv.parseRows = function (text, f) {\n        function token() {\n          if (reParse.lastIndex >= text.length) return EOF;\n          if (eol) {\n            eol = false;\n            return EOL;\n          }\n          var j = reParse.lastIndex;\n          if (text.charCodeAt(j) === 34) {\n            var i = j;\n            while (i++ < text.length) {\n              if (text.charCodeAt(i) === 34) {\n                if (text.charCodeAt(i + 1) !== 34) break;\n                i++;\n              }\n            }\n            reParse.lastIndex = i + 2;\n            var c = text.charCodeAt(i + 1);\n            if (c === 13) {\n              eol = true;\n              if (text.charCodeAt(i + 2) === 10) reParse.lastIndex++;\n            } else if (c === 10) {\n              eol = true;\n            }\n            return text.substring(j + 1, i).replace(/\"\"/g, '\"');\n          }\n          var m = reParse.exec(text);\n          if (m) {\n            eol = m[0].charCodeAt(0) !== delimiterCode;\n            return text.substring(j, m.index);\n          }\n          reParse.lastIndex = text.length;\n          return text.substring(j);\n        }\n        var EOL = {},\n          EOF = {},\n          rows = [],\n          n = 0,\n          t,\n          eol;\n        reParse.lastIndex = 0;\n        while ((t = token()) !== EOF) {\n          var a = [];\n          while (t !== EOL && t !== EOF) {\n            a.push(t);\n            t = token();\n          }\n          if (f && !(a = f(a, n++))) continue;\n          rows.push(a);\n        }\n        return rows;\n      };\n      dsv.format = function (rows) {\n        return rows.map(formatRow).join(\"\\n\");\n      };\n      return dsv;\n    }\n    function d3_geo_type(types, defaultValue) {\n      return function (object) {\n        return object && types.hasOwnProperty(object.type)\n          ? types[object.type](object)\n          : defaultValue;\n      };\n    }\n    function d3_path_circle(radius) {\n      return (\n        \"m0,\" +\n        radius +\n        \"a\" +\n        radius +\n        \",\" +\n        radius +\n        \" 0 1,1 0,\" +\n        -2 * radius +\n        \"a\" +\n        radius +\n        \",\" +\n        radius +\n        \" 0 1,1 0,\" +\n        +2 * radius +\n        \"z\"\n      );\n    }\n    function d3_geo_bounds(o, f) {\n      if (d3_geo_boundsTypes.hasOwnProperty(o.type))\n        d3_geo_boundsTypes[o.type](o, f);\n    }\n    function d3_geo_boundsFeature(o, f) {\n      d3_geo_bounds(o.geometry, f);\n    }\n    function d3_geo_boundsFeatureCollection(o, f) {\n      for (var a = o.features, i = 0, n = a.length; i < n; i++) {\n        d3_geo_bounds(a[i].geometry, f);\n      }\n    }\n    function d3_geo_boundsGeometryCollection(o, f) {\n      for (var a = o.geometries, i = 0, n = a.length; i < n; i++) {\n        d3_geo_bounds(a[i], f);\n      }\n    }\n    function d3_geo_boundsLineString(o, f) {\n      for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n        f.apply(null, a[i]);\n      }\n    }\n    function d3_geo_boundsMultiLineString(o, f) {\n      for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n        for (var b = a[i], j = 0, m = b.length; j < m; j++) {\n          f.apply(null, b[j]);\n        }\n      }\n    }\n    function d3_geo_boundsMultiPolygon(o, f) {\n      for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n        for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {\n          f.apply(null, b[j]);\n        }\n      }\n    }\n    function d3_geo_boundsPoint(o, f) {\n      f.apply(null, o.coordinates);\n    }\n    function d3_geo_boundsPolygon(o, f) {\n      for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {\n        f.apply(null, a[i]);\n      }\n    }\n    function d3_geo_greatArcSource(d) {\n      return d.source;\n    }\n    function d3_geo_greatArcTarget(d) {\n      return d.target;\n    }\n    function d3_geo_greatArcInterpolator() {\n      function interpolate(t) {\n        var B = Math.sin((t *= d)) * k,\n          A = Math.sin(d - t) * k,\n          x = A * kx0 + B * kx1,\n          y = A * ky0 + B * ky1,\n          z = A * sy0 + B * sy1;\n        return [\n          Math.atan2(y, x) / d3_geo_radians,\n          Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians,\n        ];\n      }\n      var x0, y0, cy0, sy0, kx0, ky0, x1, y1, cy1, sy1, kx1, ky1, d, k;\n      interpolate.distance = function () {\n        if (d == null)\n          k =\n            1 /\n            Math.sin(\n              (d = Math.acos(\n                Math.max(\n                  -1,\n                  Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0))\n                )\n              ))\n            );\n        return d;\n      };\n      interpolate.source = function (_) {\n        var cx0 = Math.cos((x0 = _[0] * d3_geo_radians)),\n          sx0 = Math.sin(x0);\n        cy0 = Math.cos((y0 = _[1] * d3_geo_radians));\n        sy0 = Math.sin(y0);\n        kx0 = cy0 * cx0;\n        ky0 = cy0 * sx0;\n        d = null;\n        return interpolate;\n      };\n      interpolate.target = function (_) {\n        var cx1 = Math.cos((x1 = _[0] * d3_geo_radians)),\n          sx1 = Math.sin(x1);\n        cy1 = Math.cos((y1 = _[1] * d3_geo_radians));\n        sy1 = Math.sin(y1);\n        kx1 = cy1 * cx1;\n        ky1 = cy1 * sx1;\n        d = null;\n        return interpolate;\n      };\n      return interpolate;\n    }\n    function d3_geo_greatArcInterpolate(a, b) {\n      var i = d3_geo_greatArcInterpolator().source(a).target(b);\n      i.distance();\n      return i;\n    }\n    function d3_geom_contourStart(grid) {\n      var x = 0,\n        y = 0;\n      while (true) {\n        if (grid(x, y)) {\n          return [x, y];\n        }\n        if (x === 0) {\n          x = y + 1;\n          y = 0;\n        } else {\n          x = x - 1;\n          y = y + 1;\n        }\n      }\n    }\n    function d3_geom_hullCCW(i1, i2, i3, v) {\n      var t, a, b, c, d, e, f;\n      t = v[i1];\n      a = t[0];\n      b = t[1];\n      t = v[i2];\n      c = t[0];\n      d = t[1];\n      t = v[i3];\n      e = t[0];\n      f = t[1];\n      return (f - b) * (c - a) - (d - b) * (e - a) > 0;\n    }\n    function d3_geom_polygonInside(p, a, b) {\n      return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n    }\n    function d3_geom_polygonIntersect(c, d, a, b) {\n      var x1 = c[0],\n        x2 = d[0],\n        x3 = a[0],\n        x4 = b[0],\n        y1 = c[1],\n        y2 = d[1],\n        y3 = a[1],\n        y4 = b[1],\n        x13 = x1 - x3,\n        x21 = x2 - x1,\n        x43 = x4 - x3,\n        y13 = y1 - y3,\n        y21 = y2 - y1,\n        y43 = y4 - y3,\n        ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);\n      return [x1 + ua * x21, y1 + ua * y21];\n    }\n    function d3_voronoi_tessellate(vertices, callback) {\n      var Sites = {\n        list: vertices\n          .map(function (v, i) {\n            return {\n              index: i,\n              x: v[0],\n              y: v[1],\n            };\n          })\n          .sort(function (a, b) {\n            return a.y < b.y\n              ? -1\n              : a.y > b.y\n              ? 1\n              : a.x < b.x\n              ? -1\n              : a.x > b.x\n              ? 1\n              : 0;\n          }),\n        bottomSite: null,\n      };\n      var EdgeList = {\n        list: [],\n        leftEnd: null,\n        rightEnd: null,\n        init: function () {\n          EdgeList.leftEnd = EdgeList.createHalfEdge(null, \"l\");\n          EdgeList.rightEnd = EdgeList.createHalfEdge(null, \"l\");\n          EdgeList.leftEnd.r = EdgeList.rightEnd;\n          EdgeList.rightEnd.l = EdgeList.leftEnd;\n          EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);\n        },\n        createHalfEdge: function (edge, side) {\n          return {\n            edge: edge,\n            side: side,\n            vertex: null,\n            l: null,\n            r: null,\n          };\n        },\n        insert: function (lb, he) {\n          he.l = lb;\n          he.r = lb.r;\n          lb.r.l = he;\n          lb.r = he;\n        },\n        leftBound: function (p) {\n          var he = EdgeList.leftEnd;\n          do {\n            he = he.r;\n          } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));\n          he = he.l;\n          return he;\n        },\n        del: function (he) {\n          he.l.r = he.r;\n          he.r.l = he.l;\n          he.edge = null;\n        },\n        right: function (he) {\n          return he.r;\n        },\n        left: function (he) {\n          return he.l;\n        },\n        leftRegion: function (he) {\n          return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];\n        },\n        rightRegion: function (he) {\n          return he.edge == null\n            ? Sites.bottomSite\n            : he.edge.region[d3_voronoi_opposite[he.side]];\n        },\n      };\n      var Geom = {\n        bisect: function (s1, s2) {\n          var newEdge = {\n            region: {\n              l: s1,\n              r: s2,\n            },\n            ep: {\n              l: null,\n              r: null,\n            },\n          };\n          var dx = s2.x - s1.x,\n            dy = s2.y - s1.y,\n            adx = dx > 0 ? dx : -dx,\n            ady = dy > 0 ? dy : -dy;\n          newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * 0.5;\n          if (adx > ady) {\n            newEdge.a = 1;\n            newEdge.b = dy / dx;\n            newEdge.c /= dx;\n          } else {\n            newEdge.b = 1;\n            newEdge.a = dx / dy;\n            newEdge.c /= dy;\n          }\n          return newEdge;\n        },\n        intersect: function (el1, el2) {\n          var e1 = el1.edge,\n            e2 = el2.edge;\n          if (!e1 || !e2 || e1.region.r == e2.region.r) {\n            return null;\n          }\n          var d = e1.a * e2.b - e1.b * e2.a;\n          if (Math.abs(d) < 1e-10) {\n            return null;\n          }\n          var xint = (e1.c * e2.b - e2.c * e1.b) / d,\n            yint = (e2.c * e1.a - e1.c * e2.a) / d,\n            e1r = e1.region.r,\n            e2r = e2.region.r,\n            el,\n            e;\n          if (e1r.y < e2r.y || (e1r.y == e2r.y && e1r.x < e2r.x)) {\n            el = el1;\n            e = e1;\n          } else {\n            el = el2;\n            e = e2;\n          }\n          var rightOfSite = xint >= e.region.r.x;\n          if (\n            (rightOfSite && el.side === \"l\") ||\n            (!rightOfSite && el.side === \"r\")\n          ) {\n            return null;\n          }\n          return {\n            x: xint,\n            y: yint,\n          };\n        },\n        rightOf: function (he, p) {\n          var e = he.edge,\n            topsite = e.region.r,\n            rightOfSite = p.x > topsite.x;\n          if (rightOfSite && he.side === \"l\") {\n            return 1;\n          }\n          if (!rightOfSite && he.side === \"r\") {\n            return 0;\n          }\n          if (e.a === 1) {\n            var dyp = p.y - topsite.y,\n              dxp = p.x - topsite.x,\n              fast = 0,\n              above = 0;\n            if ((!rightOfSite && e.b < 0) || (rightOfSite && e.b >= 0)) {\n              above = fast = dyp >= e.b * dxp;\n            } else {\n              above = p.x + p.y * e.b > e.c;\n              if (e.b < 0) {\n                above = !above;\n              }\n              if (!above) {\n                fast = 1;\n              }\n            }\n            if (!fast) {\n              var dxs = topsite.x - e.region.l.x;\n              above =\n                e.b * (dxp * dxp - dyp * dyp) <\n                dxs * dyp * (1 + (2 * dxp) / dxs + e.b * e.b);\n              if (e.b < 0) {\n                above = !above;\n              }\n            }\n          } else {\n            var yl = e.c - e.a * p.x,\n              t1 = p.y - yl,\n              t2 = p.x - topsite.x,\n              t3 = yl - topsite.y;\n            above = t1 * t1 > t2 * t2 + t3 * t3;\n          }\n          return he.side === \"l\" ? above : !above;\n        },\n        endPoint: function (edge, side, site) {\n          edge.ep[side] = site;\n          if (!edge.ep[d3_voronoi_opposite[side]]) return;\n          callback(edge);\n        },\n        distance: function (s, t) {\n          var dx = s.x - t.x,\n            dy = s.y - t.y;\n          return Math.sqrt(dx * dx + dy * dy);\n        },\n      };\n      var EventQueue = {\n        list: [],\n        insert: function (he, site, offset) {\n          he.vertex = site;\n          he.ystar = site.y + offset;\n          for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {\n            var next = list[i];\n            if (\n              he.ystar > next.ystar ||\n              (he.ystar == next.ystar && site.x > next.vertex.x)\n            ) {\n              continue;\n            } else {\n              break;\n            }\n          }\n          list.splice(i, 0, he);\n        },\n        del: function (he) {\n          for (\n            var i = 0, ls = EventQueue.list, l = ls.length;\n            i < l && ls[i] != he;\n            ++i\n          ) {}\n          ls.splice(i, 1);\n        },\n        empty: function () {\n          return EventQueue.list.length === 0;\n        },\n        nextEvent: function (he) {\n          for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {\n            if (ls[i] == he) return ls[i + 1];\n          }\n          return null;\n        },\n        min: function () {\n          var elem = EventQueue.list[0];\n          return {\n            x: elem.vertex.x,\n            y: elem.ystar,\n          };\n        },\n        extractMin: function () {\n          return EventQueue.list.shift();\n        },\n      };\n      EdgeList.init();\n      Sites.bottomSite = Sites.list.shift();\n      var newSite = Sites.list.shift(),\n        newIntStar;\n      var lbnd, rbnd, llbnd, rrbnd, bisector;\n      var bot, top, temp, p, v;\n      var e, pm;\n      while (true) {\n        if (!EventQueue.empty()) {\n          newIntStar = EventQueue.min();\n        }\n        if (\n          newSite &&\n          (EventQueue.empty() ||\n            newSite.y < newIntStar.y ||\n            (newSite.y == newIntStar.y && newSite.x < newIntStar.x))\n        ) {\n          lbnd = EdgeList.leftBound(newSite);\n          rbnd = EdgeList.right(lbnd);\n          bot = EdgeList.rightRegion(lbnd);\n          e = Geom.bisect(bot, newSite);\n          bisector = EdgeList.createHalfEdge(e, \"l\");\n          EdgeList.insert(lbnd, bisector);\n          p = Geom.intersect(lbnd, bisector);\n          if (p) {\n            EventQueue.del(lbnd);\n            EventQueue.insert(lbnd, p, Geom.distance(p, newSite));\n          }\n          lbnd = bisector;\n          bisector = EdgeList.createHalfEdge(e, \"r\");\n          EdgeList.insert(lbnd, bisector);\n          p = Geom.intersect(bisector, rbnd);\n          if (p) {\n            EventQueue.insert(bisector, p, Geom.distance(p, newSite));\n          }\n          newSite = Sites.list.shift();\n        } else if (!EventQueue.empty()) {\n          lbnd = EventQueue.extractMin();\n          llbnd = EdgeList.left(lbnd);\n          rbnd = EdgeList.right(lbnd);\n          rrbnd = EdgeList.right(rbnd);\n          bot = EdgeList.leftRegion(lbnd);\n          top = EdgeList.rightRegion(rbnd);\n          v = lbnd.vertex;\n          Geom.endPoint(lbnd.edge, lbnd.side, v);\n          Geom.endPoint(rbnd.edge, rbnd.side, v);\n          EdgeList.del(lbnd);\n          EventQueue.del(rbnd);\n          EdgeList.del(rbnd);\n          pm = \"l\";\n          if (bot.y > top.y) {\n            temp = bot;\n            bot = top;\n            top = temp;\n            pm = \"r\";\n          }\n          e = Geom.bisect(bot, top);\n          bisector = EdgeList.createHalfEdge(e, pm);\n          EdgeList.insert(llbnd, bisector);\n          Geom.endPoint(e, d3_voronoi_opposite[pm], v);\n          p = Geom.intersect(llbnd, bisector);\n          if (p) {\n            EventQueue.del(llbnd);\n            EventQueue.insert(llbnd, p, Geom.distance(p, bot));\n          }\n          p = Geom.intersect(bisector, rrbnd);\n          if (p) {\n            EventQueue.insert(bisector, p, Geom.distance(p, bot));\n          }\n        } else {\n          break;\n        }\n      }\n      for (\n        lbnd = EdgeList.right(EdgeList.leftEnd);\n        lbnd != EdgeList.rightEnd;\n        lbnd = EdgeList.right(lbnd)\n      ) {\n        callback(lbnd.edge);\n      }\n    }\n    function d3_geom_quadtreeNode() {\n      return {\n        leaf: true,\n        nodes: [],\n        point: null,\n      };\n    }\n    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n      if (!f(node, x1, y1, x2, y2)) {\n        var sx = (x1 + x2) * 0.5,\n          sy = (y1 + y2) * 0.5,\n          children = node.nodes;\n        if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n        if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n        if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n        if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n      }\n    }\n    function d3_geom_quadtreePoint(p) {\n      return {\n        x: p[0],\n        y: p[1],\n      };\n    }\n    function d3_time_utc() {\n      this._ = new Date(\n        arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]\n      );\n    }\n    function d3_time_formatAbbreviate(name) {\n      return name.substring(0, 3);\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c,\n        p,\n        i = 0,\n        n = template.length,\n        m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c == 37) {\n          p = d3_time_parsers[template.charAt(i++)];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    function d3_time_formatRe(names) {\n      return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n    }\n    function d3_time_formatLookup(names) {\n      var map = new d3_Map(),\n        i = -1,\n        n = names.length;\n      while (++i < n) map.set(names[i].toLowerCase(), i);\n      return map;\n    }\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.substring(i));\n      return n ? (i += n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.substring(i));\n      return n ? (i += n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.substring(i));\n      return n\n        ? ((date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase())),\n          (i += n[0].length))\n        : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.substring(i));\n      return n\n        ? ((date.m = d3_time_monthLookup.get(n[0].toLowerCase())),\n          (i += n[0].length))\n        : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseFullYear(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 4));\n      return n ? ((date.y = +n[0]), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseYear(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n      return n\n        ? ((date.y = d3_time_expandYear(+n[0])), (i += n[0].length))\n        : -1;\n    }\n    function d3_time_expandYear(d) {\n      return d + (d > 68 ? 1900 : 2e3);\n    }\n    function d3_time_parseMonthNumber(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n      return n ? ((date.m = n[0] - 1), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseDay(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n      return n ? ((date.d = +n[0]), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseHour24(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n      return n ? ((date.H = +n[0]), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseMinutes(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n      return n ? ((date.M = +n[0]), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseSeconds(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n      return n ? ((date.S = +n[0]), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseMilliseconds(date, string, i) {\n      d3_time_numberRe.lastIndex = 0;\n      var n = d3_time_numberRe.exec(string.substring(i, i + 3));\n      return n ? ((date.L = +n[0]), (i += n[0].length)) : -1;\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_amPmLookup.get(\n        string.substring(i, (i += 2)).toLowerCase()\n      );\n      return n == null ? -1 : ((date.p = n), i);\n    }\n    function d3_time_zone(d) {\n      var z = d.getTimezoneOffset(),\n        zs = z > 0 ? \"-\" : \"+\",\n        zh = ~~(Math.abs(z) / 60),\n        zm = Math.abs(z) % 60;\n      return zs + d3_time_zfill2(zh) + d3_time_zfill2(zm);\n    }\n    function d3_time_formatIsoNative(date) {\n      return date.toISOString();\n    }\n    function d3_time_interval(local, step, number) {\n      function round(date) {\n        var d0 = local(date),\n          d1 = offset(d0, 1);\n        return date - d0 < d1 - date ? d0 : d1;\n      }\n      function ceil(date) {\n        step((date = local(new d3_time(date - 1))), 1);\n        return date;\n      }\n      function offset(date, k) {\n        step((date = new d3_time(+date)), k);\n        return date;\n      }\n      function range(t0, t1, dt) {\n        var time = ceil(t0),\n          times = [];\n        if (dt > 1) {\n          while (time < t1) {\n            if (!(number(time) % dt)) times.push(new Date(+time));\n            step(time, 1);\n          }\n        } else {\n          while (time < t1) times.push(new Date(+time)), step(time, 1);\n        }\n        return times;\n      }\n      function range_utc(t0, t1, dt) {\n        try {\n          d3_time = d3_time_utc;\n          var utc = new d3_time_utc();\n          utc._ = t0;\n          return range(utc, t1, dt);\n        } finally {\n          d3_time = Date;\n        }\n      }\n      local.floor = local;\n      local.round = round;\n      local.ceil = ceil;\n      local.offset = offset;\n      local.range = range;\n      var utc = (local.utc = d3_time_interval_utc(local));\n      utc.floor = utc;\n      utc.round = d3_time_interval_utc(round);\n      utc.ceil = d3_time_interval_utc(ceil);\n      utc.offset = d3_time_interval_utc(offset);\n      utc.range = range_utc;\n      return local;\n    }\n    function d3_time_interval_utc(method) {\n      return function (date, k) {\n        try {\n          d3_time = d3_time_utc;\n          var utc = new d3_time_utc();\n          utc._ = date;\n          return method(utc, k)._;\n        } finally {\n          d3_time = Date;\n        }\n      };\n    }\n    function d3_time_scale(linear, methods, format) {\n      function scale(x) {\n        return linear(x);\n      }\n      scale.invert = function (x) {\n        return d3_time_scaleDate(linear.invert(x));\n      };\n      scale.domain = function (x) {\n        if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n        linear.domain(x);\n        return scale;\n      };\n      scale.nice = function (m) {\n        return scale.domain(\n          d3_scale_nice(scale.domain(), function () {\n            return m;\n          })\n        );\n      };\n      scale.ticks = function (m, k) {\n        var extent = d3_time_scaleExtent(scale.domain());\n        if (typeof m !== \"function\") {\n          var span = extent[1] - extent[0],\n            target = span / m,\n            i = d3.bisect(d3_time_scaleSteps, target);\n          if (i == d3_time_scaleSteps.length) return methods.year(extent, m);\n          if (!i) return linear.ticks(m).map(d3_time_scaleDate);\n          if (\n            Math.log(target / d3_time_scaleSteps[i - 1]) <\n            Math.log(d3_time_scaleSteps[i] / target)\n          )\n            --i;\n          m = methods[i];\n          k = m[1];\n          m = m[0].range;\n        }\n        return m(extent[0], new Date(+extent[1] + 1), k);\n      };\n      scale.tickFormat = function () {\n        return format;\n      };\n      scale.copy = function () {\n        return d3_time_scale(linear.copy(), methods, format);\n      };\n      return d3.rebind(\n        scale,\n        linear,\n        \"range\",\n        \"rangeRound\",\n        \"interpolate\",\n        \"clamp\"\n      );\n    }\n    function d3_time_scaleExtent(domain) {\n      var start = domain[0],\n        stop = domain[domain.length - 1];\n      return start < stop ? [start, stop] : [stop, start];\n    }\n    function d3_time_scaleDate(t) {\n      return new Date(t);\n    }\n    function d3_time_scaleFormat(formats) {\n      return function (date) {\n        var i = formats.length - 1,\n          f = formats[i];\n        while (!f[1](date)) f = formats[--i];\n        return f[0](date);\n      };\n    }\n    function d3_time_scaleSetYear(y) {\n      var d = new Date(y, 0, 1);\n      d.setFullYear(y);\n      return d;\n    }\n    function d3_time_scaleGetYear(d) {\n      var y = d.getFullYear(),\n        d0 = d3_time_scaleSetYear(y),\n        d1 = d3_time_scaleSetYear(y + 1);\n      return y + (d - d0) / (d1 - d0);\n    }\n    function d3_time_scaleUTCSetYear(y) {\n      var d = new Date(Date.UTC(y, 0, 1));\n      d.setUTCFullYear(y);\n      return d;\n    }\n    function d3_time_scaleUTCGetYear(d) {\n      var y = d.getUTCFullYear(),\n        d0 = d3_time_scaleUTCSetYear(y),\n        d1 = d3_time_scaleUTCSetYear(y + 1);\n      return y + (d - d0) / (d1 - d0);\n    }\n    if (!Date.now)\n      Date.now = function () {\n        return +new Date();\n      };\n    try {\n      document.createElement(\"div\").style.setProperty(\"opacity\", 0, \"\");\n    } catch (error) {\n      var d3_style_prototype = CSSStyleDeclaration.prototype,\n        d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_style_prototype.setProperty = function (name, value, priority) {\n        d3_style_setProperty.call(this, name, value + \"\", priority);\n      };\n    }\n    d3 = {\n      version: \"2.10.3\",\n    };\n    var d3_array = d3_arraySlice;\n    try {\n      d3_array(document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = d3_arrayCopy;\n    }\n    var d3_arraySubclass = [].__proto__\n      ? function (array, prototype) {\n          array.__proto__ = prototype;\n        }\n      : function (array, prototype) {\n          for (var property in prototype) array[property] = prototype[property];\n        };\n    d3.map = function (object) {\n      var map = new d3_Map();\n      for (var key in object) map.set(key, object[key]);\n      return map;\n    };\n    d3_class(d3_Map, {\n      has: function (key) {\n        return d3_map_prefix + key in this;\n      },\n      get: function (key) {\n        return this[d3_map_prefix + key];\n      },\n      set: function (key, value) {\n        return (this[d3_map_prefix + key] = value);\n      },\n      remove: function (key) {\n        key = d3_map_prefix + key;\n        return key in this && delete this[key];\n      },\n      keys: function () {\n        var keys = [];\n        this.forEach(function (key) {\n          keys.push(key);\n        });\n        return keys;\n      },\n      values: function () {\n        var values = [];\n        this.forEach(function (key, value) {\n          values.push(value);\n        });\n        return values;\n      },\n      entries: function () {\n        var entries = [];\n        this.forEach(function (key, value) {\n          entries.push({\n            key: key,\n            value: value,\n          });\n        });\n        return entries;\n      },\n      forEach: function (f) {\n        for (var key in this) {\n          if (key.charCodeAt(0) === d3_map_prefixCode) {\n            f.call(this, key.substring(1), this[key]);\n          }\n        }\n      },\n    });\n    var d3_map_prefix = \"\\0\",\n      d3_map_prefixCode = d3_map_prefix.charCodeAt(0);\n    d3.functor = d3_functor;\n    d3.rebind = function (target, source) {\n      var i = 1,\n        n = arguments.length,\n        method;\n      while (++i < n)\n        target[(method = arguments[i])] = d3_rebind(\n          target,\n          source,\n          source[method]\n        );\n      return target;\n    };\n    d3.ascending = function (a, b) {\n      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n    };\n    d3.descending = function (a, b) {\n      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n    };\n    d3.mean = function (array, f) {\n      var n = array.length,\n        a,\n        m = 0,\n        i = -1,\n        j = 0;\n      if (arguments.length === 1) {\n        while (++i < n) if (d3_number((a = array[i]))) m += (a - m) / ++j;\n      } else {\n        while (++i < n)\n          if (d3_number((a = f.call(array, array[i], i)))) m += (a - m) / ++j;\n      }\n      return j ? m : undefined;\n    };\n    d3.median = function (array, f) {\n      if (arguments.length > 1) array = array.map(f);\n      array = array.filter(d3_number);\n      return array.length\n        ? d3.quantile(array.sort(d3.ascending), 0.5)\n        : undefined;\n    };\n    d3.min = function (array, f) {\n      var i = -1,\n        n = array.length,\n        a,\n        b;\n      if (arguments.length === 1) {\n        while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n        while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n      } else {\n        while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a))\n          a = undefined;\n        while (++i < n)\n          if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n      }\n      return a;\n    };\n    d3.max = function (array, f) {\n      var i = -1,\n        n = array.length,\n        a,\n        b;\n      if (arguments.length === 1) {\n        while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n        while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n      } else {\n        while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a))\n          a = undefined;\n        while (++i < n)\n          if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n      }\n      return a;\n    };\n    d3.extent = function (array, f) {\n      var i = -1,\n        n = array.length,\n        a,\n        b,\n        c;\n      if (arguments.length === 1) {\n        while (++i < n && ((a = c = array[i]) == null || a != a))\n          a = c = undefined;\n        while (++i < n)\n          if ((b = array[i]) != null) {\n            if (a > b) a = b;\n            if (c < b) c = b;\n          }\n      } else {\n        while (\n          ++i < n &&\n          ((a = c = f.call(array, array[i], i)) == null || a != a)\n        )\n          a = undefined;\n        while (++i < n)\n          if ((b = f.call(array, array[i], i)) != null) {\n            if (a > b) a = b;\n            if (c < b) c = b;\n          }\n      }\n      return [a, c];\n    };\n    d3.random = {\n      normal: function (µ, σ) {\n        var n = arguments.length;\n        if (n < 2) σ = 1;\n        if (n < 1) µ = 0;\n        return function () {\n          var x, y, r;\n          do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n          } while (!r || r > 1);\n          return µ + σ * x * Math.sqrt((-2 * Math.log(r)) / r);\n        };\n      },\n      logNormal: function (µ, σ) {\n        var n = arguments.length;\n        if (n < 2) σ = 1;\n        if (n < 1) µ = 0;\n        var random = d3.random.normal();\n        return function () {\n          return Math.exp(µ + σ * random());\n        };\n      },\n      irwinHall: function (m) {\n        return function () {\n          for (var s = 0, j = 0; j < m; j++) s += Math.random();\n          return s / m;\n        };\n      },\n    };\n    d3.sum = function (array, f) {\n      var s = 0,\n        n = array.length,\n        a,\n        i = -1;\n      if (arguments.length === 1) {\n        while (++i < n) if (!isNaN((a = +array[i]))) s += a;\n      } else {\n        while (++i < n) if (!isNaN((a = +f.call(array, array[i], i)))) s += a;\n      }\n      return s;\n    };\n    d3.quantile = function (values, p) {\n      var H = (values.length - 1) * p + 1,\n        h = Math.floor(H),\n        v = values[h - 1],\n        e = H - h;\n      return e ? v + e * (values[h] - v) : v;\n    };\n    d3.transpose = function (matrix) {\n      return d3.zip.apply(d3, matrix);\n    };\n    d3.zip = function () {\n      if (!(n = arguments.length)) return [];\n      for (\n        var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m);\n        ++i < m;\n\n      ) {\n        for (var j = -1, n, zip = (zips[i] = new Array(n)); ++j < n; ) {\n          zip[j] = arguments[j][i];\n        }\n      }\n      return zips;\n    };\n    d3.bisector = function (f) {\n      return {\n        left: function (a, x, lo, hi) {\n          if (arguments.length < 3) lo = 0;\n          if (arguments.length < 4) hi = a.length;\n          while (lo < hi) {\n            var mid = (lo + hi) >>> 1;\n            if (f.call(a, a[mid], mid) < x) lo = mid + 1;\n            else hi = mid;\n          }\n          return lo;\n        },\n        right: function (a, x, lo, hi) {\n          if (arguments.length < 3) lo = 0;\n          if (arguments.length < 4) hi = a.length;\n          while (lo < hi) {\n            var mid = (lo + hi) >>> 1;\n            if (x < f.call(a, a[mid], mid)) hi = mid;\n            else lo = mid + 1;\n          }\n          return lo;\n        },\n      };\n    };\n    var d3_bisector = d3.bisector(function (d) {\n      return d;\n    });\n    d3.bisectLeft = d3_bisector.left;\n    d3.bisect = d3.bisectRight = d3_bisector.right;\n    d3.first = function (array, f) {\n      var i = 0,\n        n = array.length,\n        a = array[0],\n        b;\n      if (arguments.length === 1) f = d3.ascending;\n      while (++i < n) {\n        if (f.call(array, a, (b = array[i])) > 0) {\n          a = b;\n        }\n      }\n      return a;\n    };\n    d3.last = function (array, f) {\n      var i = 0,\n        n = array.length,\n        a = array[0],\n        b;\n      if (arguments.length === 1) f = d3.ascending;\n      while (++i < n) {\n        if (f.call(array, a, (b = array[i])) <= 0) {\n          a = b;\n        }\n      }\n      return a;\n    };\n    d3.nest = function () {\n      function map(array, depth) {\n        if (depth >= keys.length)\n          return rollup\n            ? rollup.call(nest, array)\n            : sortValues\n            ? array.sort(sortValues)\n            : array;\n        var i = -1,\n          n = array.length,\n          key = keys[depth++],\n          keyValue,\n          object,\n          valuesByKey = new d3_Map(),\n          values,\n          o = {};\n        while (++i < n) {\n          if (\n            (values = valuesByKey.get((keyValue = key((object = array[i])))))\n          ) {\n            values.push(object);\n          } else {\n            valuesByKey.set(keyValue, [object]);\n          }\n        }\n        valuesByKey.forEach(function (keyValue, values) {\n          o[keyValue] = map(values, depth);\n        });\n        return o;\n      }\n      function entries(map, depth) {\n        if (depth >= keys.length) return map;\n        var a = [],\n          sortKey = sortKeys[depth++],\n          key;\n        for (key in map) {\n          a.push({\n            key: key,\n            values: entries(map[key], depth),\n          });\n        }\n        if (sortKey)\n          a.sort(function (a, b) {\n            return sortKey(a.key, b.key);\n          });\n        return a;\n      }\n      var nest = {},\n        keys = [],\n        sortKeys = [],\n        sortValues,\n        rollup;\n      nest.map = function (array) {\n        return map(array, 0);\n      };\n      nest.entries = function (array) {\n        return entries(map(array, 0), 0);\n      };\n      nest.key = function (d) {\n        keys.push(d);\n        return nest;\n      };\n      nest.sortKeys = function (order) {\n        sortKeys[keys.length - 1] = order;\n        return nest;\n      };\n      nest.sortValues = function (order) {\n        sortValues = order;\n        return nest;\n      };\n      nest.rollup = function (f) {\n        rollup = f;\n        return nest;\n      };\n      return nest;\n    };\n    d3.keys = function (map) {\n      var keys = [];\n      for (var key in map) keys.push(key);\n      return keys;\n    };\n    d3.values = function (map) {\n      var values = [];\n      for (var key in map) values.push(map[key]);\n      return values;\n    };\n    d3.entries = function (map) {\n      var entries = [];\n      for (var key in map)\n        entries.push({\n          key: key,\n          value: map[key],\n        });\n      return entries;\n    };\n    d3.permute = function (array, indexes) {\n      var permutes = [],\n        i = -1,\n        n = indexes.length;\n      while (++i < n) permutes[i] = array[indexes[i]];\n      return permutes;\n    };\n    d3.merge = function (arrays) {\n      return Array.prototype.concat.apply([], arrays);\n    };\n    d3.split = function (array, f) {\n      var arrays = [],\n        values = [],\n        value,\n        i = -1,\n        n = array.length;\n      if (arguments.length < 2) f = d3_splitter;\n      while (++i < n) {\n        if (f.call(values, (value = array[i]), i)) {\n          values = [];\n        } else {\n          if (!values.length) arrays.push(values);\n          values.push(value);\n        }\n      }\n      return arrays;\n    };\n    d3.range = function (start, stop, step) {\n      if (arguments.length < 3) {\n        step = 1;\n        if (arguments.length < 2) {\n          stop = start;\n          start = 0;\n        }\n      }\n      if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n      var range = [],\n        k = d3_range_integerScale(Math.abs(step)),\n        i = -1,\n        j;\n      (start *= k), (stop *= k), (step *= k);\n      if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);\n      else while ((j = start + step * ++i) < stop) range.push(j / k);\n      return range;\n    };\n    d3.requote = function (s) {\n      return s.replace(d3_requote_re, \"\\\\$&\");\n    };\n    var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n    d3.round = function (x, n) {\n      return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n    };\n    d3.xhr = function (url, mime, callback) {\n      var req = new XMLHttpRequest();\n      if (arguments.length < 3) (callback = mime), (mime = null);\n      else if (mime && req.overrideMimeType) req.overrideMimeType(mime);\n      req.open(\"GET\", url, true);\n      if (mime) req.setRequestHeader(\"Accept\", mime);\n      req.onreadystatechange = function () {\n        if (req.readyState === 4) {\n          var s = req.status;\n          callback(\n            (!s && req.response) || (s >= 200 && s < 300) || s === 304\n              ? req\n              : null\n          );\n        }\n      };\n      req.send(null);\n    };\n    d3.text = function (url, mime, callback) {\n      function ready(req) {\n        callback(req && req.responseText);\n      }\n      if (arguments.length < 3) {\n        callback = mime;\n        mime = null;\n      }\n      d3.xhr(url, mime, ready);\n    };\n    d3.json = function (url, callback) {\n      d3.text(url, \"application/json\", function (text) {\n        callback(text ? JSON.parse(text) : null);\n      });\n    };\n    d3.html = function (url, callback) {\n      d3.text(url, \"text/html\", function (text) {\n        if (text != null) {\n          var range = document.createRange();\n          range.selectNode(document.body);\n          text = range.createContextualFragment(text);\n        }\n        callback(text);\n      });\n    };\n    d3.xml = function (url, mime, callback) {\n      function ready(req) {\n        callback(req && req.responseXML);\n      }\n      if (arguments.length < 3) {\n        callback = mime;\n        mime = null;\n      }\n      d3.xhr(url, mime, ready);\n    };\n    var d3_nsPrefix = {\n      svg: \"http://www.w3.org/2000/svg\",\n      xhtml: \"http://www.w3.org/1999/xhtml\",\n      xlink: \"http://www.w3.org/1999/xlink\",\n      xml: \"http://www.w3.org/XML/1998/namespace\",\n      xmlns: \"http://www.w3.org/2000/xmlns/\",\n    };\n    d3.ns = {\n      prefix: d3_nsPrefix,\n      qualify: function (name) {\n        var i = name.indexOf(\":\"),\n          prefix = name;\n        if (i >= 0) {\n          prefix = name.substring(0, i);\n          name = name.substring(i + 1);\n        }\n        return d3_nsPrefix.hasOwnProperty(prefix)\n          ? {\n              space: d3_nsPrefix[prefix],\n              local: name,\n            }\n          : name;\n      },\n    };\n    d3.dispatch = function () {\n      var dispatch = new d3_dispatch(),\n        i = -1,\n        n = arguments.length;\n      while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n      return dispatch;\n    };\n    d3_dispatch.prototype.on = function (type, listener) {\n      var i = type.indexOf(\".\"),\n        name = \"\";\n      if (i > 0) {\n        name = type.substring(i + 1);\n        type = type.substring(0, i);\n      }\n      return arguments.length < 2\n        ? this[type].on(name)\n        : this[type].on(name, listener);\n    };\n    d3.format = function (specifier) {\n      var match = d3_format_re.exec(specifier),\n        fill = match[1] || \" \",\n        sign = match[3] || \"\",\n        zfill = match[5],\n        width = +match[6],\n        comma = match[7],\n        precision = match[8],\n        type = match[9],\n        scale = 1,\n        suffix = \"\",\n        integer = false;\n      if (precision) precision = +precision.substring(1);\n      if (zfill) {\n        fill = \"0\";\n        if (comma) width -= Math.floor((width - 1) / 4);\n      }\n      switch (type) {\n        case \"n\":\n          comma = true;\n          type = \"g\";\n          break;\n        case \"%\":\n          scale = 100;\n          suffix = \"%\";\n          type = \"f\";\n          break;\n        case \"p\":\n          scale = 100;\n          suffix = \"%\";\n          type = \"r\";\n          break;\n        case \"d\":\n          integer = true;\n          precision = 0;\n          break;\n        case \"s\":\n          scale = -1;\n          type = \"r\";\n          break;\n      }\n      if (type == \"r\" && !precision) type = \"g\";\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      return function (value) {\n        if (integer && value % 1) return \"\";\n        var negative = value < 0 && (value = -value) ? \"-\" : sign;\n        if (scale < 0) {\n          var prefix = d3.formatPrefix(value, precision);\n          value = prefix.scale(value);\n          suffix = prefix.symbol;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        if (zfill) {\n          var length = value.length + negative.length;\n          if (length < width)\n            value = new Array(width - length + 1).join(fill) + value;\n          if (comma) value = d3_format_group(value);\n          value = negative + value;\n        } else {\n          if (comma) value = d3_format_group(value);\n          value = negative + value;\n          var length = value.length;\n          if (length < width)\n            value = new Array(width - length + 1).join(fill) + value;\n        }\n        return value + suffix;\n      };\n    };\n    var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\n    var d3_format_types = d3.map({\n      g: function (x, p) {\n        return x.toPrecision(p);\n      },\n      e: function (x, p) {\n        return x.toExponential(p);\n      },\n      f: function (x, p) {\n        return x.toFixed(p);\n      },\n      r: function (x, p) {\n        return d3\n          .round(x, (p = d3_format_precision(x, p)))\n          .toFixed(Math.max(0, Math.min(20, p)));\n      },\n    });\n    var d3_formatPrefixes = [\n      \"y\",\n      \"z\",\n      \"a\",\n      \"f\",\n      \"p\",\n      \"n\",\n      \"μ\",\n      \"m\",\n      \"\",\n      \"k\",\n      \"M\",\n      \"G\",\n      \"T\",\n      \"P\",\n      \"E\",\n      \"Z\",\n      \"Y\",\n    ].map(d3_formatPrefix);\n    d3.formatPrefix = function (value, precision) {\n      var i = 0;\n      if (value) {\n        if (value < 0) value *= -1;\n        if (precision)\n          value = d3.round(value, d3_format_precision(value, precision));\n        i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n        i = Math.max(\n          -24,\n          Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3)\n        );\n      }\n      return d3_formatPrefixes[8 + i / 3];\n    };\n    var d3_ease_quad = d3_ease_poly(2),\n      d3_ease_cubic = d3_ease_poly(3),\n      d3_ease_default = function () {\n        return d3_ease_identity;\n      };\n    var d3_ease = d3.map({\n      linear: d3_ease_default,\n      poly: d3_ease_poly,\n      quad: function () {\n        return d3_ease_quad;\n      },\n      cubic: function () {\n        return d3_ease_cubic;\n      },\n      sin: function () {\n        return d3_ease_sin;\n      },\n      exp: function () {\n        return d3_ease_exp;\n      },\n      circle: function () {\n        return d3_ease_circle;\n      },\n      elastic: d3_ease_elastic,\n      back: d3_ease_back,\n      bounce: function () {\n        return d3_ease_bounce;\n      },\n    });\n    var d3_ease_mode = d3.map({\n      in: d3_ease_identity,\n      out: d3_ease_reverse,\n      \"in-out\": d3_ease_reflect,\n      \"out-in\": function (f) {\n        return d3_ease_reflect(d3_ease_reverse(f));\n      },\n    });\n    d3.ease = function (name) {\n      var i = name.indexOf(\"-\"),\n        t = i >= 0 ? name.substring(0, i) : name,\n        m = i >= 0 ? name.substring(i + 1) : \"in\";\n      t = d3_ease.get(t) || d3_ease_default;\n      m = d3_ease_mode.get(m) || d3_ease_identity;\n      return d3_ease_clamp(\n        m(t.apply(null, Array.prototype.slice.call(arguments, 1)))\n      );\n    };\n    d3.event = null;\n    d3.transform = function (string) {\n      var g = document.createElementNS(d3.ns.prefix.svg, \"g\");\n      return (d3.transform = function (string) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n        return new d3_transform(t ? t.matrix : d3_transformIdentity);\n      })(string);\n    };\n    d3_transform.prototype.toString = function () {\n      return (\n        \"translate(\" +\n        this.translate +\n        \")rotate(\" +\n        this.rotate +\n        \")skewX(\" +\n        this.skew +\n        \")scale(\" +\n        this.scale +\n        \")\"\n      );\n    };\n    var d3_transformDegrees = 180 / Math.PI,\n      d3_transformIdentity = {\n        a: 1,\n        b: 0,\n        c: 0,\n        d: 1,\n        e: 0,\n        f: 0,\n      };\n    d3.interpolate = function (a, b) {\n      var i = d3.interpolators.length,\n        f;\n      while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n      return f;\n    };\n    d3.interpolateNumber = function (a, b) {\n      b -= a;\n      return function (t) {\n        return a + b * t;\n      };\n    };\n    d3.interpolateRound = function (a, b) {\n      b -= a;\n      return function (t) {\n        return Math.round(a + b * t);\n      };\n    };\n    d3.interpolateString = function (a, b) {\n      var m,\n        i,\n        j,\n        s0 = 0,\n        s1 = 0,\n        s = [],\n        q = [],\n        n,\n        o;\n      d3_interpolate_number.lastIndex = 0;\n      for (i = 0; (m = d3_interpolate_number.exec(b)); ++i) {\n        if (m.index) s.push(b.substring(s0, (s1 = m.index)));\n        q.push({\n          i: s.length,\n          x: m[0],\n        });\n        s.push(null);\n        s0 = d3_interpolate_number.lastIndex;\n      }\n      if (s0 < b.length) s.push(b.substring(s0));\n      for (\n        i = 0, n = q.length;\n        (m = d3_interpolate_number.exec(a)) && i < n;\n        ++i\n      ) {\n        o = q[i];\n        if (o.x == m[0]) {\n          if (o.i) {\n            if (s[o.i + 1] == null) {\n              s[o.i - 1] += o.x;\n              s.splice(o.i, 1);\n              for (j = i + 1; j < n; ++j) q[j].i--;\n            } else {\n              s[o.i - 1] += o.x + s[o.i + 1];\n              s.splice(o.i, 2);\n              for (j = i + 1; j < n; ++j) q[j].i -= 2;\n            }\n          } else {\n            if (s[o.i + 1] == null) {\n              s[o.i] = o.x;\n            } else {\n              s[o.i] = o.x + s[o.i + 1];\n              s.splice(o.i + 1, 1);\n              for (j = i + 1; j < n; ++j) q[j].i--;\n            }\n          }\n          q.splice(i, 1);\n          n--;\n          i--;\n        } else {\n          o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\n        }\n      }\n      while (i < n) {\n        o = q.pop();\n        if (s[o.i + 1] == null) {\n          s[o.i] = o.x;\n        } else {\n          s[o.i] = o.x + s[o.i + 1];\n          s.splice(o.i + 1, 1);\n        }\n        n--;\n      }\n      if (s.length === 1) {\n        return s[0] == null\n          ? q[0].x\n          : function () {\n              return b;\n            };\n      }\n      return function (t) {\n        for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\n        return s.join(\"\");\n      };\n    };\n    d3.interpolateTransform = function (a, b) {\n      var s = [],\n        q = [],\n        n,\n        A = d3.transform(a),\n        B = d3.transform(b),\n        ta = A.translate,\n        tb = B.translate,\n        ra = A.rotate,\n        rb = B.rotate,\n        wa = A.skew,\n        wb = B.skew,\n        ka = A.scale,\n        kb = B.scale;\n      if (ta[0] != tb[0] || ta[1] != tb[1]) {\n        s.push(\"translate(\", null, \",\", null, \")\");\n        q.push(\n          {\n            i: 1,\n            x: d3.interpolateNumber(ta[0], tb[0]),\n          },\n          {\n            i: 3,\n            x: d3.interpolateNumber(ta[1], tb[1]),\n          }\n        );\n      } else if (tb[0] || tb[1]) {\n        s.push(\"translate(\" + tb + \")\");\n      } else {\n        s.push(\"\");\n      }\n      if (ra != rb) {\n        if (ra - rb > 180) rb += 360;\n        else if (rb - ra > 180) ra += 360;\n        q.push({\n          i: s.push(s.pop() + \"rotate(\", null, \")\") - 2,\n          x: d3.interpolateNumber(ra, rb),\n        });\n      } else if (rb) {\n        s.push(s.pop() + \"rotate(\" + rb + \")\");\n      }\n      if (wa != wb) {\n        q.push({\n          i: s.push(s.pop() + \"skewX(\", null, \")\") - 2,\n          x: d3.interpolateNumber(wa, wb),\n        });\n      } else if (wb) {\n        s.push(s.pop() + \"skewX(\" + wb + \")\");\n      }\n      if (ka[0] != kb[0] || ka[1] != kb[1]) {\n        n = s.push(s.pop() + \"scale(\", null, \",\", null, \")\");\n        q.push(\n          {\n            i: n - 4,\n            x: d3.interpolateNumber(ka[0], kb[0]),\n          },\n          {\n            i: n - 2,\n            x: d3.interpolateNumber(ka[1], kb[1]),\n          }\n        );\n      } else if (kb[0] != 1 || kb[1] != 1) {\n        s.push(s.pop() + \"scale(\" + kb + \")\");\n      }\n      n = q.length;\n      return function (t) {\n        var i = -1,\n          o;\n        while (++i < n) s[(o = q[i]).i] = o.x(t);\n        return s.join(\"\");\n      };\n    };\n    d3.interpolateRgb = function (a, b) {\n      a = d3.rgb(a);\n      b = d3.rgb(b);\n      var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n      return function (t) {\n        return (\n          \"#\" +\n          d3_rgb_hex(Math.round(ar + br * t)) +\n          d3_rgb_hex(Math.round(ag + bg * t)) +\n          d3_rgb_hex(Math.round(ab + bb * t))\n        );\n      };\n    };\n    d3.interpolateHsl = function (a, b) {\n      a = d3.hsl(a);\n      b = d3.hsl(b);\n      var h0 = a.h,\n        s0 = a.s,\n        l0 = a.l,\n        h1 = b.h - h0,\n        s1 = b.s - s0,\n        l1 = b.l - l0;\n      if (h1 > 180) h1 -= 360;\n      else if (h1 < -180) h1 += 360;\n      return function (t) {\n        return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + \"\";\n      };\n    };\n    d3.interpolateLab = function (a, b) {\n      a = d3.lab(a);\n      b = d3.lab(b);\n      var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n      return function (t) {\n        return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n      };\n    };\n    d3.interpolateHcl = function (a, b) {\n      a = d3.hcl(a);\n      b = d3.hcl(b);\n      var ah = a.h,\n        ac = a.c,\n        al = a.l,\n        bh = b.h - ah,\n        bc = b.c - ac,\n        bl = b.l - al;\n      if (bh > 180) bh -= 360;\n      else if (bh < -180) bh += 360;\n      return function (t) {\n        return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n      };\n    };\n    d3.interpolateArray = function (a, b) {\n      var x = [],\n        c = [],\n        na = a.length,\n        nb = b.length,\n        n0 = Math.min(a.length, b.length),\n        i;\n      for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\n      for (; i < na; ++i) c[i] = a[i];\n      for (; i < nb; ++i) c[i] = b[i];\n      return function (t) {\n        for (i = 0; i < n0; ++i) c[i] = x[i](t);\n        return c;\n      };\n    };\n    d3.interpolateObject = function (a, b) {\n      var i = {},\n        c = {},\n        k;\n      for (k in a) {\n        if (k in b) {\n          i[k] = d3_interpolateByName(k)(a[k], b[k]);\n        } else {\n          c[k] = a[k];\n        }\n      }\n      for (k in b) {\n        if (!(k in a)) {\n          c[k] = b[k];\n        }\n      }\n      return function (t) {\n        for (k in i) c[k] = i[k](t);\n        return c;\n      };\n    };\n    var d3_interpolate_number = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\n    d3.interpolators = [\n      d3.interpolateObject,\n      function (a, b) {\n        return b instanceof Array && d3.interpolateArray(a, b);\n      },\n      function (a, b) {\n        return (\n          (typeof a === \"string\" || typeof b === \"string\") &&\n          d3.interpolateString(a + \"\", b + \"\")\n        );\n      },\n      function (a, b) {\n        return (\n          (typeof b === \"string\"\n            ? d3_rgb_names.has(b) || /^(#|rgb\\(|hsl\\()/.test(b)\n            : b instanceof d3_Color) && d3.interpolateRgb(a, b)\n        );\n      },\n      function (a, b) {\n        return (\n          !isNaN((a = +a)) && !isNaN((b = +b)) && d3.interpolateNumber(a, b)\n        );\n      },\n    ];\n    d3_Color.prototype.toString = function () {\n      return this.rgb() + \"\";\n    };\n    d3.rgb = function (r, g, b) {\n      return arguments.length === 1\n        ? r instanceof d3_Rgb\n          ? d3_rgb(r.r, r.g, r.b)\n          : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb)\n        : d3_rgb(~~r, ~~g, ~~b);\n    };\n    var d3_rgbPrototype = (d3_Rgb.prototype = new d3_Color());\n    d3_rgbPrototype.brighter = function (k) {\n      k = Math.pow(0.7, arguments.length ? k : 1);\n      var r = this.r,\n        g = this.g,\n        b = this.b,\n        i = 30;\n      if (!r && !g && !b) return d3_rgb(i, i, i);\n      if (r && r < i) r = i;\n      if (g && g < i) g = i;\n      if (b && b < i) b = i;\n      return d3_rgb(\n        Math.min(255, Math.floor(r / k)),\n        Math.min(255, Math.floor(g / k)),\n        Math.min(255, Math.floor(b / k))\n      );\n    };\n    d3_rgbPrototype.darker = function (k) {\n      k = Math.pow(0.7, arguments.length ? k : 1);\n      return d3_rgb(\n        Math.floor(k * this.r),\n        Math.floor(k * this.g),\n        Math.floor(k * this.b)\n      );\n    };\n    d3_rgbPrototype.hsl = function () {\n      return d3_rgb_hsl(this.r, this.g, this.b);\n    };\n    d3_rgbPrototype.toString = function () {\n      return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n    };\n    var d3_rgb_names = d3.map({\n      black: \"#000000\",\n      white: \"#ffffff\",\n      cyan: \"#00ffff\",\n      fuchsia: \"#ff00ff\",\n      lime: \"#00ff00\",\n      limegreen: \"#32cd32\",\n      tangerine: \"#f28500\",\n      ultramarineblue: \"#4166f5\",\n      yellow: \"#ffff00\",\n    });\n    d3_rgb_names.forEach(function (key, value) {\n      d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));\n    });\n    d3.hsl = function (h, s, l) {\n      return arguments.length === 1\n        ? h instanceof d3_Hsl\n          ? d3_hsl(h.h, h.s, h.l)\n          : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl)\n        : d3_hsl(+h, +s, +l);\n    };\n    var d3_hslPrototype = (d3_Hsl.prototype = new d3_Color());\n    d3_hslPrototype.brighter = function (k) {\n      k = Math.pow(0.7, arguments.length ? k : 1);\n      return d3_hsl(this.h, this.s, this.l / k);\n    };\n    d3_hslPrototype.darker = function (k) {\n      k = Math.pow(0.7, arguments.length ? k : 1);\n      return d3_hsl(this.h, this.s, k * this.l);\n    };\n    d3_hslPrototype.rgb = function () {\n      return d3_hsl_rgb(this.h, this.s, this.l);\n    };\n    d3.hcl = function (h, c, l) {\n      return arguments.length === 1\n        ? h instanceof d3_Hcl\n          ? d3_hcl(h.h, h.c, h.l)\n          : h instanceof d3_Lab\n          ? d3_lab_hcl(h.l, h.a, h.b)\n          : d3_lab_hcl(\n              (h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l,\n              h.a,\n              h.b\n            )\n        : d3_hcl(+h, +c, +l);\n    };\n    var d3_hclPrototype = (d3_Hcl.prototype = new d3_Color());\n    d3_hclPrototype.brighter = function (k) {\n      return d3_hcl(\n        this.h,\n        this.c,\n        Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1))\n      );\n    };\n    d3_hclPrototype.darker = function (k) {\n      return d3_hcl(\n        this.h,\n        this.c,\n        Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1))\n      );\n    };\n    d3_hclPrototype.rgb = function () {\n      return d3_hcl_lab(this.h, this.c, this.l).rgb();\n    };\n    d3.lab = function (l, a, b) {\n      return arguments.length === 1\n        ? l instanceof d3_Lab\n          ? d3_lab(l.l, l.a, l.b)\n          : l instanceof d3_Hcl\n          ? d3_hcl_lab(l.l, l.c, l.h)\n          : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b)\n        : d3_lab(+l, +a, +b);\n    };\n    var d3_lab_K = 18;\n    var d3_lab_X = 0.95047,\n      d3_lab_Y = 1,\n      d3_lab_Z = 1.08883;\n    var d3_labPrototype = (d3_Lab.prototype = new d3_Color());\n    d3_labPrototype.brighter = function (k) {\n      return d3_lab(\n        Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)),\n        this.a,\n        this.b\n      );\n    };\n    d3_labPrototype.darker = function (k) {\n      return d3_lab(\n        Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)),\n        this.a,\n        this.b\n      );\n    };\n    d3_labPrototype.rgb = function () {\n      return d3_lab_rgb(this.l, this.a, this.b);\n    };\n    var d3_select = function (s, n) {\n        return n.querySelector(s);\n      },\n      d3_selectAll = function (s, n) {\n        return n.querySelectorAll(s);\n      },\n      d3_selectRoot = document.documentElement,\n      d3_selectMatcher =\n        d3_selectRoot.matchesSelector ||\n        d3_selectRoot.webkitMatchesSelector ||\n        d3_selectRoot.mozMatchesSelector ||\n        d3_selectRoot.msMatchesSelector ||\n        d3_selectRoot.oMatchesSelector,\n      d3_selectMatches = function (n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n    if (typeof Sizzle === \"function\") {\n      d3_select = function (s, n) {\n        return Sizzle(s, n)[0] || null;\n      };\n      d3_selectAll = function (s, n) {\n        return Sizzle.uniqueSort(Sizzle(s, n));\n      };\n      d3_selectMatches = Sizzle.matchesSelector;\n    }\n    var d3_selectionPrototype = [];\n    d3.selection = function () {\n      return d3_selectionRoot;\n    };\n    d3.selection.prototype = d3_selectionPrototype;\n    d3_selectionPrototype.select = function (selector) {\n      var subgroups = [],\n        subgroup,\n        subnode,\n        group,\n        node;\n      if (typeof selector !== \"function\")\n        selector = d3_selection_selector(selector);\n      for (var j = -1, m = this.length; ++j < m; ) {\n        subgroups.push((subgroup = []));\n        subgroup.parentNode = (group = this[j]).parentNode;\n        for (var i = -1, n = group.length; ++i < n; ) {\n          if ((node = group[i])) {\n            subgroup.push((subnode = selector.call(node, node.__data__, i)));\n            if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n          } else {\n            subgroup.push(null);\n          }\n        }\n      }\n      return d3_selection(subgroups);\n    };\n    d3_selectionPrototype.selectAll = function (selector) {\n      var subgroups = [],\n        subgroup,\n        node;\n      if (typeof selector !== \"function\")\n        selector = d3_selection_selectorAll(selector);\n      for (var j = -1, m = this.length; ++j < m; ) {\n        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n          if ((node = group[i])) {\n            subgroups.push(\n              (subgroup = d3_array(selector.call(node, node.__data__, i)))\n            );\n            subgroup.parentNode = node;\n          }\n        }\n      }\n      return d3_selection(subgroups);\n    };\n    d3_selectionPrototype.attr = function (name, value) {\n      if (arguments.length < 2) {\n        if (typeof name === \"string\") {\n          var node = this.node();\n          name = d3.ns.qualify(name);\n          return name.local\n            ? node.getAttributeNS(name.space, name.local)\n            : node.getAttribute(name);\n        }\n        for (value in name) this.each(d3_selection_attr(value, name[value]));\n        return this;\n      }\n      return this.each(d3_selection_attr(name, value));\n    };\n    d3_selectionPrototype.classed = function (name, value) {\n      if (arguments.length < 2) {\n        if (typeof name === \"string\") {\n          var node = this.node(),\n            n = (name = name.trim().split(/^|\\s+/g)).length,\n            i = -1;\n          if ((value = node.classList)) {\n            while (++i < n) if (!value.contains(name[i])) return false;\n          } else {\n            value = node.className;\n            if (value.baseVal != null) value = value.baseVal;\n            while (++i < n)\n              if (!d3_selection_classedRe(name[i]).test(value)) return false;\n          }\n          return true;\n        }\n        for (value in name) this.each(d3_selection_classed(value, name[value]));\n        return this;\n      }\n      return this.each(d3_selection_classed(name, value));\n    };\n    d3_selectionPrototype.style = function (name, value, priority) {\n      var n = arguments.length;\n      if (n < 3) {\n        if (typeof name !== \"string\") {\n          if (n < 2) value = \"\";\n          for (priority in name)\n            this.each(d3_selection_style(priority, name[priority], value));\n          return this;\n        }\n        if (n < 2)\n          return window\n            .getComputedStyle(this.node(), null)\n            .getPropertyValue(name);\n        priority = \"\";\n      }\n      return this.each(d3_selection_style(name, value, priority));\n    };\n    d3_selectionPrototype.property = function (name, value) {\n      if (arguments.length < 2) {\n        if (typeof name === \"string\") return this.node()[name];\n        for (value in name)\n          this.each(d3_selection_property(value, name[value]));\n        return this;\n      }\n      return this.each(d3_selection_property(name, value));\n    };\n    d3_selectionPrototype.text = function (value) {\n      return arguments.length < 1\n        ? this.node().textContent\n        : this.each(\n            typeof value === \"function\"\n              ? function () {\n                  var v = value.apply(this, arguments);\n                  this.textContent = v == null ? \"\" : v;\n                }\n              : value == null\n              ? function () {\n                  this.textContent = \"\";\n                }\n              : function () {\n                  this.textContent = value;\n                }\n          );\n    };\n    d3_selectionPrototype.html = function (value) {\n      return arguments.length < 1\n        ? this.node().innerHTML\n        : this.each(\n            typeof value === \"function\"\n              ? function () {\n                  var v = value.apply(this, arguments);\n                  this.innerHTML = v == null ? \"\" : v;\n                }\n              : value == null\n              ? function () {\n                  this.innerHTML = \"\";\n                }\n              : function () {\n                  this.innerHTML = value;\n                }\n          );\n    };\n    d3_selectionPrototype.append = function (name) {\n      function append() {\n        return this.appendChild(\n          document.createElementNS(this.namespaceURI, name)\n        );\n      }\n      function appendNS() {\n        return this.appendChild(\n          document.createElementNS(name.space, name.local)\n        );\n      }\n      name = d3.ns.qualify(name);\n      return this.select(name.local ? appendNS : append);\n    };\n    d3_selectionPrototype.insert = function (name, before) {\n      function insert() {\n        return this.insertBefore(\n          document.createElementNS(this.namespaceURI, name),\n          d3_select(before, this)\n        );\n      }\n      function insertNS() {\n        return this.insertBefore(\n          document.createElementNS(name.space, name.local),\n          d3_select(before, this)\n        );\n      }\n      name = d3.ns.qualify(name);\n      return this.select(name.local ? insertNS : insert);\n    };\n    d3_selectionPrototype.remove = function () {\n      return this.each(function () {\n        var parent = this.parentNode;\n        if (parent) parent.removeChild(this);\n      });\n    };\n    d3_selectionPrototype.data = function (value, key) {\n      function bind(group, groupData) {\n        var i,\n          n = group.length,\n          m = groupData.length,\n          n0 = Math.min(n, m),\n          n1 = Math.max(n, m),\n          updateNodes = [],\n          enterNodes = [],\n          exitNodes = [],\n          node,\n          nodeData;\n        if (key) {\n          var nodeByKeyValue = new d3_Map(),\n            keyValues = [],\n            keyValue,\n            j = groupData.length;\n          for (i = -1; ++i < n; ) {\n            keyValue = key.call((node = group[i]), node.__data__, i);\n            if (nodeByKeyValue.has(keyValue)) {\n              exitNodes[j++] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues.push(keyValue);\n          }\n          for (i = -1; ++i < m; ) {\n            keyValue = key.call(groupData, (nodeData = groupData[i]), i);\n            if (nodeByKeyValue.has(keyValue)) {\n              updateNodes[i] = node = nodeByKeyValue.get(keyValue);\n              node.__data__ = nodeData;\n              enterNodes[i] = exitNodes[i] = null;\n            } else {\n              enterNodes[i] = d3_selection_dataNode(nodeData);\n              updateNodes[i] = exitNodes[i] = null;\n            }\n            nodeByKeyValue.remove(keyValue);\n          }\n          for (i = -1; ++i < n; ) {\n            if (nodeByKeyValue.has(keyValues[i])) {\n              exitNodes[i] = group[i];\n            }\n          }\n        } else {\n          for (i = -1; ++i < n0; ) {\n            node = group[i];\n            nodeData = groupData[i];\n            if (node) {\n              node.__data__ = nodeData;\n              updateNodes[i] = node;\n              enterNodes[i] = exitNodes[i] = null;\n            } else {\n              enterNodes[i] = d3_selection_dataNode(nodeData);\n              updateNodes[i] = exitNodes[i] = null;\n            }\n          }\n          for (; i < m; ++i) {\n            enterNodes[i] = d3_selection_dataNode(groupData[i]);\n            updateNodes[i] = exitNodes[i] = null;\n          }\n          for (; i < n1; ++i) {\n            exitNodes[i] = group[i];\n            enterNodes[i] = updateNodes[i] = null;\n          }\n        }\n        enterNodes.update = updateNodes;\n        enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode =\n          group.parentNode;\n        enter.push(enterNodes);\n        update.push(updateNodes);\n        exit.push(exitNodes);\n      }\n      var i = -1,\n        n = this.length,\n        group,\n        node;\n      if (!arguments.length) {\n        value = new Array((n = (group = this[0]).length));\n        while (++i < n) {\n          if ((node = group[i])) {\n            value[i] = node.__data__;\n          }\n        }\n        return value;\n      }\n      var enter = d3_selection_enter([]),\n        update = d3_selection([]),\n        exit = d3_selection([]);\n      if (typeof value === \"function\") {\n        while (++i < n) {\n          bind(\n            (group = this[i]),\n            value.call(group, group.parentNode.__data__, i)\n          );\n        }\n      } else {\n        while (++i < n) {\n          bind((group = this[i]), value);\n        }\n      }\n      update.enter = function () {\n        return enter;\n      };\n      update.exit = function () {\n        return exit;\n      };\n      return update;\n    };\n    d3_selectionPrototype.datum = d3_selectionPrototype.map = function (value) {\n      return arguments.length < 1\n        ? this.property(\"__data__\")\n        : this.property(\"__data__\", value);\n    };\n    d3_selectionPrototype.filter = function (filter) {\n      var subgroups = [],\n        subgroup,\n        group,\n        node;\n      if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n      for (var j = 0, m = this.length; j < m; j++) {\n        subgroups.push((subgroup = []));\n        subgroup.parentNode = (group = this[j]).parentNode;\n        for (var i = 0, n = group.length; i < n; i++) {\n          if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n            subgroup.push(node);\n          }\n        }\n      }\n      return d3_selection(subgroups);\n    };\n    d3_selectionPrototype.order = function () {\n      for (var j = -1, m = this.length; ++j < m; ) {\n        for (\n          var group = this[j], i = group.length - 1, next = group[i], node;\n          --i >= 0;\n\n        ) {\n          if ((node = group[i])) {\n            if (next && next !== node.nextSibling)\n              next.parentNode.insertBefore(node, next);\n            next = node;\n          }\n        }\n      }\n      return this;\n    };\n    d3_selectionPrototype.sort = function (comparator) {\n      comparator = d3_selection_sortComparator.apply(this, arguments);\n      for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n      return this.order();\n    };\n    d3_selectionPrototype.on = function (type, listener, capture) {\n      var n = arguments.length;\n      if (n < 3) {\n        if (typeof type !== \"string\") {\n          if (n < 2) listener = false;\n          for (capture in type)\n            this.each(d3_selection_on(capture, type[capture], listener));\n          return this;\n        }\n        if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n        capture = false;\n      }\n      return this.each(d3_selection_on(type, listener, capture));\n    };\n    d3_selectionPrototype.each = function (callback) {\n      return d3_selection_each(this, function (node, i, j) {\n        callback.call(node, node.__data__, i, j);\n      });\n    };\n    d3_selectionPrototype.call = function (callback) {\n      callback.apply(this, ((arguments[0] = this), arguments));\n      return this;\n    };\n    d3_selectionPrototype.empty = function () {\n      return !this.node();\n    };\n    d3_selectionPrototype.node = function (callback) {\n      for (var j = 0, m = this.length; j < m; j++) {\n        for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n          var node = group[i];\n          if (node) return node;\n        }\n      }\n      return null;\n    };\n    d3_selectionPrototype.transition = function () {\n      var subgroups = [],\n        subgroup,\n        node;\n      for (var j = -1, m = this.length; ++j < m; ) {\n        subgroups.push((subgroup = []));\n        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n          subgroup.push(\n            (node = group[i])\n              ? {\n                  node: node,\n                  delay: d3_transitionDelay,\n                  duration: d3_transitionDuration,\n                }\n              : null\n          );\n        }\n      }\n      return d3_transition(\n        subgroups,\n        d3_transitionId || ++d3_transitionNextId,\n        Date.now()\n      );\n    };\n    var d3_selectionRoot = d3_selection([[document]]);\n    d3_selectionRoot[0].parentNode = d3_selectRoot;\n    d3.select = function (selector) {\n      return typeof selector === \"string\"\n        ? d3_selectionRoot.select(selector)\n        : d3_selection([[selector]]);\n    };\n    d3.selectAll = function (selector) {\n      return typeof selector === \"string\"\n        ? d3_selectionRoot.selectAll(selector)\n        : d3_selection([d3_array(selector)]);\n    };\n    var d3_selection_enterPrototype = [];\n    d3.selection.enter = d3_selection_enter;\n    d3.selection.enter.prototype = d3_selection_enterPrototype;\n    d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n    d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;\n    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n    d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n    d3_selection_enterPrototype.select = function (selector) {\n      var subgroups = [],\n        subgroup,\n        subnode,\n        upgroup,\n        group,\n        node;\n      for (var j = -1, m = this.length; ++j < m; ) {\n        upgroup = (group = this[j]).update;\n        subgroups.push((subgroup = []));\n        subgroup.parentNode = group.parentNode;\n        for (var i = -1, n = group.length; ++i < n; ) {\n          if ((node = group[i])) {\n            subgroup.push(\n              (upgroup[i] = subnode = selector.call(\n                group.parentNode,\n                node.__data__,\n                i\n              ))\n            );\n            subnode.__data__ = node.__data__;\n          } else {\n            subgroup.push(null);\n          }\n        }\n      }\n      return d3_selection(subgroups);\n    };\n    var d3_transitionPrototype = [],\n      d3_transitionNextId = 0,\n      d3_transitionId = 0,\n      d3_transitionDefaultDelay = 0,\n      d3_transitionDefaultDuration = 250,\n      d3_transitionDefaultEase = d3.ease(\"cubic-in-out\"),\n      d3_transitionDelay = d3_transitionDefaultDelay,\n      d3_transitionDuration = d3_transitionDefaultDuration,\n      d3_transitionEase = d3_transitionDefaultEase;\n    d3_transitionPrototype.call = d3_selectionPrototype.call;\n    d3.transition = function (selection) {\n      return arguments.length\n        ? d3_transitionId\n          ? selection.transition()\n          : selection\n        : d3_selectionRoot.transition();\n    };\n    d3.transition.prototype = d3_transitionPrototype;\n    d3_transitionPrototype.select = function (selector) {\n      var subgroups = [],\n        subgroup,\n        subnode,\n        node;\n      if (typeof selector !== \"function\")\n        selector = d3_selection_selector(selector);\n      for (var j = -1, m = this.length; ++j < m; ) {\n        subgroups.push((subgroup = []));\n        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n          if (\n            (node = group[i]) &&\n            (subnode = selector.call(node.node, node.node.__data__, i))\n          ) {\n            if (\"__data__\" in node.node) subnode.__data__ = node.node.__data__;\n            subgroup.push({\n              node: subnode,\n              delay: node.delay,\n              duration: node.duration,\n            });\n          } else {\n            subgroup.push(null);\n          }\n        }\n      }\n      return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n    };\n    d3_transitionPrototype.selectAll = function (selector) {\n      var subgroups = [],\n        subgroup,\n        subnodes,\n        node;\n      if (typeof selector !== \"function\")\n        selector = d3_selection_selectorAll(selector);\n      for (var j = -1, m = this.length; ++j < m; ) {\n        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n          if ((node = group[i])) {\n            subnodes = selector.call(node.node, node.node.__data__, i);\n            subgroups.push((subgroup = []));\n            for (var k = -1, o = subnodes.length; ++k < o; ) {\n              subgroup.push({\n                node: subnodes[k],\n                delay: node.delay,\n                duration: node.duration,\n              });\n            }\n          }\n        }\n      }\n      return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n    };\n    d3_transitionPrototype.filter = function (filter) {\n      var subgroups = [],\n        subgroup,\n        group,\n        node;\n      if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n      for (var j = 0, m = this.length; j < m; j++) {\n        subgroups.push((subgroup = []));\n        for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n          if (\n            (node = group[i]) &&\n            filter.call(node.node, node.node.__data__, i)\n          ) {\n            subgroup.push(node);\n          }\n        }\n      }\n      return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n    };\n    d3_transitionPrototype.attr = function (name, value) {\n      if (arguments.length < 2) {\n        for (value in name)\n          this.attrTween(value, d3_tweenByName(name[value], value));\n        return this;\n      }\n      return this.attrTween(name, d3_tweenByName(value, name));\n    };\n    d3_transitionPrototype.attrTween = function (nameNS, tween) {\n      function attrTween(d, i) {\n        var f = tween.call(this, d, i, this.getAttribute(name));\n        return f === d3_tweenRemove\n          ? (this.removeAttribute(name), null)\n          : f &&\n              function (t) {\n                this.setAttribute(name, f(t));\n              };\n      }\n      function attrTweenNS(d, i) {\n        var f = tween.call(\n          this,\n          d,\n          i,\n          this.getAttributeNS(name.space, name.local)\n        );\n        return f === d3_tweenRemove\n          ? (this.removeAttributeNS(name.space, name.local), null)\n          : f &&\n              function (t) {\n                this.setAttributeNS(name.space, name.local, f(t));\n              };\n      }\n      var name = d3.ns.qualify(nameNS);\n      return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n    };\n    d3_transitionPrototype.style = function (name, value, priority) {\n      var n = arguments.length;\n      if (n < 3) {\n        if (typeof name !== \"string\") {\n          if (n < 2) value = \"\";\n          for (priority in name)\n            this.styleTween(\n              priority,\n              d3_tweenByName(name[priority], priority),\n              value\n            );\n          return this;\n        }\n        priority = \"\";\n      }\n      return this.styleTween(name, d3_tweenByName(value, name), priority);\n    };\n    d3_transitionPrototype.styleTween = function (name, tween, priority) {\n      if (arguments.length < 3) priority = \"\";\n      return this.tween(\"style.\" + name, function (d, i) {\n        var f = tween.call(\n          this,\n          d,\n          i,\n          window.getComputedStyle(this, null).getPropertyValue(name)\n        );\n        return f === d3_tweenRemove\n          ? (this.style.removeProperty(name), null)\n          : f &&\n              function (t) {\n                this.style.setProperty(name, f(t), priority);\n              };\n      });\n    };\n    d3_transitionPrototype.text = function (value) {\n      return this.tween(\"text\", function (d, i) {\n        this.textContent =\n          typeof value === \"function\" ? value.call(this, d, i) : value;\n      });\n    };\n    d3_transitionPrototype.remove = function () {\n      return this.each(\"end.transition\", function () {\n        var p;\n        if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);\n      });\n    };\n    d3_transitionPrototype.delay = function (value) {\n      return d3_selection_each(\n        this,\n        typeof value === \"function\"\n          ? function (node, i, j) {\n              node.delay =\n                value.call((node = node.node), node.__data__, i, j) | 0;\n            }\n          : ((value = value | 0),\n            function (node) {\n              node.delay = value;\n            })\n      );\n    };\n    d3_transitionPrototype.duration = function (value) {\n      return d3_selection_each(\n        this,\n        typeof value === \"function\"\n          ? function (node, i, j) {\n              node.duration = Math.max(\n                1,\n                value.call((node = node.node), node.__data__, i, j) | 0\n              );\n            }\n          : ((value = Math.max(1, value | 0)),\n            function (node) {\n              node.duration = value;\n            })\n      );\n    };\n    d3_transitionPrototype.transition = function () {\n      return this.select(d3_this);\n    };\n    d3.tween = function (b, interpolate) {\n      function tweenFunction(d, i, a) {\n        var v = b.call(this, d, i);\n        return v == null\n          ? a != \"\" && d3_tweenRemove\n          : a != v && interpolate(a, v + \"\");\n      }\n      function tweenString(d, i, a) {\n        return a != b && interpolate(a, b);\n      }\n      return typeof b === \"function\"\n        ? tweenFunction\n        : b == null\n        ? d3_tweenNull\n        : ((b += \"\"), tweenString);\n    };\n    var d3_tweenRemove = {};\n    var d3_timer_id = 0,\n      d3_timer_byId = {},\n      d3_timer_queue = null,\n      d3_timer_interval,\n      d3_timer_timeout;\n    d3.timer = function (callback, delay, then) {\n      if (arguments.length < 3) {\n        if (arguments.length < 2) delay = 0;\n        else if (!isFinite(delay)) return;\n        then = Date.now();\n      }\n      var timer = d3_timer_byId[callback.id];\n      if (timer && timer.callback === callback) {\n        timer.then = then;\n        timer.delay = delay;\n      } else\n        d3_timer_byId[(callback.id = ++d3_timer_id)] = d3_timer_queue = {\n          callback: callback,\n          then: then,\n          delay: delay,\n          next: d3_timer_queue,\n        };\n      if (!d3_timer_interval) {\n        d3_timer_timeout = clearTimeout(d3_timer_timeout);\n        d3_timer_interval = 1;\n        d3_timer_frame(d3_timer_step);\n      }\n    };\n    d3.timer.flush = function () {\n      var elapsed,\n        now = Date.now(),\n        t1 = d3_timer_queue;\n      while (t1) {\n        elapsed = now - t1.then;\n        if (!t1.delay) t1.flush = t1.callback(elapsed);\n        t1 = t1.next;\n      }\n      d3_timer_flush();\n    };\n    var d3_timer_frame =\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function (callback) {\n        setTimeout(callback, 17);\n      };\n    d3.mouse = function (container) {\n      return d3_mousePoint(container, d3_eventSource());\n    };\n    var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;\n    d3.touches = function (container, touches) {\n      if (arguments.length < 2) touches = d3_eventSource().touches;\n      return touches\n        ? d3_array(touches).map(function (touch) {\n            var point = d3_mousePoint(container, touch);\n            point.identifier = touch.identifier;\n            return point;\n          })\n        : [];\n    };\n    d3.scale = {};\n    d3.scale.linear = function () {\n      return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);\n    };\n    d3.scale.log = function () {\n      return d3_scale_log(d3.scale.linear(), d3_scale_logp);\n    };\n    var d3_scale_logFormat = d3.format(\".0e\");\n    d3_scale_logp.pow = function (x) {\n      return Math.pow(10, x);\n    };\n    d3_scale_logn.pow = function (x) {\n      return -Math.pow(10, -x);\n    };\n    d3.scale.pow = function () {\n      return d3_scale_pow(d3.scale.linear(), 1);\n    };\n    d3.scale.sqrt = function () {\n      return d3.scale.pow().exponent(0.5);\n    };\n    d3.scale.ordinal = function () {\n      return d3_scale_ordinal([], {\n        t: \"range\",\n        a: [[]],\n      });\n    };\n    d3.scale.category10 = function () {\n      return d3.scale.ordinal().range(d3_category10);\n    };\n    d3.scale.category20 = function () {\n      return d3.scale.ordinal().range(d3_category20);\n    };\n    d3.scale.category20b = function () {\n      return d3.scale.ordinal().range(d3_category20b);\n    };\n    d3.scale.category20c = function () {\n      return d3.scale.ordinal().range(d3_category20c);\n    };\n    var d3_category10 = [\n      \"#1f77b4\",\n      \"#ff7f0e\",\n      \"#2ca02c\",\n      \"#d62728\",\n      \"#9467bd\",\n      \"#8c564b\",\n      \"#e377c2\",\n      \"#7f7f7f\",\n      \"#bcbd22\",\n      \"#17becf\",\n    ];\n    var d3_category20 = [\n      \"#1f77b4\",\n      \"#aec7e8\",\n      \"#ff7f0e\",\n      \"#ffbb78\",\n      \"#2ca02c\",\n      \"#98df8a\",\n      \"#d62728\",\n      \"#ff9896\",\n      \"#9467bd\",\n      \"#c5b0d5\",\n      \"#8c564b\",\n      \"#c49c94\",\n      \"#e377c2\",\n      \"#f7b6d2\",\n      \"#7f7f7f\",\n      \"#c7c7c7\",\n      \"#bcbd22\",\n      \"#dbdb8d\",\n      \"#17becf\",\n      \"#9edae5\",\n    ];\n    var d3_category20b = [\n      \"#393b79\",\n      \"#5254a3\",\n      \"#6b6ecf\",\n      \"#9c9ede\",\n      \"#637939\",\n      \"#8ca252\",\n      \"#b5cf6b\",\n      \"#cedb9c\",\n      \"#8c6d31\",\n      \"#bd9e39\",\n      \"#e7ba52\",\n      \"#e7cb94\",\n      \"#843c39\",\n      \"#ad494a\",\n      \"#d6616b\",\n      \"#e7969c\",\n      \"#7b4173\",\n      \"#a55194\",\n      \"#ce6dbd\",\n      \"#de9ed6\",\n    ];\n    var d3_category20c = [\n      \"#3182bd\",\n      \"#6baed6\",\n      \"#9ecae1\",\n      \"#c6dbef\",\n      \"#e6550d\",\n      \"#fd8d3c\",\n      \"#fdae6b\",\n      \"#fdd0a2\",\n      \"#31a354\",\n      \"#74c476\",\n      \"#a1d99b\",\n      \"#c7e9c0\",\n      \"#756bb1\",\n      \"#9e9ac8\",\n      \"#bcbddc\",\n      \"#dadaeb\",\n      \"#636363\",\n      \"#969696\",\n      \"#bdbdbd\",\n      \"#d9d9d9\",\n    ];\n    d3.scale.quantile = function () {\n      return d3_scale_quantile([], []);\n    };\n    d3.scale.quantize = function () {\n      return d3_scale_quantize(0, 1, [0, 1]);\n    };\n    d3.scale.threshold = function () {\n      return d3_scale_threshold([0.5], [0, 1]);\n    };\n    d3.scale.identity = function () {\n      return d3_scale_identity([0, 1]);\n    };\n    d3.svg = {};\n    d3.svg.arc = function () {\n      function arc() {\n        var r0 = innerRadius.apply(this, arguments),\n          r1 = outerRadius.apply(this, arguments),\n          a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,\n          a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,\n          da = (a1 < a0 && ((da = a0), (a0 = a1), (a1 = da)), a1 - a0),\n          df = da < Math.PI ? \"0\" : \"1\",\n          c0 = Math.cos(a0),\n          s0 = Math.sin(a0),\n          c1 = Math.cos(a1),\n          s1 = Math.sin(a1);\n        return da >= d3_svg_arcMax\n          ? r0\n            ? \"M0,\" +\n              r1 +\n              \"A\" +\n              r1 +\n              \",\" +\n              r1 +\n              \" 0 1,1 0,\" +\n              -r1 +\n              \"A\" +\n              r1 +\n              \",\" +\n              r1 +\n              \" 0 1,1 0,\" +\n              r1 +\n              \"M0,\" +\n              r0 +\n              \"A\" +\n              r0 +\n              \",\" +\n              r0 +\n              \" 0 1,0 0,\" +\n              -r0 +\n              \"A\" +\n              r0 +\n              \",\" +\n              r0 +\n              \" 0 1,0 0,\" +\n              r0 +\n              \"Z\"\n            : \"M0,\" +\n              r1 +\n              \"A\" +\n              r1 +\n              \",\" +\n              r1 +\n              \" 0 1,1 0,\" +\n              -r1 +\n              \"A\" +\n              r1 +\n              \",\" +\n              r1 +\n              \" 0 1,1 0,\" +\n              r1 +\n              \"Z\"\n          : r0\n          ? \"M\" +\n            r1 * c0 +\n            \",\" +\n            r1 * s0 +\n            \"A\" +\n            r1 +\n            \",\" +\n            r1 +\n            \" 0 \" +\n            df +\n            \",1 \" +\n            r1 * c1 +\n            \",\" +\n            r1 * s1 +\n            \"L\" +\n            r0 * c1 +\n            \",\" +\n            r0 * s1 +\n            \"A\" +\n            r0 +\n            \",\" +\n            r0 +\n            \" 0 \" +\n            df +\n            \",0 \" +\n            r0 * c0 +\n            \",\" +\n            r0 * s0 +\n            \"Z\"\n          : \"M\" +\n            r1 * c0 +\n            \",\" +\n            r1 * s0 +\n            \"A\" +\n            r1 +\n            \",\" +\n            r1 +\n            \" 0 \" +\n            df +\n            \",1 \" +\n            r1 * c1 +\n            \",\" +\n            r1 * s1 +\n            \"L0,0\" +\n            \"Z\";\n      }\n      var innerRadius = d3_svg_arcInnerRadius,\n        outerRadius = d3_svg_arcOuterRadius,\n        startAngle = d3_svg_arcStartAngle,\n        endAngle = d3_svg_arcEndAngle;\n      arc.innerRadius = function (v) {\n        if (!arguments.length) return innerRadius;\n        innerRadius = d3_functor(v);\n        return arc;\n      };\n      arc.outerRadius = function (v) {\n        if (!arguments.length) return outerRadius;\n        outerRadius = d3_functor(v);\n        return arc;\n      };\n      arc.startAngle = function (v) {\n        if (!arguments.length) return startAngle;\n        startAngle = d3_functor(v);\n        return arc;\n      };\n      arc.endAngle = function (v) {\n        if (!arguments.length) return endAngle;\n        endAngle = d3_functor(v);\n        return arc;\n      };\n      arc.centroid = function () {\n        var r =\n            (innerRadius.apply(this, arguments) +\n              outerRadius.apply(this, arguments)) /\n            2,\n          a =\n            (startAngle.apply(this, arguments) +\n              endAngle.apply(this, arguments)) /\n              2 +\n            d3_svg_arcOffset;\n        return [Math.cos(a) * r, Math.sin(a) * r];\n      };\n      return arc;\n    };\n    var d3_svg_arcOffset = -Math.PI / 2,\n      d3_svg_arcMax = 2 * Math.PI - 1e-6;\n    d3.svg.line = function () {\n      return d3_svg_line(d3_identity);\n    };\n    var d3_svg_lineInterpolators = d3.map({\n      linear: d3_svg_lineLinear,\n      \"linear-closed\": d3_svg_lineLinearClosed,\n      \"step-before\": d3_svg_lineStepBefore,\n      \"step-after\": d3_svg_lineStepAfter,\n      basis: d3_svg_lineBasis,\n      \"basis-open\": d3_svg_lineBasisOpen,\n      \"basis-closed\": d3_svg_lineBasisClosed,\n      bundle: d3_svg_lineBundle,\n      cardinal: d3_svg_lineCardinal,\n      \"cardinal-open\": d3_svg_lineCardinalOpen,\n      \"cardinal-closed\": d3_svg_lineCardinalClosed,\n      monotone: d3_svg_lineMonotone,\n    });\n    d3_svg_lineInterpolators.forEach(function (key, value) {\n      value.key = key;\n      value.closed = /-closed$/.test(key);\n    });\n    var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],\n      d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],\n      d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];\n    d3.svg.line.radial = function () {\n      var line = d3_svg_line(d3_svg_lineRadial);\n      (line.radius = line.x), delete line.x;\n      (line.angle = line.y), delete line.y;\n      return line;\n    };\n    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n    d3.svg.area = function () {\n      return d3_svg_area(d3_identity);\n    };\n    d3.svg.area.radial = function () {\n      var area = d3_svg_area(d3_svg_lineRadial);\n      (area.radius = area.x), delete area.x;\n      (area.innerRadius = area.x0), delete area.x0;\n      (area.outerRadius = area.x1), delete area.x1;\n      (area.angle = area.y), delete area.y;\n      (area.startAngle = area.y0), delete area.y0;\n      (area.endAngle = area.y1), delete area.y1;\n      return area;\n    };\n    d3.svg.chord = function () {\n      function chord(d, i) {\n        var s = subgroup(this, source, d, i),\n          t = subgroup(this, target, d, i);\n        return (\n          \"M\" +\n          s.p0 +\n          arc(s.r, s.p1, s.a1 - s.a0) +\n          (equals(s, t)\n            ? curve(s.r, s.p1, s.r, s.p0)\n            : curve(s.r, s.p1, t.r, t.p0) +\n              arc(t.r, t.p1, t.a1 - t.a0) +\n              curve(t.r, t.p1, s.r, s.p0)) +\n          \"Z\"\n        );\n      }\n      function subgroup(self, f, d, i) {\n        var subgroup = f.call(self, d, i),\n          r = radius.call(self, subgroup, i),\n          a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,\n          a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\n        return {\n          r: r,\n          a0: a0,\n          a1: a1,\n          p0: [r * Math.cos(a0), r * Math.sin(a0)],\n          p1: [r * Math.cos(a1), r * Math.sin(a1)],\n        };\n      }\n      function equals(a, b) {\n        return a.a0 == b.a0 && a.a1 == b.a1;\n      }\n      function arc(r, p, a) {\n        return \"A\" + r + \",\" + r + \" 0 \" + +(a > Math.PI) + \",1 \" + p;\n      }\n      function curve(r0, p0, r1, p1) {\n        return \"Q 0,0 \" + p1;\n      }\n      var source = d3_svg_chordSource,\n        target = d3_svg_chordTarget,\n        radius = d3_svg_chordRadius,\n        startAngle = d3_svg_arcStartAngle,\n        endAngle = d3_svg_arcEndAngle;\n      chord.radius = function (v) {\n        if (!arguments.length) return radius;\n        radius = d3_functor(v);\n        return chord;\n      };\n      chord.source = function (v) {\n        if (!arguments.length) return source;\n        source = d3_functor(v);\n        return chord;\n      };\n      chord.target = function (v) {\n        if (!arguments.length) return target;\n        target = d3_functor(v);\n        return chord;\n      };\n      chord.startAngle = function (v) {\n        if (!arguments.length) return startAngle;\n        startAngle = d3_functor(v);\n        return chord;\n      };\n      chord.endAngle = function (v) {\n        if (!arguments.length) return endAngle;\n        endAngle = d3_functor(v);\n        return chord;\n      };\n      return chord;\n    };\n    d3.svg.diagonal = function () {\n      function diagonal(d, i) {\n        var p0 = source.call(this, d, i),\n          p3 = target.call(this, d, i),\n          m = (p0.y + p3.y) / 2,\n          p = [\n            p0,\n            {\n              x: p0.x,\n              y: m,\n            },\n            {\n              x: p3.x,\n              y: m,\n            },\n            p3,\n          ];\n        p = p.map(projection);\n        return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n      }\n      var source = d3_svg_chordSource,\n        target = d3_svg_chordTarget,\n        projection = d3_svg_diagonalProjection;\n      diagonal.source = function (x) {\n        if (!arguments.length) return source;\n        source = d3_functor(x);\n        return diagonal;\n      };\n      diagonal.target = function (x) {\n        if (!arguments.length) return target;\n        target = d3_functor(x);\n        return diagonal;\n      };\n      diagonal.projection = function (x) {\n        if (!arguments.length) return projection;\n        projection = x;\n        return diagonal;\n      };\n      return diagonal;\n    };\n    d3.svg.diagonal.radial = function () {\n      var diagonal = d3.svg.diagonal(),\n        projection = d3_svg_diagonalProjection,\n        projection_ = diagonal.projection;\n      diagonal.projection = function (x) {\n        return arguments.length\n          ? projection_(d3_svg_diagonalRadialProjection((projection = x)))\n          : projection;\n      };\n      return diagonal;\n    };\n    d3.svg.mouse = d3.mouse;\n    d3.svg.touches = d3.touches;\n    d3.svg.symbol = function () {\n      function symbol(d, i) {\n        return (\n          d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle\n        )(size.call(this, d, i));\n      }\n      var type = d3_svg_symbolType,\n        size = d3_svg_symbolSize;\n      symbol.type = function (x) {\n        if (!arguments.length) return type;\n        type = d3_functor(x);\n        return symbol;\n      };\n      symbol.size = function (x) {\n        if (!arguments.length) return size;\n        size = d3_functor(x);\n        return symbol;\n      };\n      return symbol;\n    };\n    var d3_svg_symbols = d3.map({\n      circle: d3_svg_symbolCircle,\n      cross: function (size) {\n        var r = Math.sqrt(size / 5) / 2;\n        return (\n          \"M\" +\n          -3 * r +\n          \",\" +\n          -r +\n          \"H\" +\n          -r +\n          \"V\" +\n          -3 * r +\n          \"H\" +\n          r +\n          \"V\" +\n          -r +\n          \"H\" +\n          3 * r +\n          \"V\" +\n          r +\n          \"H\" +\n          r +\n          \"V\" +\n          3 * r +\n          \"H\" +\n          -r +\n          \"V\" +\n          r +\n          \"H\" +\n          -3 * r +\n          \"Z\"\n        );\n      },\n      diamond: function (size) {\n        var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n          rx = ry * d3_svg_symbolTan30;\n        return (\n          \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\"\n        );\n      },\n      square: function (size) {\n        var r = Math.sqrt(size) / 2;\n        return (\n          \"M\" +\n          -r +\n          \",\" +\n          -r +\n          \"L\" +\n          r +\n          \",\" +\n          -r +\n          \" \" +\n          r +\n          \",\" +\n          r +\n          \" \" +\n          -r +\n          \",\" +\n          r +\n          \"Z\"\n        );\n      },\n      \"triangle-down\": function (size) {\n        var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n          ry = (rx * d3_svg_symbolSqrt3) / 2;\n        return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n      },\n      \"triangle-up\": function (size) {\n        var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n          ry = (rx * d3_svg_symbolSqrt3) / 2;\n        return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n      },\n    });\n    d3.svg.symbolTypes = d3_svg_symbols.keys();\n    var d3_svg_symbolSqrt3 = Math.sqrt(3),\n      d3_svg_symbolTan30 = Math.tan((30 * Math.PI) / 180);\n    d3.svg.axis = function () {\n      function axis(g) {\n        g.each(function () {\n          var g = d3.select(this);\n          var ticks =\n              tickValues == null\n                ? scale.ticks\n                  ? scale.ticks.apply(scale, tickArguments_)\n                  : scale.domain()\n                : tickValues,\n            tickFormat =\n              tickFormat_ == null\n                ? scale.tickFormat\n                  ? scale.tickFormat.apply(scale, tickArguments_)\n                  : String\n                : tickFormat_;\n          var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),\n            subtick = g.selectAll(\".minor\").data(subticks, String),\n            subtickEnter = subtick\n              .enter()\n              .insert(\"line\", \"g\")\n              .attr(\"class\", \"tick minor\")\n              .style(\"opacity\", 1e-6),\n            subtickExit = d3\n              .transition(subtick.exit())\n              .style(\"opacity\", 1e-6)\n              .remove(),\n            subtickUpdate = d3.transition(subtick).style(\"opacity\", 1);\n          var tick = g.selectAll(\"g\").data(ticks, String),\n            tickEnter = tick.enter().insert(\"g\", \"path\").style(\"opacity\", 1e-6),\n            tickExit = d3\n              .transition(tick.exit())\n              .style(\"opacity\", 1e-6)\n              .remove(),\n            tickUpdate = d3.transition(tick).style(\"opacity\", 1),\n            tickTransform;\n          var range = d3_scaleRange(scale),\n            path = g.selectAll(\".domain\").data([0]),\n            pathEnter = path.enter().append(\"path\").attr(\"class\", \"domain\"),\n            pathUpdate = d3.transition(path);\n          var scale1 = scale.copy(),\n            scale0 = this.__chart__ || scale1;\n          this.__chart__ = scale1;\n          tickEnter.append(\"line\").attr(\"class\", \"tick\");\n          tickEnter.append(\"text\");\n          var lineEnter = tickEnter.select(\"line\"),\n            lineUpdate = tickUpdate.select(\"line\"),\n            text = tick.select(\"text\").text(tickFormat),\n            textEnter = tickEnter.select(\"text\"),\n            textUpdate = tickUpdate.select(\"text\");\n          switch (orient) {\n            case \"bottom\": {\n              tickTransform = d3_svg_axisX;\n              subtickEnter.attr(\"y2\", tickMinorSize);\n              subtickUpdate.attr(\"x2\", 0).attr(\"y2\", tickMinorSize);\n              lineEnter.attr(\"y2\", tickMajorSize);\n              textEnter.attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\n              lineUpdate.attr(\"x2\", 0).attr(\"y2\", tickMajorSize);\n              textUpdate\n                .attr(\"x\", 0)\n                .attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\n              text.attr(\"dy\", \".71em\").attr(\"text-anchor\", \"middle\");\n              pathUpdate.attr(\n                \"d\",\n                \"M\" +\n                  range[0] +\n                  \",\" +\n                  tickEndSize +\n                  \"V0H\" +\n                  range[1] +\n                  \"V\" +\n                  tickEndSize\n              );\n              break;\n            }\n            case \"top\": {\n              tickTransform = d3_svg_axisX;\n              subtickEnter.attr(\"y2\", -tickMinorSize);\n              subtickUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMinorSize);\n              lineEnter.attr(\"y2\", -tickMajorSize);\n              textEnter.attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\n              lineUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMajorSize);\n              textUpdate\n                .attr(\"x\", 0)\n                .attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\n              text.attr(\"dy\", \"0em\").attr(\"text-anchor\", \"middle\");\n              pathUpdate.attr(\n                \"d\",\n                \"M\" +\n                  range[0] +\n                  \",\" +\n                  -tickEndSize +\n                  \"V0H\" +\n                  range[1] +\n                  \"V\" +\n                  -tickEndSize\n              );\n              break;\n            }\n            case \"left\": {\n              tickTransform = d3_svg_axisY;\n              subtickEnter.attr(\"x2\", -tickMinorSize);\n              subtickUpdate.attr(\"x2\", -tickMinorSize).attr(\"y2\", 0);\n              lineEnter.attr(\"x2\", -tickMajorSize);\n              textEnter.attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding));\n              lineUpdate.attr(\"x2\", -tickMajorSize).attr(\"y2\", 0);\n              textUpdate\n                .attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding))\n                .attr(\"y\", 0);\n              text.attr(\"dy\", \".32em\").attr(\"text-anchor\", \"end\");\n              pathUpdate.attr(\n                \"d\",\n                \"M\" +\n                  -tickEndSize +\n                  \",\" +\n                  range[0] +\n                  \"H0V\" +\n                  range[1] +\n                  \"H\" +\n                  -tickEndSize\n              );\n              break;\n            }\n            case \"right\": {\n              tickTransform = d3_svg_axisY;\n              subtickEnter.attr(\"x2\", tickMinorSize);\n              subtickUpdate.attr(\"x2\", tickMinorSize).attr(\"y2\", 0);\n              lineEnter.attr(\"x2\", tickMajorSize);\n              textEnter.attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding);\n              lineUpdate.attr(\"x2\", tickMajorSize).attr(\"y2\", 0);\n              textUpdate\n                .attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding)\n                .attr(\"y\", 0);\n              text.attr(\"dy\", \".32em\").attr(\"text-anchor\", \"start\");\n              pathUpdate.attr(\n                \"d\",\n                \"M\" +\n                  tickEndSize +\n                  \",\" +\n                  range[0] +\n                  \"H0V\" +\n                  range[1] +\n                  \"H\" +\n                  tickEndSize\n              );\n              break;\n            }\n          }\n          if (scale.ticks) {\n            tickEnter.call(tickTransform, scale0);\n            tickUpdate.call(tickTransform, scale1);\n            tickExit.call(tickTransform, scale1);\n            subtickEnter.call(tickTransform, scale0);\n            subtickUpdate.call(tickTransform, scale1);\n            subtickExit.call(tickTransform, scale1);\n          } else {\n            var dx = scale1.rangeBand() / 2,\n              x = function (d) {\n                return scale1(d) + dx;\n              };\n            tickEnter.call(tickTransform, x);\n            tickUpdate.call(tickTransform, x);\n          }\n        });\n      }\n      var scale = d3.scale.linear(),\n        orient = \"bottom\",\n        tickMajorSize = 6,\n        tickMinorSize = 6,\n        tickEndSize = 6,\n        tickPadding = 3,\n        tickArguments_ = [10],\n        tickValues = null,\n        tickFormat_,\n        tickSubdivide = 0;\n      axis.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = x;\n        return axis;\n      };\n      axis.orient = function (x) {\n        if (!arguments.length) return orient;\n        orient = x;\n        return axis;\n      };\n      axis.ticks = function () {\n        if (!arguments.length) return tickArguments_;\n        tickArguments_ = arguments;\n        return axis;\n      };\n      axis.tickValues = function (x) {\n        if (!arguments.length) return tickValues;\n        tickValues = x;\n        return axis;\n      };\n      axis.tickFormat = function (x) {\n        if (!arguments.length) return tickFormat_;\n        tickFormat_ = x;\n        return axis;\n      };\n      axis.tickSize = function (x, y, z) {\n        if (!arguments.length) return tickMajorSize;\n        var n = arguments.length - 1;\n        tickMajorSize = +x;\n        tickMinorSize = n > 1 ? +y : tickMajorSize;\n        tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;\n        return axis;\n      };\n      axis.tickPadding = function (x) {\n        if (!arguments.length) return tickPadding;\n        tickPadding = +x;\n        return axis;\n      };\n      axis.tickSubdivide = function (x) {\n        if (!arguments.length) return tickSubdivide;\n        tickSubdivide = +x;\n        return axis;\n      };\n      return axis;\n    };\n    d3.svg.brush = function () {\n      function brush(g) {\n        g.each(function () {\n          var g = d3.select(this),\n            bg = g.selectAll(\".background\").data([0]),\n            fg = g.selectAll(\".extent\").data([0]),\n            tz = g.selectAll(\".resize\").data(resizes, String),\n            e;\n          g.style(\"pointer-events\", \"all\")\n            .on(\"mousedown.brush\", brushstart)\n            .on(\"touchstart.brush\", brushstart);\n          bg.enter()\n            .append(\"rect\")\n            .attr(\"class\", \"background\")\n            .style(\"visibility\", \"hidden\")\n            .style(\"cursor\", \"crosshair\");\n          fg.enter()\n            .append(\"rect\")\n            .attr(\"class\", \"extent\")\n            .style(\"cursor\", \"move\");\n          tz.enter()\n            .append(\"g\")\n            .attr(\"class\", function (d) {\n              return \"resize \" + d;\n            })\n            .style(\"cursor\", function (d) {\n              return d3_svg_brushCursor[d];\n            })\n            .append(\"rect\")\n            .attr(\"x\", function (d) {\n              return /[ew]$/.test(d) ? -3 : null;\n            })\n            .attr(\"y\", function (d) {\n              return /^[ns]/.test(d) ? -3 : null;\n            })\n            .attr(\"width\", 6)\n            .attr(\"height\", 6)\n            .style(\"visibility\", \"hidden\");\n          tz.style(\"display\", brush.empty() ? \"none\" : null);\n          tz.exit().remove();\n          if (x) {\n            e = d3_scaleRange(x);\n            bg.attr(\"x\", e[0]).attr(\"width\", e[1] - e[0]);\n            redrawX(g);\n          }\n          if (y) {\n            e = d3_scaleRange(y);\n            bg.attr(\"y\", e[0]).attr(\"height\", e[1] - e[0]);\n            redrawY(g);\n          }\n          redraw(g);\n        });\n      }\n      function redraw(g) {\n        g.selectAll(\".resize\").attr(\"transform\", function (d) {\n          return (\n            \"translate(\" +\n            extent[+/e$/.test(d)][0] +\n            \",\" +\n            extent[+/^s/.test(d)][1] +\n            \")\"\n          );\n        });\n      }\n      function redrawX(g) {\n        g.select(\".extent\").attr(\"x\", extent[0][0]);\n        g.selectAll(\".extent,.n>rect,.s>rect\").attr(\n          \"width\",\n          extent[1][0] - extent[0][0]\n        );\n      }\n      function redrawY(g) {\n        g.select(\".extent\").attr(\"y\", extent[0][1]);\n        g.selectAll(\".extent,.e>rect,.w>rect\").attr(\n          \"height\",\n          extent[1][1] - extent[0][1]\n        );\n      }\n      function brushstart() {\n        function mouse() {\n          var touches = d3.event.changedTouches;\n          return touches ? d3.touches(target, touches)[0] : d3.mouse(target);\n        }\n        function keydown() {\n          if (d3.event.keyCode == 32) {\n            if (!dragging) {\n              center = null;\n              origin[0] -= extent[1][0];\n              origin[1] -= extent[1][1];\n              dragging = 2;\n            }\n            d3_eventCancel();\n          }\n        }\n        function keyup() {\n          if (d3.event.keyCode == 32 && dragging == 2) {\n            origin[0] += extent[1][0];\n            origin[1] += extent[1][1];\n            dragging = 0;\n            d3_eventCancel();\n          }\n        }\n        function brushmove() {\n          var point = mouse(),\n            moved = false;\n          if (offset) {\n            point[0] += offset[0];\n            point[1] += offset[1];\n          }\n          if (!dragging) {\n            if (d3.event.altKey) {\n              if (!center)\n                center = [\n                  (extent[0][0] + extent[1][0]) / 2,\n                  (extent[0][1] + extent[1][1]) / 2,\n                ];\n              origin[0] = extent[+(point[0] < center[0])][0];\n              origin[1] = extent[+(point[1] < center[1])][1];\n            } else center = null;\n          }\n          if (resizingX && move1(point, x, 0)) {\n            redrawX(g);\n            moved = true;\n          }\n          if (resizingY && move1(point, y, 1)) {\n            redrawY(g);\n            moved = true;\n          }\n          if (moved) {\n            redraw(g);\n            event_({\n              type: \"brush\",\n              mode: dragging ? \"move\" : \"resize\",\n            });\n          }\n        }\n        function move1(point, scale, i) {\n          var range = d3_scaleRange(scale),\n            r0 = range[0],\n            r1 = range[1],\n            position = origin[i],\n            size = extent[1][i] - extent[0][i],\n            min,\n            max;\n          if (dragging) {\n            r0 -= position;\n            r1 -= size + position;\n          }\n          min = Math.max(r0, Math.min(r1, point[i]));\n          if (dragging) {\n            max = (min += position) + size;\n          } else {\n            if (center)\n              position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n            if (position < min) {\n              max = min;\n              min = position;\n            } else {\n              max = position;\n            }\n          }\n          if (extent[0][i] !== min || extent[1][i] !== max) {\n            extentDomain = null;\n            extent[0][i] = min;\n            extent[1][i] = max;\n            return true;\n          }\n        }\n        function brushend() {\n          brushmove();\n          g.style(\"pointer-events\", \"all\")\n            .selectAll(\".resize\")\n            .style(\"display\", brush.empty() ? \"none\" : null);\n          d3.select(\"body\").style(\"cursor\", null);\n          w.on(\"mousemove.brush\", null)\n            .on(\"mouseup.brush\", null)\n            .on(\"touchmove.brush\", null)\n            .on(\"touchend.brush\", null)\n            .on(\"keydown.brush\", null)\n            .on(\"keyup.brush\", null);\n          event_({\n            type: \"brushend\",\n          });\n          d3_eventCancel();\n        }\n        var target = this,\n          eventTarget = d3.select(d3.event.target),\n          event_ = event.of(target, arguments),\n          g = d3.select(target),\n          resizing = eventTarget.datum(),\n          resizingX = !/^(n|s)$/.test(resizing) && x,\n          resizingY = !/^(e|w)$/.test(resizing) && y,\n          dragging = eventTarget.classed(\"extent\"),\n          center,\n          origin = mouse(),\n          offset;\n        var w = d3\n          .select(window)\n          .on(\"mousemove.brush\", brushmove)\n          .on(\"mouseup.brush\", brushend)\n          .on(\"touchmove.brush\", brushmove)\n          .on(\"touchend.brush\", brushend)\n          .on(\"keydown.brush\", keydown)\n          .on(\"keyup.brush\", keyup);\n        if (dragging) {\n          origin[0] = extent[0][0] - origin[0];\n          origin[1] = extent[0][1] - origin[1];\n        } else if (resizing) {\n          var ex = +/w$/.test(resizing),\n            ey = +/^n/.test(resizing);\n          offset = [\n            extent[1 - ex][0] - origin[0],\n            extent[1 - ey][1] - origin[1],\n          ];\n          origin[0] = extent[ex][0];\n          origin[1] = extent[ey][1];\n        } else if (d3.event.altKey) center = origin.slice();\n        g.style(\"pointer-events\", \"none\")\n          .selectAll(\".resize\")\n          .style(\"display\", null);\n        d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n        event_({\n          type: \"brushstart\",\n        });\n        brushmove();\n        d3_eventCancel();\n      }\n      var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"),\n        x = null,\n        y = null,\n        resizes = d3_svg_brushResizes[0],\n        extent = [\n          [0, 0],\n          [0, 0],\n        ],\n        extentDomain;\n      brush.x = function (z) {\n        if (!arguments.length) return x;\n        x = z;\n        resizes = d3_svg_brushResizes[(!x << 1) | !y];\n        return brush;\n      };\n      brush.y = function (z) {\n        if (!arguments.length) return y;\n        y = z;\n        resizes = d3_svg_brushResizes[(!x << 1) | !y];\n        return brush;\n      };\n      brush.extent = function (z) {\n        var x0, x1, y0, y1, t;\n        if (!arguments.length) {\n          z = extentDomain || extent;\n          if (x) {\n            (x0 = z[0][0]), (x1 = z[1][0]);\n            if (!extentDomain) {\n              (x0 = extent[0][0]), (x1 = extent[1][0]);\n              if (x.invert) (x0 = x.invert(x0)), (x1 = x.invert(x1));\n              if (x1 < x0) (t = x0), (x0 = x1), (x1 = t);\n            }\n          }\n          if (y) {\n            (y0 = z[0][1]), (y1 = z[1][1]);\n            if (!extentDomain) {\n              (y0 = extent[0][1]), (y1 = extent[1][1]);\n              if (y.invert) (y0 = y.invert(y0)), (y1 = y.invert(y1));\n              if (y1 < y0) (t = y0), (y0 = y1), (y1 = t);\n            }\n          }\n          return x && y\n            ? [\n                [x0, y0],\n                [x1, y1],\n              ]\n            : x\n            ? [x0, x1]\n            : y && [y0, y1];\n        }\n        extentDomain = [\n          [0, 0],\n          [0, 0],\n        ];\n        if (x) {\n          (x0 = z[0]), (x1 = z[1]);\n          if (y) (x0 = x0[0]), (x1 = x1[0]);\n          (extentDomain[0][0] = x0), (extentDomain[1][0] = x1);\n          if (x.invert) (x0 = x(x0)), (x1 = x(x1));\n          if (x1 < x0) (t = x0), (x0 = x1), (x1 = t);\n          (extent[0][0] = x0 | 0), (extent[1][0] = x1 | 0);\n        }\n        if (y) {\n          (y0 = z[0]), (y1 = z[1]);\n          if (x) (y0 = y0[1]), (y1 = y1[1]);\n          (extentDomain[0][1] = y0), (extentDomain[1][1] = y1);\n          if (y.invert) (y0 = y(y0)), (y1 = y(y1));\n          if (y1 < y0) (t = y0), (y0 = y1), (y1 = t);\n          (extent[0][1] = y0 | 0), (extent[1][1] = y1 | 0);\n        }\n        return brush;\n      };\n      brush.clear = function () {\n        extentDomain = null;\n        extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;\n        return brush;\n      };\n      brush.empty = function () {\n        return (\n          (x && extent[0][0] === extent[1][0]) ||\n          (y && extent[0][1] === extent[1][1])\n        );\n      };\n      return d3.rebind(brush, event, \"on\");\n    };\n    var d3_svg_brushCursor = {\n      n: \"ns-resize\",\n      e: \"ew-resize\",\n      s: \"ns-resize\",\n      w: \"ew-resize\",\n      nw: \"nwse-resize\",\n      ne: \"nesw-resize\",\n      se: \"nwse-resize\",\n      sw: \"nesw-resize\",\n    };\n    var d3_svg_brushResizes = [\n      [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"],\n      [\"e\", \"w\"],\n      [\"n\", \"s\"],\n      [],\n    ];\n    d3.behavior = {};\n    d3.behavior.drag = function () {\n      function drag() {\n        this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", mousedown);\n      }\n      function mousedown() {\n        function point() {\n          var p = target.parentNode;\n          return touchId\n            ? d3.touches(p).filter(function (p) {\n                return p.identifier === touchId;\n              })[0]\n            : d3.mouse(p);\n        }\n        function dragmove() {\n          if (!target.parentNode) return dragend();\n          var p = point(),\n            dx = p[0] - origin_[0],\n            dy = p[1] - origin_[1];\n          moved |= dx | dy;\n          origin_ = p;\n          d3_eventCancel();\n          event_({\n            type: \"drag\",\n            x: p[0] + offset[0],\n            y: p[1] + offset[1],\n            dx: dx,\n            dy: dy,\n          });\n        }\n        function dragend() {\n          event_({\n            type: \"dragend\",\n          });\n          if (moved) {\n            d3_eventCancel();\n            if (d3.event.target === eventTarget)\n              w.on(\"click.drag\", click, true);\n          }\n          w.on(\n            touchId ? \"touchmove.drag-\" + touchId : \"mousemove.drag\",\n            null\n          ).on(touchId ? \"touchend.drag-\" + touchId : \"mouseup.drag\", null);\n        }\n        function click() {\n          d3_eventCancel();\n          w.on(\"click.drag\", null);\n        }\n        var target = this,\n          event_ = event.of(target, arguments),\n          eventTarget = d3.event.target,\n          touchId = d3.event.touches && d3.event.changedTouches[0].identifier,\n          offset,\n          origin_ = point(),\n          moved = 0;\n        var w = d3\n          .select(window)\n          .on(\n            touchId ? \"touchmove.drag-\" + touchId : \"mousemove.drag\",\n            dragmove\n          )\n          .on(\n            touchId ? \"touchend.drag-\" + touchId : \"mouseup.drag\",\n            dragend,\n            true\n          );\n        if (origin) {\n          offset = origin.apply(target, arguments);\n          offset = [offset.x - origin_[0], offset.y - origin_[1]];\n        } else {\n          offset = [0, 0];\n        }\n        if (!touchId) d3_eventCancel();\n        event_({\n          type: \"dragstart\",\n        });\n      }\n      var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"),\n        origin = null;\n      drag.origin = function (x) {\n        if (!arguments.length) return origin;\n        origin = x;\n        return drag;\n      };\n      return d3.rebind(drag, event, \"on\");\n    };\n    d3.behavior.zoom = function () {\n      function zoom() {\n        this.on(\"mousedown.zoom\", mousedown)\n          .on(\"mousewheel.zoom\", mousewheel)\n          .on(\"mousemove.zoom\", mousemove)\n          .on(\"DOMMouseScroll.zoom\", mousewheel)\n          .on(\"dblclick.zoom\", dblclick)\n          .on(\"touchstart.zoom\", touchstart)\n          .on(\"touchmove.zoom\", touchmove)\n          .on(\"touchend.zoom\", touchstart);\n      }\n      function location(p) {\n        return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];\n      }\n      function point(l) {\n        return [l[0] * scale + translate[0], l[1] * scale + translate[1]];\n      }\n      function scaleTo(s) {\n        scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n      }\n      function translateTo(p, l) {\n        l = point(l);\n        translate[0] += p[0] - l[0];\n        translate[1] += p[1] - l[1];\n      }\n      function dispatch(event) {\n        if (x1)\n          x1.domain(\n            x0\n              .range()\n              .map(function (x) {\n                return (x - translate[0]) / scale;\n              })\n              .map(x0.invert)\n          );\n        if (y1)\n          y1.domain(\n            y0\n              .range()\n              .map(function (y) {\n                return (y - translate[1]) / scale;\n              })\n              .map(y0.invert)\n          );\n        d3.event.preventDefault();\n        event({\n          type: \"zoom\",\n          scale: scale,\n          translate: translate,\n        });\n      }\n      function mousedown() {\n        function mousemove() {\n          moved = 1;\n          translateTo(d3.mouse(target), l);\n          dispatch(event_);\n        }\n        function mouseup() {\n          if (moved) d3_eventCancel();\n          w.on(\"mousemove.zoom\", null).on(\"mouseup.zoom\", null);\n          if (moved && d3.event.target === eventTarget)\n            w.on(\"click.zoom\", click, true);\n        }\n        function click() {\n          d3_eventCancel();\n          w.on(\"click.zoom\", null);\n        }\n        var target = this,\n          event_ = event.of(target, arguments),\n          eventTarget = d3.event.target,\n          moved = 0,\n          w = d3\n            .select(window)\n            .on(\"mousemove.zoom\", mousemove)\n            .on(\"mouseup.zoom\", mouseup),\n          l = location(d3.mouse(target));\n        window.focus();\n        d3_eventCancel();\n      }\n      function mousewheel() {\n        if (!translate0) translate0 = location(d3.mouse(this));\n        scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 0.002) * scale);\n        translateTo(d3.mouse(this), translate0);\n        dispatch(event.of(this, arguments));\n      }\n      function mousemove() {\n        translate0 = null;\n      }\n      function dblclick() {\n        var p = d3.mouse(this),\n          l = location(p);\n        scaleTo(d3.event.shiftKey ? scale / 2 : scale * 2);\n        translateTo(p, l);\n        dispatch(event.of(this, arguments));\n      }\n      function touchstart() {\n        var touches = d3.touches(this),\n          now = Date.now();\n        scale0 = scale;\n        translate0 = {};\n        touches.forEach(function (t) {\n          translate0[t.identifier] = location(t);\n        });\n        d3_eventCancel();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0],\n              l = location(touches[0]);\n            scaleTo(scale * 2);\n            translateTo(p, l);\n            dispatch(event.of(this, arguments));\n          }\n          touchtime = now;\n        }\n      }\n      function touchmove() {\n        var touches = d3.touches(this),\n          p0 = touches[0],\n          l0 = translate0[p0.identifier];\n        if ((p1 = touches[1])) {\n          var p1,\n            l1 = translate0[p1.identifier];\n          p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n          l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n          scaleTo(d3.event.scale * scale0);\n        }\n        translateTo(p0, l0);\n        touchtime = null;\n        dispatch(event.of(this, arguments));\n      }\n      var translate = [0, 0],\n        translate0,\n        scale = 1,\n        scale0,\n        scaleExtent = d3_behavior_zoomInfinity,\n        event = d3_eventDispatch(zoom, \"zoom\"),\n        x0,\n        x1,\n        y0,\n        y1,\n        touchtime;\n      zoom.translate = function (x) {\n        if (!arguments.length) return translate;\n        translate = x.map(Number);\n        return zoom;\n      };\n      zoom.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = +x;\n        return zoom;\n      };\n      zoom.scaleExtent = function (x) {\n        if (!arguments.length) return scaleExtent;\n        scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);\n        return zoom;\n      };\n      zoom.x = function (z) {\n        if (!arguments.length) return x1;\n        x1 = z;\n        x0 = z.copy();\n        return zoom;\n      };\n      zoom.y = function (z) {\n        if (!arguments.length) return y1;\n        y1 = z;\n        y0 = z.copy();\n        return zoom;\n      };\n      return d3.rebind(zoom, event, \"on\");\n    };\n    var d3_behavior_zoomDiv,\n      d3_behavior_zoomInfinity = [0, Infinity];\n    d3.layout = {};\n    d3.layout.bundle = function () {\n      return function (links) {\n        var paths = [],\n          i = -1,\n          n = links.length;\n        while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n        return paths;\n      };\n    };\n    d3.layout.chord = function () {\n      function relayout() {\n        var subgroups = {},\n          groupSums = [],\n          groupIndex = d3.range(n),\n          subgroupIndex = [],\n          k,\n          x,\n          x0,\n          i,\n          j;\n        chords = [];\n        groups = [];\n        (k = 0), (i = -1);\n        while (++i < n) {\n          (x = 0), (j = -1);\n          while (++j < n) {\n            x += matrix[i][j];\n          }\n          groupSums.push(x);\n          subgroupIndex.push(d3.range(n));\n          k += x;\n        }\n        if (sortGroups) {\n          groupIndex.sort(function (a, b) {\n            return sortGroups(groupSums[a], groupSums[b]);\n          });\n        }\n        if (sortSubgroups) {\n          subgroupIndex.forEach(function (d, i) {\n            d.sort(function (a, b) {\n              return sortSubgroups(matrix[i][a], matrix[i][b]);\n            });\n          });\n        }\n        k = (2 * Math.PI - padding * n) / k;\n        (x = 0), (i = -1);\n        while (++i < n) {\n          (x0 = x), (j = -1);\n          while (++j < n) {\n            var di = groupIndex[i],\n              dj = subgroupIndex[di][j],\n              v = matrix[di][dj],\n              a0 = x,\n              a1 = (x += v * k);\n            subgroups[di + \"-\" + dj] = {\n              index: di,\n              subindex: dj,\n              startAngle: a0,\n              endAngle: a1,\n              value: v,\n            };\n          }\n          groups[di] = {\n            index: di,\n            startAngle: x0,\n            endAngle: x,\n            value: (x - x0) / k,\n          };\n          x += padding;\n        }\n        i = -1;\n        while (++i < n) {\n          j = i - 1;\n          while (++j < n) {\n            var source = subgroups[i + \"-\" + j],\n              target = subgroups[j + \"-\" + i];\n            if (source.value || target.value) {\n              chords.push(\n                source.value < target.value\n                  ? {\n                      source: target,\n                      target: source,\n                    }\n                  : {\n                      source: source,\n                      target: target,\n                    }\n              );\n            }\n          }\n        }\n        if (sortChords) resort();\n      }\n      function resort() {\n        chords.sort(function (a, b) {\n          return sortChords(\n            (a.source.value + a.target.value) / 2,\n            (b.source.value + b.target.value) / 2\n          );\n        });\n      }\n      var chord = {},\n        chords,\n        groups,\n        matrix,\n        n,\n        padding = 0,\n        sortGroups,\n        sortSubgroups,\n        sortChords;\n      chord.matrix = function (x) {\n        if (!arguments.length) return matrix;\n        n = (matrix = x) && matrix.length;\n        chords = groups = null;\n        return chord;\n      };\n      chord.padding = function (x) {\n        if (!arguments.length) return padding;\n        padding = x;\n        chords = groups = null;\n        return chord;\n      };\n      chord.sortGroups = function (x) {\n        if (!arguments.length) return sortGroups;\n        sortGroups = x;\n        chords = groups = null;\n        return chord;\n      };\n      chord.sortSubgroups = function (x) {\n        if (!arguments.length) return sortSubgroups;\n        sortSubgroups = x;\n        chords = null;\n        return chord;\n      };\n      chord.sortChords = function (x) {\n        if (!arguments.length) return sortChords;\n        sortChords = x;\n        if (chords) resort();\n        return chord;\n      };\n      chord.chords = function () {\n        if (!chords) relayout();\n        return chords;\n      };\n      chord.groups = function () {\n        if (!groups) relayout();\n        return groups;\n      };\n      return chord;\n    };\n    d3.layout.force = function () {\n      function repulse(node) {\n        return function (quad, x1, y1, x2, y2) {\n          if (quad.point !== node) {\n            var dx = quad.cx - node.x,\n              dy = quad.cy - node.y,\n              dn = 1 / Math.sqrt(dx * dx + dy * dy);\n            if ((x2 - x1) * dn < theta) {\n              var k = quad.charge * dn * dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n              return true;\n            }\n            if (quad.point && isFinite(dn)) {\n              var k = quad.pointCharge * dn * dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n          }\n          return !quad.charge;\n        };\n      }\n      function dragmove(d) {\n        d.px = d3.event.x;\n        d.py = d3.event.y;\n        force.resume();\n      }\n      var force = {},\n        event = d3.dispatch(\"start\", \"tick\", \"end\"),\n        size = [1, 1],\n        drag,\n        alpha,\n        friction = 0.9,\n        linkDistance = d3_layout_forceLinkDistance,\n        linkStrength = d3_layout_forceLinkStrength,\n        charge = -30,\n        gravity = 0.1,\n        theta = 0.8,\n        interval,\n        nodes = [],\n        links = [],\n        distances,\n        strengths,\n        charges;\n      force.tick = function () {\n        if ((alpha *= 0.99) < 0.005) {\n          event.end({\n            type: \"end\",\n            alpha: (alpha = 0),\n          });\n          return true;\n        }\n        var n = nodes.length,\n          m = links.length,\n          q,\n          i,\n          o,\n          s,\n          t,\n          l,\n          k,\n          x,\n          y;\n        for (i = 0; i < m; ++i) {\n          o = links[i];\n          s = o.source;\n          t = o.target;\n          x = t.x - s.x;\n          y = t.y - s.y;\n          if ((l = x * x + y * y)) {\n            l =\n              (alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i])) / l;\n            x *= l;\n            y *= l;\n            t.x -= x * (k = s.weight / (t.weight + s.weight));\n            t.y -= y * k;\n            s.x += x * (k = 1 - k);\n            s.y += y * k;\n          }\n        }\n        if ((k = alpha * gravity)) {\n          x = size[0] / 2;\n          y = size[1] / 2;\n          i = -1;\n          if (k)\n            while (++i < n) {\n              o = nodes[i];\n              o.x += (x - o.x) * k;\n              o.y += (y - o.y) * k;\n            }\n        }\n        if (charge) {\n          d3_layout_forceAccumulate(\n            (q = d3.geom.quadtree(nodes)),\n            alpha,\n            charges\n          );\n          i = -1;\n          while (++i < n) {\n            if (!(o = nodes[i]).fixed) {\n              q.visit(repulse(o));\n            }\n          }\n        }\n        i = -1;\n        while (++i < n) {\n          o = nodes[i];\n          if (o.fixed) {\n            o.x = o.px;\n            o.y = o.py;\n          } else {\n            o.x -= (o.px - (o.px = o.x)) * friction;\n            o.y -= (o.py - (o.py = o.y)) * friction;\n          }\n        }\n        event.tick({\n          type: \"tick\",\n          alpha: alpha,\n        });\n      };\n      force.nodes = function (x) {\n        if (!arguments.length) return nodes;\n        nodes = x;\n        return force;\n      };\n      force.links = function (x) {\n        if (!arguments.length) return links;\n        links = x;\n        return force;\n      };\n      force.size = function (x) {\n        if (!arguments.length) return size;\n        size = x;\n        return force;\n      };\n      force.linkDistance = function (x) {\n        if (!arguments.length) return linkDistance;\n        linkDistance = d3_functor(x);\n        return force;\n      };\n      force.distance = force.linkDistance;\n      force.linkStrength = function (x) {\n        if (!arguments.length) return linkStrength;\n        linkStrength = d3_functor(x);\n        return force;\n      };\n      force.friction = function (x) {\n        if (!arguments.length) return friction;\n        friction = x;\n        return force;\n      };\n      force.charge = function (x) {\n        if (!arguments.length) return charge;\n        charge = typeof x === \"function\" ? x : +x;\n        return force;\n      };\n      force.gravity = function (x) {\n        if (!arguments.length) return gravity;\n        gravity = x;\n        return force;\n      };\n      force.theta = function (x) {\n        if (!arguments.length) return theta;\n        theta = x;\n        return force;\n      };\n      force.alpha = function (x) {\n        if (!arguments.length) return alpha;\n        if (alpha) {\n          if (x > 0) alpha = x;\n          else alpha = 0;\n        } else if (x > 0) {\n          event.start({\n            type: \"start\",\n            alpha: (alpha = x),\n          });\n          d3.timer(force.tick);\n        }\n        return force;\n      };\n      force.start = function () {\n        function position(dimension, size) {\n          var neighbors = neighbor(i),\n            j = -1,\n            m = neighbors.length,\n            x;\n          while (++j < m) if (!isNaN((x = neighbors[j][dimension]))) return x;\n          return Math.random() * size;\n        }\n        function neighbor() {\n          if (!neighbors) {\n            neighbors = [];\n            for (j = 0; j < n; ++j) {\n              neighbors[j] = [];\n            }\n            for (j = 0; j < m; ++j) {\n              var o = links[j];\n              neighbors[o.source.index].push(o.target);\n              neighbors[o.target.index].push(o.source);\n            }\n          }\n          return neighbors[i];\n        }\n        var i,\n          j,\n          n = nodes.length,\n          m = links.length,\n          w = size[0],\n          h = size[1],\n          neighbors,\n          o;\n        for (i = 0; i < n; ++i) {\n          (o = nodes[i]).index = i;\n          o.weight = 0;\n        }\n        distances = [];\n        strengths = [];\n        for (i = 0; i < m; ++i) {\n          o = links[i];\n          if (typeof o.source == \"number\") o.source = nodes[o.source];\n          if (typeof o.target == \"number\") o.target = nodes[o.target];\n          distances[i] = linkDistance.call(this, o, i);\n          strengths[i] = linkStrength.call(this, o, i);\n          ++o.source.weight;\n          ++o.target.weight;\n        }\n        for (i = 0; i < n; ++i) {\n          o = nodes[i];\n          if (isNaN(o.x)) o.x = position(\"x\", w);\n          if (isNaN(o.y)) o.y = position(\"y\", h);\n          if (isNaN(o.px)) o.px = o.x;\n          if (isNaN(o.py)) o.py = o.y;\n        }\n        charges = [];\n        if (typeof charge === \"function\") {\n          for (i = 0; i < n; ++i) {\n            charges[i] = +charge.call(this, nodes[i], i);\n          }\n        } else {\n          for (i = 0; i < n; ++i) {\n            charges[i] = charge;\n          }\n        }\n        return force.resume();\n      };\n      force.resume = function () {\n        return force.alpha(0.1);\n      };\n      force.stop = function () {\n        return force.alpha(0);\n      };\n      force.drag = function () {\n        if (!drag)\n          drag = d3.behavior\n            .drag()\n            .origin(d3_identity)\n            .on(\"dragstart\", d3_layout_forceDragstart)\n            .on(\"drag\", dragmove)\n            .on(\"dragend\", d3_layout_forceDragend);\n        this.on(\"mouseover.force\", d3_layout_forceMouseover)\n          .on(\"mouseout.force\", d3_layout_forceMouseout)\n          .call(drag);\n      };\n      return d3.rebind(force, event, \"on\");\n    };\n    d3.layout.partition = function () {\n      function position(node, x, dx, dy) {\n        var children = node.children;\n        node.x = x;\n        node.y = node.depth * dy;\n        node.dx = dx;\n        node.dy = dy;\n        if (children && (n = children.length)) {\n          var i = -1,\n            n,\n            c,\n            d;\n          dx = node.value ? dx / node.value : 0;\n          while (++i < n) {\n            position((c = children[i]), x, (d = c.value * dx), dy);\n            x += d;\n          }\n        }\n      }\n      function depth(node) {\n        var children = node.children,\n          d = 0;\n        if (children && (n = children.length)) {\n          var i = -1,\n            n;\n          while (++i < n) d = Math.max(d, depth(children[i]));\n        }\n        return 1 + d;\n      }\n      function partition(d, i) {\n        var nodes = hierarchy.call(this, d, i);\n        position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n        return nodes;\n      }\n      var hierarchy = d3.layout.hierarchy(),\n        size = [1, 1];\n      partition.size = function (x) {\n        if (!arguments.length) return size;\n        size = x;\n        return partition;\n      };\n      return d3_layout_hierarchyRebind(partition, hierarchy);\n    };\n    d3.layout.pie = function () {\n      function pie(data, i) {\n        var values = data.map(function (d, i) {\n          return +value.call(pie, d, i);\n        });\n        var a = +(typeof startAngle === \"function\"\n          ? startAngle.apply(this, arguments)\n          : startAngle);\n        var k =\n          ((typeof endAngle === \"function\"\n            ? endAngle.apply(this, arguments)\n            : endAngle) -\n            startAngle) /\n          d3.sum(values);\n        var index = d3.range(data.length);\n        if (sort != null)\n          index.sort(\n            sort === d3_layout_pieSortByValue\n              ? function (i, j) {\n                  return values[j] - values[i];\n                }\n              : function (i, j) {\n                  return sort(data[i], data[j]);\n                }\n          );\n        var arcs = [];\n        index.forEach(function (i) {\n          var d;\n          arcs[i] = {\n            data: data[i],\n            value: (d = values[i]),\n            startAngle: a,\n            endAngle: (a += d * k),\n          };\n        });\n        return arcs;\n      }\n      var value = Number,\n        sort = d3_layout_pieSortByValue,\n        startAngle = 0,\n        endAngle = 2 * Math.PI;\n      pie.value = function (x) {\n        if (!arguments.length) return value;\n        value = x;\n        return pie;\n      };\n      pie.sort = function (x) {\n        if (!arguments.length) return sort;\n        sort = x;\n        return pie;\n      };\n      pie.startAngle = function (x) {\n        if (!arguments.length) return startAngle;\n        startAngle = x;\n        return pie;\n      };\n      pie.endAngle = function (x) {\n        if (!arguments.length) return endAngle;\n        endAngle = x;\n        return pie;\n      };\n      return pie;\n    };\n    var d3_layout_pieSortByValue = {};\n    d3.layout.stack = function () {\n      function stack(data, index) {\n        var series = data.map(function (d, i) {\n          return values.call(stack, d, i);\n        });\n        var points = series.map(function (d, i) {\n          return d.map(function (v, i) {\n            return [x.call(stack, v, i), y.call(stack, v, i)];\n          });\n        });\n        var orders = order.call(stack, points, index);\n        series = d3.permute(series, orders);\n        points = d3.permute(points, orders);\n        var offsets = offset.call(stack, points, index);\n        var n = series.length,\n          m = series[0].length,\n          i,\n          j,\n          o;\n        for (j = 0; j < m; ++j) {\n          out.call(stack, series[0][j], (o = offsets[j]), points[0][j][1]);\n          for (i = 1; i < n; ++i) {\n            out.call(\n              stack,\n              series[i][j],\n              (o += points[i - 1][j][1]),\n              points[i][j][1]\n            );\n          }\n        }\n        return data;\n      }\n      var values = d3_identity,\n        order = d3_layout_stackOrderDefault,\n        offset = d3_layout_stackOffsetZero,\n        out = d3_layout_stackOut,\n        x = d3_layout_stackX,\n        y = d3_layout_stackY;\n      stack.values = function (x) {\n        if (!arguments.length) return values;\n        values = x;\n        return stack;\n      };\n      stack.order = function (x) {\n        if (!arguments.length) return order;\n        order =\n          typeof x === \"function\"\n            ? x\n            : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n        return stack;\n      };\n      stack.offset = function (x) {\n        if (!arguments.length) return offset;\n        offset =\n          typeof x === \"function\"\n            ? x\n            : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n        return stack;\n      };\n      stack.x = function (z) {\n        if (!arguments.length) return x;\n        x = z;\n        return stack;\n      };\n      stack.y = function (z) {\n        if (!arguments.length) return y;\n        y = z;\n        return stack;\n      };\n      stack.out = function (z) {\n        if (!arguments.length) return out;\n        out = z;\n        return stack;\n      };\n      return stack;\n    };\n    var d3_layout_stackOrders = d3.map({\n      \"inside-out\": function (data) {\n        var n = data.length,\n          i,\n          j,\n          max = data.map(d3_layout_stackMaxIndex),\n          sums = data.map(d3_layout_stackReduceSum),\n          index = d3.range(n).sort(function (a, b) {\n            return max[a] - max[b];\n          }),\n          top = 0,\n          bottom = 0,\n          tops = [],\n          bottoms = [];\n        for (i = 0; i < n; ++i) {\n          j = index[i];\n          if (top < bottom) {\n            top += sums[j];\n            tops.push(j);\n          } else {\n            bottom += sums[j];\n            bottoms.push(j);\n          }\n        }\n        return bottoms.reverse().concat(tops);\n      },\n      reverse: function (data) {\n        return d3.range(data.length).reverse();\n      },\n      default: d3_layout_stackOrderDefault,\n    });\n    var d3_layout_stackOffsets = d3.map({\n      silhouette: function (data) {\n        var n = data.length,\n          m = data[0].length,\n          sums = [],\n          max = 0,\n          i,\n          j,\n          o,\n          y0 = [];\n        for (j = 0; j < m; ++j) {\n          for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n          if (o > max) max = o;\n          sums.push(o);\n        }\n        for (j = 0; j < m; ++j) {\n          y0[j] = (max - sums[j]) / 2;\n        }\n        return y0;\n      },\n      wiggle: function (data) {\n        var n = data.length,\n          x = data[0],\n          m = x.length,\n          max = 0,\n          i,\n          j,\n          k,\n          s1,\n          s2,\n          s3,\n          dx,\n          o,\n          o0,\n          y0 = [];\n        y0[0] = o = o0 = 0;\n        for (j = 1; j < m; ++j) {\n          for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n          for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n            for (\n              k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx);\n              k < i;\n              ++k\n            ) {\n              s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n            }\n            s2 += s3 * data[i][j][1];\n          }\n          y0[j] = o -= s1 ? (s2 / s1) * dx : 0;\n          if (o < o0) o0 = o;\n        }\n        for (j = 0; j < m; ++j) y0[j] -= o0;\n        return y0;\n      },\n      expand: function (data) {\n        var n = data.length,\n          m = data[0].length,\n          k = 1 / n,\n          i,\n          j,\n          o,\n          y0 = [];\n        for (j = 0; j < m; ++j) {\n          for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n          if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;\n          else for (i = 0; i < n; i++) data[i][j][1] = k;\n        }\n        for (j = 0; j < m; ++j) y0[j] = 0;\n        return y0;\n      },\n      zero: d3_layout_stackOffsetZero,\n    });\n    d3.layout.histogram = function () {\n      function histogram(data, i) {\n        var bins = [],\n          values = data.map(valuer, this),\n          range = ranger.call(this, values, i),\n          thresholds = binner.call(this, range, values, i),\n          bin,\n          i = -1,\n          n = values.length,\n          m = thresholds.length - 1,\n          k = frequency ? 1 : 1 / n,\n          x;\n        while (++i < m) {\n          bin = bins[i] = [];\n          bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n          bin.y = 0;\n        }\n        if (m > 0) {\n          i = -1;\n          while (++i < n) {\n            x = values[i];\n            if (x >= range[0] && x <= range[1]) {\n              bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n              bin.y += k;\n              bin.push(data[i]);\n            }\n          }\n        }\n        return bins;\n      }\n      var frequency = true,\n        valuer = Number,\n        ranger = d3_layout_histogramRange,\n        binner = d3_layout_histogramBinSturges;\n      histogram.value = function (x) {\n        if (!arguments.length) return valuer;\n        valuer = x;\n        return histogram;\n      };\n      histogram.range = function (x) {\n        if (!arguments.length) return ranger;\n        ranger = d3_functor(x);\n        return histogram;\n      };\n      histogram.bins = function (x) {\n        if (!arguments.length) return binner;\n        binner =\n          typeof x === \"number\"\n            ? function (range) {\n                return d3_layout_histogramBinFixed(range, x);\n              }\n            : d3_functor(x);\n        return histogram;\n      };\n      histogram.frequency = function (x) {\n        if (!arguments.length) return frequency;\n        frequency = !!x;\n        return histogram;\n      };\n      return histogram;\n    };\n    d3.layout.hierarchy = function () {\n      function recurse(data, depth, nodes) {\n        var childs = children.call(hierarchy, data, depth),\n          node = d3_layout_hierarchyInline\n            ? data\n            : {\n                data: data,\n              };\n        node.depth = depth;\n        nodes.push(node);\n        if (childs && (n = childs.length)) {\n          var i = -1,\n            n,\n            c = (node.children = []),\n            v = 0,\n            j = depth + 1,\n            d;\n          while (++i < n) {\n            d = recurse(childs[i], j, nodes);\n            d.parent = node;\n            c.push(d);\n            v += d.value;\n          }\n          if (sort) c.sort(sort);\n          if (value) node.value = v;\n        } else if (value) {\n          node.value = +value.call(hierarchy, data, depth) || 0;\n        }\n        return node;\n      }\n      function revalue(node, depth) {\n        var children = node.children,\n          v = 0;\n        if (children && (n = children.length)) {\n          var i = -1,\n            n,\n            j = depth + 1;\n          while (++i < n) v += revalue(children[i], j);\n        } else if (value) {\n          v =\n            +value.call(\n              hierarchy,\n              d3_layout_hierarchyInline ? node : node.data,\n              depth\n            ) || 0;\n        }\n        if (value) node.value = v;\n        return v;\n      }\n      function hierarchy(d) {\n        var nodes = [];\n        recurse(d, 0, nodes);\n        return nodes;\n      }\n      var sort = d3_layout_hierarchySort,\n        children = d3_layout_hierarchyChildren,\n        value = d3_layout_hierarchyValue;\n      hierarchy.sort = function (x) {\n        if (!arguments.length) return sort;\n        sort = x;\n        return hierarchy;\n      };\n      hierarchy.children = function (x) {\n        if (!arguments.length) return children;\n        children = x;\n        return hierarchy;\n      };\n      hierarchy.value = function (x) {\n        if (!arguments.length) return value;\n        value = x;\n        return hierarchy;\n      };\n      hierarchy.revalue = function (root) {\n        revalue(root, 0);\n        return root;\n      };\n      return hierarchy;\n    };\n    var d3_layout_hierarchyInline = false;\n    d3.layout.pack = function () {\n      function pack(d, i) {\n        var nodes = hierarchy.call(this, d, i),\n          root = nodes[0];\n        root.x = 0;\n        root.y = 0;\n        d3_layout_treeVisitAfter(root, function (d) {\n          d.r = Math.sqrt(d.value);\n        });\n        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\n        var w = size[0],\n          h = size[1],\n          k = Math.max((2 * root.r) / w, (2 * root.r) / h);\n        if (padding > 0) {\n          var dr = (padding * k) / 2;\n          d3_layout_treeVisitAfter(root, function (d) {\n            d.r += dr;\n          });\n          d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\n          d3_layout_treeVisitAfter(root, function (d) {\n            d.r -= dr;\n          });\n          k = Math.max((2 * root.r) / w, (2 * root.r) / h);\n        }\n        d3_layout_packTransform(root, w / 2, h / 2, 1 / k);\n        return nodes;\n      }\n      var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\n        padding = 0,\n        size = [1, 1];\n      pack.size = function (x) {\n        if (!arguments.length) return size;\n        size = x;\n        return pack;\n      };\n      pack.padding = function (_) {\n        if (!arguments.length) return padding;\n        padding = +_;\n        return pack;\n      };\n      return d3_layout_hierarchyRebind(pack, hierarchy);\n    };\n    d3.layout.cluster = function () {\n      function cluster(d, i) {\n        var nodes = hierarchy.call(this, d, i),\n          root = nodes[0],\n          previousNode,\n          x = 0,\n          kx,\n          ky;\n        d3_layout_treeVisitAfter(root, function (node) {\n          var children = node.children;\n          if (children && children.length) {\n            node.x = d3_layout_clusterX(children);\n            node.y = d3_layout_clusterY(children);\n          } else {\n            node.x = previousNode ? (x += separation(node, previousNode)) : 0;\n            node.y = 0;\n            previousNode = node;\n          }\n        });\n        var left = d3_layout_clusterLeft(root),\n          right = d3_layout_clusterRight(root),\n          x0 = left.x - separation(left, right) / 2,\n          x1 = right.x + separation(right, left) / 2;\n        d3_layout_treeVisitAfter(root, function (node) {\n          node.x = ((node.x - x0) / (x1 - x0)) * size[0];\n          node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n        });\n        return nodes;\n      }\n      var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n        separation = d3_layout_treeSeparation,\n        size = [1, 1];\n      cluster.separation = function (x) {\n        if (!arguments.length) return separation;\n        separation = x;\n        return cluster;\n      };\n      cluster.size = function (x) {\n        if (!arguments.length) return size;\n        size = x;\n        return cluster;\n      };\n      return d3_layout_hierarchyRebind(cluster, hierarchy);\n    };\n    d3.layout.tree = function () {\n      function tree(d, i) {\n        function firstWalk(node, previousSibling) {\n          var children = node.children,\n            layout = node._tree;\n          if (children && (n = children.length)) {\n            var n,\n              firstChild = children[0],\n              previousChild,\n              ancestor = firstChild,\n              child,\n              i = -1;\n            while (++i < n) {\n              child = children[i];\n              firstWalk(child, previousChild);\n              ancestor = apportion(child, previousChild, ancestor);\n              previousChild = child;\n            }\n            d3_layout_treeShift(node);\n            var midpoint = 0.5 * (firstChild._tree.prelim + child._tree.prelim);\n            if (previousSibling) {\n              layout.prelim =\n                previousSibling._tree.prelim +\n                separation(node, previousSibling);\n              layout.mod = layout.prelim - midpoint;\n            } else {\n              layout.prelim = midpoint;\n            }\n          } else {\n            if (previousSibling) {\n              layout.prelim =\n                previousSibling._tree.prelim +\n                separation(node, previousSibling);\n            }\n          }\n        }\n        function secondWalk(node, x) {\n          node.x = node._tree.prelim + x;\n          var children = node.children;\n          if (children && (n = children.length)) {\n            var i = -1,\n              n;\n            x += node._tree.mod;\n            while (++i < n) {\n              secondWalk(children[i], x);\n            }\n          }\n        }\n        function apportion(node, previousSibling, ancestor) {\n          if (previousSibling) {\n            var vip = node,\n              vop = node,\n              vim = previousSibling,\n              vom = node.parent.children[0],\n              sip = vip._tree.mod,\n              sop = vop._tree.mod,\n              sim = vim._tree.mod,\n              som = vom._tree.mod,\n              shift;\n            while (\n              ((vim = d3_layout_treeRight(vim)),\n              (vip = d3_layout_treeLeft(vip)),\n              vim && vip)\n            ) {\n              vom = d3_layout_treeLeft(vom);\n              vop = d3_layout_treeRight(vop);\n              vop._tree.ancestor = node;\n              shift =\n                vim._tree.prelim +\n                sim -\n                vip._tree.prelim -\n                sip +\n                separation(vim, vip);\n              if (shift > 0) {\n                d3_layout_treeMove(\n                  d3_layout_treeAncestor(vim, node, ancestor),\n                  node,\n                  shift\n                );\n                sip += shift;\n                sop += shift;\n              }\n              sim += vim._tree.mod;\n              sip += vip._tree.mod;\n              som += vom._tree.mod;\n              sop += vop._tree.mod;\n            }\n            if (vim && !d3_layout_treeRight(vop)) {\n              vop._tree.thread = vim;\n              vop._tree.mod += sim - sop;\n            }\n            if (vip && !d3_layout_treeLeft(vom)) {\n              vom._tree.thread = vip;\n              vom._tree.mod += sip - som;\n              ancestor = node;\n            }\n          }\n          return ancestor;\n        }\n        var nodes = hierarchy.call(this, d, i),\n          root = nodes[0];\n        d3_layout_treeVisitAfter(root, function (node, previousSibling) {\n          node._tree = {\n            ancestor: node,\n            prelim: 0,\n            mod: 0,\n            change: 0,\n            shift: 0,\n            number: previousSibling ? previousSibling._tree.number + 1 : 0,\n          };\n        });\n        firstWalk(root);\n        secondWalk(root, -root._tree.prelim);\n        var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),\n          right = d3_layout_treeSearch(root, d3_layout_treeRightmost),\n          deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),\n          x0 = left.x - separation(left, right) / 2,\n          x1 = right.x + separation(right, left) / 2,\n          y1 = deep.depth || 1;\n        d3_layout_treeVisitAfter(root, function (node) {\n          node.x = ((node.x - x0) / (x1 - x0)) * size[0];\n          node.y = (node.depth / y1) * size[1];\n          delete node._tree;\n        });\n        return nodes;\n      }\n      var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n        separation = d3_layout_treeSeparation,\n        size = [1, 1];\n      tree.separation = function (x) {\n        if (!arguments.length) return separation;\n        separation = x;\n        return tree;\n      };\n      tree.size = function (x) {\n        if (!arguments.length) return size;\n        size = x;\n        return tree;\n      };\n      return d3_layout_hierarchyRebind(tree, hierarchy);\n    };\n    d3.layout.treemap = function () {\n      function scale(children, k) {\n        var i = -1,\n          n = children.length,\n          child,\n          area;\n        while (++i < n) {\n          area = (child = children[i]).value * (k < 0 ? 0 : k);\n          child.area = isNaN(area) || area <= 0 ? 0 : area;\n        }\n      }\n      function squarify(node) {\n        var children = node.children;\n        if (children && children.length) {\n          var rect = pad(node),\n            row = [],\n            remaining = children.slice(),\n            child,\n            best = Infinity,\n            score,\n            u = Math.min(rect.dx, rect.dy),\n            n;\n          scale(remaining, (rect.dx * rect.dy) / node.value);\n          row.area = 0;\n          while ((n = remaining.length) > 0) {\n            row.push((child = remaining[n - 1]));\n            row.area += child.area;\n            if ((score = worst(row, u)) <= best) {\n              remaining.pop();\n              best = score;\n            } else {\n              row.area -= row.pop().area;\n              position(row, u, rect, false);\n              u = Math.min(rect.dx, rect.dy);\n              row.length = row.area = 0;\n              best = Infinity;\n            }\n          }\n          if (row.length) {\n            position(row, u, rect, true);\n            row.length = row.area = 0;\n          }\n          children.forEach(squarify);\n        }\n      }\n      function stickify(node) {\n        var children = node.children;\n        if (children && children.length) {\n          var rect = pad(node),\n            remaining = children.slice(),\n            child,\n            row = [];\n          scale(remaining, (rect.dx * rect.dy) / node.value);\n          row.area = 0;\n          while ((child = remaining.pop())) {\n            row.push(child);\n            row.area += child.area;\n            if (child.z != null) {\n              position(\n                row,\n                child.z ? rect.dx : rect.dy,\n                rect,\n                !remaining.length\n              );\n              row.length = row.area = 0;\n            }\n          }\n          children.forEach(stickify);\n        }\n      }\n      function worst(row, u) {\n        var s = row.area,\n          r,\n          rmax = 0,\n          rmin = Infinity,\n          i = -1,\n          n = row.length;\n        while (++i < n) {\n          if (!(r = row[i].area)) continue;\n          if (r < rmin) rmin = r;\n          if (r > rmax) rmax = r;\n        }\n        s *= s;\n        u *= u;\n        return s\n          ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))\n          : Infinity;\n      }\n      function position(row, u, rect, flush) {\n        var i = -1,\n          n = row.length,\n          x = rect.x,\n          y = rect.y,\n          v = u ? round(row.area / u) : 0,\n          o;\n        if (u == rect.dx) {\n          if (flush || v > rect.dy) v = rect.dy;\n          while (++i < n) {\n            o = row[i];\n            o.x = x;\n            o.y = y;\n            o.dy = v;\n            x += o.dx = Math.min(\n              rect.x + rect.dx - x,\n              v ? round(o.area / v) : 0\n            );\n          }\n          o.z = true;\n          o.dx += rect.x + rect.dx - x;\n          rect.y += v;\n          rect.dy -= v;\n        } else {\n          if (flush || v > rect.dx) v = rect.dx;\n          while (++i < n) {\n            o = row[i];\n            o.x = x;\n            o.y = y;\n            o.dx = v;\n            y += o.dy = Math.min(\n              rect.y + rect.dy - y,\n              v ? round(o.area / v) : 0\n            );\n          }\n          o.z = false;\n          o.dy += rect.y + rect.dy - y;\n          rect.x += v;\n          rect.dx -= v;\n        }\n      }\n      function treemap(d) {\n        var nodes = stickies || hierarchy(d),\n          root = nodes[0];\n        root.x = 0;\n        root.y = 0;\n        root.dx = size[0];\n        root.dy = size[1];\n        if (stickies) hierarchy.revalue(root);\n        scale([root], (root.dx * root.dy) / root.value);\n        (stickies ? stickify : squarify)(root);\n        if (sticky) stickies = nodes;\n        return nodes;\n      }\n      var hierarchy = d3.layout.hierarchy(),\n        round = Math.round,\n        size = [1, 1],\n        padding = null,\n        pad = d3_layout_treemapPadNull,\n        sticky = false,\n        stickies,\n        ratio = 0.5 * (1 + Math.sqrt(5));\n      treemap.size = function (x) {\n        if (!arguments.length) return size;\n        size = x;\n        return treemap;\n      };\n      treemap.padding = function (x) {\n        function padFunction(node) {\n          var p = x.call(treemap, node, node.depth);\n          return p == null\n            ? d3_layout_treemapPadNull(node)\n            : d3_layout_treemapPad(\n                node,\n                typeof p === \"number\" ? [p, p, p, p] : p\n              );\n        }\n        function padConstant(node) {\n          return d3_layout_treemapPad(node, x);\n        }\n        if (!arguments.length) return padding;\n        var type;\n        pad =\n          (padding = x) == null\n            ? d3_layout_treemapPadNull\n            : (type = typeof x) === \"function\"\n            ? padFunction\n            : type === \"number\"\n            ? ((x = [x, x, x, x]), padConstant)\n            : padConstant;\n        return treemap;\n      };\n      treemap.round = function (x) {\n        if (!arguments.length) return round != Number;\n        round = x ? Math.round : Number;\n        return treemap;\n      };\n      treemap.sticky = function (x) {\n        if (!arguments.length) return sticky;\n        sticky = x;\n        stickies = null;\n        return treemap;\n      };\n      treemap.ratio = function (x) {\n        if (!arguments.length) return ratio;\n        ratio = x;\n        return treemap;\n      };\n      return d3_layout_hierarchyRebind(treemap, hierarchy);\n    };\n    d3.csv = d3_dsv(\",\", \"text/csv\");\n    d3.tsv = d3_dsv(\"\t\", \"text/tab-separated-values\");\n    d3.geo = {};\n    var d3_geo_radians = Math.PI / 180;\n    d3.geo.azimuthal = function () {\n      function azimuthal(coordinates) {\n        var x1 = coordinates[0] * d3_geo_radians - x0,\n          y1 = coordinates[1] * d3_geo_radians,\n          cx1 = Math.cos(x1),\n          sx1 = Math.sin(x1),\n          cy1 = Math.cos(y1),\n          sy1 = Math.sin(y1),\n          cc = mode !== \"orthographic\" ? sy0 * sy1 + cy0 * cy1 * cx1 : null,\n          c,\n          k =\n            mode === \"stereographic\"\n              ? 1 / (1 + cc)\n              : mode === \"gnomonic\"\n              ? 1 / cc\n              : mode === \"equidistant\"\n              ? ((c = Math.acos(cc)), c ? c / Math.sin(c) : 0)\n              : mode === \"equalarea\"\n              ? Math.sqrt(2 / (1 + cc))\n              : 1,\n          x = k * cy1 * sx1,\n          y = k * (sy0 * cy1 * cx1 - cy0 * sy1);\n        return [scale * x + translate[0], scale * y + translate[1]];\n      }\n      var mode = \"orthographic\",\n        origin,\n        scale = 200,\n        translate = [480, 250],\n        x0,\n        y0,\n        cy0,\n        sy0;\n      azimuthal.invert = function (coordinates) {\n        var x = (coordinates[0] - translate[0]) / scale,\n          y = (coordinates[1] - translate[1]) / scale,\n          p = Math.sqrt(x * x + y * y),\n          c =\n            mode === \"stereographic\"\n              ? 2 * Math.atan(p)\n              : mode === \"gnomonic\"\n              ? Math.atan(p)\n              : mode === \"equidistant\"\n              ? p\n              : mode === \"equalarea\"\n              ? 2 * Math.asin(0.5 * p)\n              : Math.asin(p),\n          sc = Math.sin(c),\n          cc = Math.cos(c);\n        return [\n          (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) /\n            d3_geo_radians,\n          Math.asin(cc * sy0 - (p ? (y * sc * cy0) / p : 0)) / d3_geo_radians,\n        ];\n      };\n      azimuthal.mode = function (x) {\n        if (!arguments.length) return mode;\n        mode = x + \"\";\n        return azimuthal;\n      };\n      azimuthal.origin = function (x) {\n        if (!arguments.length) return origin;\n        origin = x;\n        x0 = origin[0] * d3_geo_radians;\n        y0 = origin[1] * d3_geo_radians;\n        cy0 = Math.cos(y0);\n        sy0 = Math.sin(y0);\n        return azimuthal;\n      };\n      azimuthal.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = +x;\n        return azimuthal;\n      };\n      azimuthal.translate = function (x) {\n        if (!arguments.length) return translate;\n        translate = [+x[0], +x[1]];\n        return azimuthal;\n      };\n      return azimuthal.origin([0, 0]);\n    };\n    d3.geo.albers = function () {\n      function albers(coordinates) {\n        var t = n * (d3_geo_radians * coordinates[0] - lng0),\n          p =\n            Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) /\n            n;\n        return [\n          scale * p * Math.sin(t) + translate[0],\n          scale * (p * Math.cos(t) - p0) + translate[1],\n        ];\n      }\n      function reload() {\n        var phi1 = d3_geo_radians * parallels[0],\n          phi2 = d3_geo_radians * parallels[1],\n          lat0 = d3_geo_radians * origin[1],\n          s = Math.sin(phi1),\n          c = Math.cos(phi1);\n        lng0 = d3_geo_radians * origin[0];\n        n = 0.5 * (s + Math.sin(phi2));\n        C = c * c + 2 * n * s;\n        p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;\n        return albers;\n      }\n      var origin = [-98, 38],\n        parallels = [29.5, 45.5],\n        scale = 1e3,\n        translate = [480, 250],\n        lng0,\n        n,\n        C,\n        p0;\n      albers.invert = function (coordinates) {\n        var x = (coordinates[0] - translate[0]) / scale,\n          y = (coordinates[1] - translate[1]) / scale,\n          p0y = p0 + y,\n          t = Math.atan2(x, p0y),\n          p = Math.sqrt(x * x + p0y * p0y);\n        return [\n          (lng0 + t / n) / d3_geo_radians,\n          Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians,\n        ];\n      };\n      albers.origin = function (x) {\n        if (!arguments.length) return origin;\n        origin = [+x[0], +x[1]];\n        return reload();\n      };\n      albers.parallels = function (x) {\n        if (!arguments.length) return parallels;\n        parallels = [+x[0], +x[1]];\n        return reload();\n      };\n      albers.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = +x;\n        return albers;\n      };\n      albers.translate = function (x) {\n        if (!arguments.length) return translate;\n        translate = [+x[0], +x[1]];\n        return albers;\n      };\n      return reload();\n    };\n    d3.geo.albersUsa = function () {\n      function albersUsa(coordinates) {\n        var lon = coordinates[0],\n          lat = coordinates[1];\n        return (lat > 50\n          ? alaska\n          : lon < -140\n          ? hawaii\n          : lat < 21\n          ? puertoRico\n          : lower48)(coordinates);\n      }\n      var lower48 = d3.geo.albers();\n      var alaska = d3.geo.albers().origin([-160, 60]).parallels([55, 65]);\n      var hawaii = d3.geo.albers().origin([-160, 20]).parallels([8, 18]);\n      var puertoRico = d3.geo.albers().origin([-60, 10]).parallels([8, 18]);\n      albersUsa.scale = function (x) {\n        if (!arguments.length) return lower48.scale();\n        lower48.scale(x);\n        alaska.scale(x * 0.6);\n        hawaii.scale(x);\n        puertoRico.scale(x * 1.5);\n        return albersUsa.translate(lower48.translate());\n      };\n      albersUsa.translate = function (x) {\n        if (!arguments.length) return lower48.translate();\n        var dz = lower48.scale() / 1e3,\n          dx = x[0],\n          dy = x[1];\n        lower48.translate(x);\n        alaska.translate([dx - 400 * dz, dy + 170 * dz]);\n        hawaii.translate([dx - 190 * dz, dy + 200 * dz]);\n        puertoRico.translate([dx + 580 * dz, dy + 430 * dz]);\n        return albersUsa;\n      };\n      return albersUsa.scale(lower48.scale());\n    };\n    d3.geo.bonne = function () {\n      function bonne(coordinates) {\n        var x = coordinates[0] * d3_geo_radians - x0,\n          y = coordinates[1] * d3_geo_radians - y0;\n        if (y1) {\n          var p = c1 + y1 - y,\n            E = (x * Math.cos(y)) / p;\n          x = p * Math.sin(E);\n          y = p * Math.cos(E) - c1;\n        } else {\n          x *= Math.cos(y);\n          y *= -1;\n        }\n        return [scale * x + translate[0], scale * y + translate[1]];\n      }\n      var scale = 200,\n        translate = [480, 250],\n        x0,\n        y0,\n        y1,\n        c1;\n      bonne.invert = function (coordinates) {\n        var x = (coordinates[0] - translate[0]) / scale,\n          y = (coordinates[1] - translate[1]) / scale;\n        if (y1) {\n          var c = c1 + y,\n            p = Math.sqrt(x * x + c * c);\n          y = c1 + y1 - p;\n          x = x0 + (p * Math.atan2(x, c)) / Math.cos(y);\n        } else {\n          y *= -1;\n          x /= Math.cos(y);\n        }\n        return [x / d3_geo_radians, y / d3_geo_radians];\n      };\n      bonne.parallel = function (x) {\n        if (!arguments.length) return y1 / d3_geo_radians;\n        c1 = 1 / Math.tan((y1 = x * d3_geo_radians));\n        return bonne;\n      };\n      bonne.origin = function (x) {\n        if (!arguments.length)\n          return [x0 / d3_geo_radians, y0 / d3_geo_radians];\n        x0 = x[0] * d3_geo_radians;\n        y0 = x[1] * d3_geo_radians;\n        return bonne;\n      };\n      bonne.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = +x;\n        return bonne;\n      };\n      bonne.translate = function (x) {\n        if (!arguments.length) return translate;\n        translate = [+x[0], +x[1]];\n        return bonne;\n      };\n      return bonne.origin([0, 0]).parallel(45);\n    };\n    d3.geo.equirectangular = function () {\n      function equirectangular(coordinates) {\n        var x = coordinates[0] / 360,\n          y = -coordinates[1] / 360;\n        return [scale * x + translate[0], scale * y + translate[1]];\n      }\n      var scale = 500,\n        translate = [480, 250];\n      equirectangular.invert = function (coordinates) {\n        var x = (coordinates[0] - translate[0]) / scale,\n          y = (coordinates[1] - translate[1]) / scale;\n        return [360 * x, -360 * y];\n      };\n      equirectangular.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = +x;\n        return equirectangular;\n      };\n      equirectangular.translate = function (x) {\n        if (!arguments.length) return translate;\n        translate = [+x[0], +x[1]];\n        return equirectangular;\n      };\n      return equirectangular;\n    };\n    d3.geo.mercator = function () {\n      function mercator(coordinates) {\n        var x = coordinates[0] / 360,\n          y =\n            -(\n              Math.log(\n                Math.tan(Math.PI / 4 + (coordinates[1] * d3_geo_radians) / 2)\n              ) / d3_geo_radians\n            ) / 360;\n        return [\n          scale * x + translate[0],\n          scale * Math.max(-0.5, Math.min(0.5, y)) + translate[1],\n        ];\n      }\n      var scale = 500,\n        translate = [480, 250];\n      mercator.invert = function (coordinates) {\n        var x = (coordinates[0] - translate[0]) / scale,\n          y = (coordinates[1] - translate[1]) / scale;\n        return [\n          360 * x,\n          (2 * Math.atan(Math.exp(-360 * y * d3_geo_radians))) /\n            d3_geo_radians -\n            90,\n        ];\n      };\n      mercator.scale = function (x) {\n        if (!arguments.length) return scale;\n        scale = +x;\n        return mercator;\n      };\n      mercator.translate = function (x) {\n        if (!arguments.length) return translate;\n        translate = [+x[0], +x[1]];\n        return mercator;\n      };\n      return mercator;\n    };\n    d3.geo.path = function () {\n      function path(d, i) {\n        if (typeof pointRadius === \"function\")\n          pointCircle = d3_path_circle(pointRadius.apply(this, arguments));\n        pathType(d);\n        var result = buffer.length ? buffer.join(\"\") : null;\n        buffer = [];\n        return result;\n      }\n      function project(coordinates) {\n        return projection(coordinates).join(\",\");\n      }\n      function polygonArea(coordinates) {\n        var sum = area(coordinates[0]),\n          i = 0,\n          n = coordinates.length;\n        while (++i < n) sum -= area(coordinates[i]);\n        return sum;\n      }\n      function polygonCentroid(coordinates) {\n        var polygon = d3.geom.polygon(coordinates[0].map(projection)),\n          area = polygon.area(),\n          centroid = polygon.centroid(area < 0 ? ((area *= -1), 1) : -1),\n          x = centroid[0],\n          y = centroid[1],\n          z = area,\n          i = 0,\n          n = coordinates.length;\n        while (++i < n) {\n          polygon = d3.geom.polygon(coordinates[i].map(projection));\n          area = polygon.area();\n          centroid = polygon.centroid(area < 0 ? ((area *= -1), 1) : -1);\n          x -= centroid[0];\n          y -= centroid[1];\n          z -= area;\n        }\n        return [x, y, 6 * z];\n      }\n      function area(coordinates) {\n        return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());\n      }\n      var pointRadius = 4.5,\n        pointCircle = d3_path_circle(pointRadius),\n        projection = d3.geo.albersUsa(),\n        buffer = [];\n      var pathType = d3_geo_type({\n        FeatureCollection: function (o) {\n          var features = o.features,\n            i = -1,\n            n = features.length;\n          while (++i < n) buffer.push(pathType(features[i].geometry));\n        },\n        Feature: function (o) {\n          pathType(o.geometry);\n        },\n        Point: function (o) {\n          buffer.push(\"M\", project(o.coordinates), pointCircle);\n        },\n        MultiPoint: function (o) {\n          var coordinates = o.coordinates,\n            i = -1,\n            n = coordinates.length;\n          while (++i < n)\n            buffer.push(\"M\", project(coordinates[i]), pointCircle);\n        },\n        LineString: function (o) {\n          var coordinates = o.coordinates,\n            i = -1,\n            n = coordinates.length;\n          buffer.push(\"M\");\n          while (++i < n) buffer.push(project(coordinates[i]), \"L\");\n          buffer.pop();\n        },\n        MultiLineString: function (o) {\n          var coordinates = o.coordinates,\n            i = -1,\n            n = coordinates.length,\n            subcoordinates,\n            j,\n            m;\n          while (++i < n) {\n            subcoordinates = coordinates[i];\n            j = -1;\n            m = subcoordinates.length;\n            buffer.push(\"M\");\n            while (++j < m) buffer.push(project(subcoordinates[j]), \"L\");\n            buffer.pop();\n          }\n        },\n        Polygon: function (o) {\n          var coordinates = o.coordinates,\n            i = -1,\n            n = coordinates.length,\n            subcoordinates,\n            j,\n            m;\n          while (++i < n) {\n            subcoordinates = coordinates[i];\n            j = -1;\n            if ((m = subcoordinates.length - 1) > 0) {\n              buffer.push(\"M\");\n              while (++j < m) buffer.push(project(subcoordinates[j]), \"L\");\n              buffer[buffer.length - 1] = \"Z\";\n            }\n          }\n        },\n        MultiPolygon: function (o) {\n          var coordinates = o.coordinates,\n            i = -1,\n            n = coordinates.length,\n            subcoordinates,\n            j,\n            m,\n            subsubcoordinates,\n            k,\n            p;\n          while (++i < n) {\n            subcoordinates = coordinates[i];\n            j = -1;\n            m = subcoordinates.length;\n            while (++j < m) {\n              subsubcoordinates = subcoordinates[j];\n              k = -1;\n              if ((p = subsubcoordinates.length - 1) > 0) {\n                buffer.push(\"M\");\n                while (++k < p) buffer.push(project(subsubcoordinates[k]), \"L\");\n                buffer[buffer.length - 1] = \"Z\";\n              }\n            }\n          }\n        },\n        GeometryCollection: function (o) {\n          var geometries = o.geometries,\n            i = -1,\n            n = geometries.length;\n          while (++i < n) buffer.push(pathType(geometries[i]));\n        },\n      });\n      var areaType = (path.area = d3_geo_type(\n        {\n          FeatureCollection: function (o) {\n            var area = 0,\n              features = o.features,\n              i = -1,\n              n = features.length;\n            while (++i < n) area += areaType(features[i]);\n            return area;\n          },\n          Feature: function (o) {\n            return areaType(o.geometry);\n          },\n          Polygon: function (o) {\n            return polygonArea(o.coordinates);\n          },\n          MultiPolygon: function (o) {\n            var sum = 0,\n              coordinates = o.coordinates,\n              i = -1,\n              n = coordinates.length;\n            while (++i < n) sum += polygonArea(coordinates[i]);\n            return sum;\n          },\n          GeometryCollection: function (o) {\n            var sum = 0,\n              geometries = o.geometries,\n              i = -1,\n              n = geometries.length;\n            while (++i < n) sum += areaType(geometries[i]);\n            return sum;\n          },\n        },\n        0\n      ));\n      var centroidType = (path.centroid = d3_geo_type({\n        Feature: function (o) {\n          return centroidType(o.geometry);\n        },\n        Polygon: function (o) {\n          var centroid = polygonCentroid(o.coordinates);\n          return [centroid[0] / centroid[2], centroid[1] / centroid[2]];\n        },\n        MultiPolygon: function (o) {\n          var area = 0,\n            coordinates = o.coordinates,\n            centroid,\n            x = 0,\n            y = 0,\n            z = 0,\n            i = -1,\n            n = coordinates.length;\n          while (++i < n) {\n            centroid = polygonCentroid(coordinates[i]);\n            x += centroid[0];\n            y += centroid[1];\n            z += centroid[2];\n          }\n          return [x / z, y / z];\n        },\n      }));\n      path.projection = function (x) {\n        projection = x;\n        return path;\n      };\n      path.pointRadius = function (x) {\n        if (typeof x === \"function\") pointRadius = x;\n        else {\n          pointRadius = +x;\n          pointCircle = d3_path_circle(pointRadius);\n        }\n        return path;\n      };\n      return path;\n    };\n    d3.geo.bounds = function (feature) {\n      var left = Infinity,\n        bottom = Infinity,\n        right = -Infinity,\n        top = -Infinity;\n      d3_geo_bounds(feature, function (x, y) {\n        if (x < left) left = x;\n        if (x > right) right = x;\n        if (y < bottom) bottom = y;\n        if (y > top) top = y;\n      });\n      return [\n        [left, bottom],\n        [right, top],\n      ];\n    };\n    var d3_geo_boundsTypes = {\n      Feature: d3_geo_boundsFeature,\n      FeatureCollection: d3_geo_boundsFeatureCollection,\n      GeometryCollection: d3_geo_boundsGeometryCollection,\n      LineString: d3_geo_boundsLineString,\n      MultiLineString: d3_geo_boundsMultiLineString,\n      MultiPoint: d3_geo_boundsLineString,\n      MultiPolygon: d3_geo_boundsMultiPolygon,\n      Point: d3_geo_boundsPoint,\n      Polygon: d3_geo_boundsPolygon,\n    };\n    d3.geo.circle = function () {\n      function circle() {}\n      function visible(point) {\n        return arc.distance(point) < radians;\n      }\n      function clip(coordinates) {\n        var i = -1,\n          n = coordinates.length,\n          clipped = [],\n          p0,\n          p1,\n          p2,\n          d0,\n          d1;\n        while (++i < n) {\n          d1 = arc.distance((p2 = coordinates[i]));\n          if (d1 < radians) {\n            if (p1)\n              clipped.push(\n                d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1))\n              );\n            clipped.push(p2);\n            p0 = p1 = null;\n          } else {\n            p1 = p2;\n            if (!p0 && clipped.length) {\n              clipped.push(\n                d3_geo_greatArcInterpolate(\n                  clipped[clipped.length - 1],\n                  p1\n                )((radians - d0) / (d1 - d0))\n              );\n              p0 = p1;\n            }\n          }\n          d0 = d1;\n        }\n        p0 = coordinates[0];\n        p1 = clipped[0];\n        if (\n          p1 &&\n          p2[0] === p0[0] &&\n          p2[1] === p0[1] &&\n          !(p2[0] === p1[0] && p2[1] === p1[1])\n        ) {\n          clipped.push(p1);\n        }\n        return resample(clipped);\n      }\n      function resample(coordinates) {\n        var i = 0,\n          n = coordinates.length,\n          j,\n          m,\n          resampled = n ? [coordinates[0]] : coordinates,\n          resamples,\n          origin = arc.source();\n        while (++i < n) {\n          resamples = arc.source(coordinates[i - 1])(coordinates[i])\n            .coordinates;\n          for (j = 0, m = resamples.length; ++j < m; )\n            resampled.push(resamples[j]);\n        }\n        arc.source(origin);\n        return resampled;\n      }\n      var origin = [0, 0],\n        degrees = 90 - 0.01,\n        radians = degrees * d3_geo_radians,\n        arc = d3.geo.greatArc().source(origin).target(d3_identity);\n      circle.clip = function (d) {\n        if (typeof origin === \"function\")\n          arc.source(origin.apply(this, arguments));\n        return clipType(d) || null;\n      };\n      var clipType = d3_geo_type({\n        FeatureCollection: function (o) {\n          var features = o.features.map(clipType).filter(d3_identity);\n          return (\n            features && ((o = Object.create(o)), (o.features = features), o)\n          );\n        },\n        Feature: function (o) {\n          var geometry = clipType(o.geometry);\n          return (\n            geometry && ((o = Object.create(o)), (o.geometry = geometry), o)\n          );\n        },\n        Point: function (o) {\n          return visible(o.coordinates) && o;\n        },\n        MultiPoint: function (o) {\n          var coordinates = o.coordinates.filter(visible);\n          return (\n            coordinates.length && {\n              type: o.type,\n              coordinates: coordinates,\n            }\n          );\n        },\n        LineString: function (o) {\n          var coordinates = clip(o.coordinates);\n          return (\n            coordinates.length &&\n            ((o = Object.create(o)), (o.coordinates = coordinates), o)\n          );\n        },\n        MultiLineString: function (o) {\n          var coordinates = o.coordinates.map(clip).filter(function (d) {\n            return d.length;\n          });\n          return (\n            coordinates.length &&\n            ((o = Object.create(o)), (o.coordinates = coordinates), o)\n          );\n        },\n        Polygon: function (o) {\n          var coordinates = o.coordinates.map(clip);\n          return (\n            coordinates[0].length &&\n            ((o = Object.create(o)), (o.coordinates = coordinates), o)\n          );\n        },\n        MultiPolygon: function (o) {\n          var coordinates = o.coordinates\n            .map(function (d) {\n              return d.map(clip);\n            })\n            .filter(function (d) {\n              return d[0].length;\n            });\n          return (\n            coordinates.length &&\n            ((o = Object.create(o)), (o.coordinates = coordinates), o)\n          );\n        },\n        GeometryCollection: function (o) {\n          var geometries = o.geometries.map(clipType).filter(d3_identity);\n          return (\n            geometries.length &&\n            ((o = Object.create(o)), (o.geometries = geometries), o)\n          );\n        },\n      });\n      circle.origin = function (x) {\n        if (!arguments.length) return origin;\n        origin = x;\n        if (typeof origin !== \"function\") arc.source(origin);\n        return circle;\n      };\n      circle.angle = function (x) {\n        if (!arguments.length) return degrees;\n        radians = (degrees = +x) * d3_geo_radians;\n        return circle;\n      };\n      return d3.rebind(circle, arc, \"precision\");\n    };\n    d3.geo.greatArc = function () {\n      function greatArc() {\n        var d = greatArc.distance.apply(this, arguments),\n          t = 0,\n          dt = precision / d,\n          coordinates = [p0];\n        while ((t += dt) < 1) coordinates.push(interpolate(t));\n        coordinates.push(p1);\n        return {\n          type: \"LineString\",\n          coordinates: coordinates,\n        };\n      }\n      var source = d3_geo_greatArcSource,\n        p0,\n        target = d3_geo_greatArcTarget,\n        p1,\n        precision = 6 * d3_geo_radians,\n        interpolate = d3_geo_greatArcInterpolator();\n      greatArc.distance = function () {\n        if (typeof source === \"function\")\n          interpolate.source((p0 = source.apply(this, arguments)));\n        if (typeof target === \"function\")\n          interpolate.target((p1 = target.apply(this, arguments)));\n        return interpolate.distance();\n      };\n      greatArc.source = function (_) {\n        if (!arguments.length) return source;\n        source = _;\n        if (typeof source !== \"function\") interpolate.source((p0 = source));\n        return greatArc;\n      };\n      greatArc.target = function (_) {\n        if (!arguments.length) return target;\n        target = _;\n        if (typeof target !== \"function\") interpolate.target((p1 = target));\n        return greatArc;\n      };\n      greatArc.precision = function (_) {\n        if (!arguments.length) return precision / d3_geo_radians;\n        precision = _ * d3_geo_radians;\n        return greatArc;\n      };\n      return greatArc;\n    };\n    d3.geo.greatCircle = d3.geo.circle;\n    d3.geom = {};\n    d3.geom.contour = function (grid, start) {\n      var s = start || d3_geom_contourStart(grid),\n        c = [],\n        x = s[0],\n        y = s[1],\n        dx = 0,\n        dy = 0,\n        pdx = NaN,\n        pdy = NaN,\n        i = 0;\n      do {\n        i = 0;\n        if (grid(x - 1, y - 1)) i += 1;\n        if (grid(x, y - 1)) i += 2;\n        if (grid(x - 1, y)) i += 4;\n        if (grid(x, y)) i += 8;\n        if (i === 6) {\n          dx = pdy === -1 ? -1 : 1;\n          dy = 0;\n        } else if (i === 9) {\n          dx = 0;\n          dy = pdx === 1 ? -1 : 1;\n        } else {\n          dx = d3_geom_contourDx[i];\n          dy = d3_geom_contourDy[i];\n        }\n        if (dx != pdx && dy != pdy) {\n          c.push([x, y]);\n          pdx = dx;\n          pdy = dy;\n        }\n        x += dx;\n        y += dy;\n      } while (s[0] != x || s[1] != y);\n      return c;\n    };\n    var d3_geom_contourDx = [\n        1,\n        0,\n        1,\n        1,\n        -1,\n        0,\n        -1,\n        1,\n        0,\n        0,\n        0,\n        0,\n        -1,\n        0,\n        -1,\n        NaN,\n      ],\n      d3_geom_contourDy = [\n        0,\n        -1,\n        0,\n        0,\n        0,\n        -1,\n        0,\n        0,\n        1,\n        -1,\n        1,\n        1,\n        0,\n        -1,\n        0,\n        NaN,\n      ];\n    d3.geom.hull = function (vertices) {\n      if (vertices.length < 3) return [];\n      var len = vertices.length,\n        plen = len - 1,\n        points = [],\n        stack = [],\n        i,\n        j,\n        h = 0,\n        x1,\n        y1,\n        x2,\n        y2,\n        u,\n        v,\n        a,\n        sp;\n      for (i = 1; i < len; ++i) {\n        if (vertices[i][1] < vertices[h][1]) {\n          h = i;\n        } else if (vertices[i][1] == vertices[h][1]) {\n          h = vertices[i][0] < vertices[h][0] ? i : h;\n        }\n      }\n      for (i = 0; i < len; ++i) {\n        if (i === h) continue;\n        y1 = vertices[i][1] - vertices[h][1];\n        x1 = vertices[i][0] - vertices[h][0];\n        points.push({\n          angle: Math.atan2(y1, x1),\n          index: i,\n        });\n      }\n      points.sort(function (a, b) {\n        return a.angle - b.angle;\n      });\n      a = points[0].angle;\n      v = points[0].index;\n      u = 0;\n      for (i = 1; i < plen; ++i) {\n        j = points[i].index;\n        if (a == points[i].angle) {\n          x1 = vertices[v][0] - vertices[h][0];\n          y1 = vertices[v][1] - vertices[h][1];\n          x2 = vertices[j][0] - vertices[h][0];\n          y2 = vertices[j][1] - vertices[h][1];\n          if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {\n            points[i].index = -1;\n          } else {\n            points[u].index = -1;\n            a = points[i].angle;\n            u = i;\n            v = j;\n          }\n        } else {\n          a = points[i].angle;\n          u = i;\n          v = j;\n        }\n      }\n      stack.push(h);\n      for (i = 0, j = 0; i < 2; ++j) {\n        if (points[j].index !== -1) {\n          stack.push(points[j].index);\n          i++;\n        }\n      }\n      sp = stack.length;\n      for (; j < plen; ++j) {\n        if (points[j].index === -1) continue;\n        while (\n          !d3_geom_hullCCW(\n            stack[sp - 2],\n            stack[sp - 1],\n            points[j].index,\n            vertices\n          )\n        ) {\n          --sp;\n        }\n        stack[sp++] = points[j].index;\n      }\n      var poly = [];\n      for (i = 0; i < sp; ++i) {\n        poly.push(vertices[stack[i]]);\n      }\n      return poly;\n    };\n    d3.geom.polygon = function (coordinates) {\n      coordinates.area = function () {\n        var i = 0,\n          n = coordinates.length,\n          a = coordinates[n - 1][0] * coordinates[0][1],\n          b = coordinates[n - 1][1] * coordinates[0][0];\n        while (++i < n) {\n          a += coordinates[i - 1][0] * coordinates[i][1];\n          b += coordinates[i - 1][1] * coordinates[i][0];\n        }\n        return (b - a) * 0.5;\n      };\n      coordinates.centroid = function (k) {\n        var i = -1,\n          n = coordinates.length,\n          x = 0,\n          y = 0,\n          a,\n          b = coordinates[n - 1],\n          c;\n        if (!arguments.length) k = -1 / (6 * coordinates.area());\n        while (++i < n) {\n          a = b;\n          b = coordinates[i];\n          c = a[0] * b[1] - b[0] * a[1];\n          x += (a[0] + b[0]) * c;\n          y += (a[1] + b[1]) * c;\n        }\n        return [x * k, y * k];\n      };\n      coordinates.clip = function (subject) {\n        var input,\n          i = -1,\n          n = coordinates.length,\n          j,\n          m,\n          a = coordinates[n - 1],\n          b,\n          c,\n          d;\n        while (++i < n) {\n          input = subject.slice();\n          subject.length = 0;\n          b = coordinates[i];\n          c = input[(m = input.length) - 1];\n          j = -1;\n          while (++j < m) {\n            d = input[j];\n            if (d3_geom_polygonInside(d, a, b)) {\n              if (!d3_geom_polygonInside(c, a, b)) {\n                subject.push(d3_geom_polygonIntersect(c, d, a, b));\n              }\n              subject.push(d);\n            } else if (d3_geom_polygonInside(c, a, b)) {\n              subject.push(d3_geom_polygonIntersect(c, d, a, b));\n            }\n            c = d;\n          }\n          a = b;\n        }\n        return subject;\n      };\n      return coordinates;\n    };\n    d3.geom.voronoi = function (vertices) {\n      var polygons = vertices.map(function () {\n        return [];\n      });\n      d3_voronoi_tessellate(vertices, function (e) {\n        var s1, s2, x1, x2, y1, y2;\n        if (e.a === 1 && e.b >= 0) {\n          s1 = e.ep.r;\n          s2 = e.ep.l;\n        } else {\n          s1 = e.ep.l;\n          s2 = e.ep.r;\n        }\n        if (e.a === 1) {\n          y1 = s1 ? s1.y : -1e6;\n          x1 = e.c - e.b * y1;\n          y2 = s2 ? s2.y : 1e6;\n          x2 = e.c - e.b * y2;\n        } else {\n          x1 = s1 ? s1.x : -1e6;\n          y1 = e.c - e.a * x1;\n          x2 = s2 ? s2.x : 1e6;\n          y2 = e.c - e.a * x2;\n        }\n        var v1 = [x1, y1],\n          v2 = [x2, y2];\n        polygons[e.region.l.index].push(v1, v2);\n        polygons[e.region.r.index].push(v1, v2);\n      });\n      return polygons.map(function (polygon, i) {\n        var cx = vertices[i][0],\n          cy = vertices[i][1];\n        polygon.forEach(function (v) {\n          v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n        });\n        return polygon\n          .sort(function (a, b) {\n            return a.angle - b.angle;\n          })\n          .filter(function (d, i) {\n            return !i || d.angle - polygon[i - 1].angle > 1e-10;\n          });\n      });\n    };\n    var d3_voronoi_opposite = {\n      l: \"r\",\n      r: \"l\",\n    };\n    d3.geom.delaunay = function (vertices) {\n      var edges = vertices.map(function () {\n          return [];\n        }),\n        triangles = [];\n      d3_voronoi_tessellate(vertices, function (e) {\n        edges[e.region.l.index].push(vertices[e.region.r.index]);\n      });\n      edges.forEach(function (edge, i) {\n        var v = vertices[i],\n          cx = v[0],\n          cy = v[1];\n        edge.forEach(function (v) {\n          v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n        });\n        edge.sort(function (a, b) {\n          return a.angle - b.angle;\n        });\n        for (var j = 0, m = edge.length - 1; j < m; j++) {\n          triangles.push([v, edge[j], edge[j + 1]]);\n        }\n      });\n      return triangles;\n    };\n    d3.geom.quadtree = function (points, x1, y1, x2, y2) {\n      function insert(n, p, x1, y1, x2, y2) {\n        if (isNaN(p.x) || isNaN(p.y)) return;\n        if (n.leaf) {\n          var v = n.point;\n          if (v) {\n            if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < 0.01) {\n              insertChild(n, p, x1, y1, x2, y2);\n            } else {\n              n.point = null;\n              insertChild(n, v, x1, y1, x2, y2);\n              insertChild(n, p, x1, y1, x2, y2);\n            }\n          } else {\n            n.point = p;\n          }\n        } else {\n          insertChild(n, p, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, p, x1, y1, x2, y2) {\n        var sx = (x1 + x2) * 0.5,\n          sy = (y1 + y2) * 0.5,\n          right = p.x >= sx,\n          bottom = p.y >= sy,\n          i = (bottom << 1) + right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = sx;\n        else x2 = sx;\n        if (bottom) y1 = sy;\n        else y2 = sy;\n        insert(n, p, x1, y1, x2, y2);\n      }\n      var p,\n        i = -1,\n        n = points.length;\n      if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);\n      if (arguments.length < 5) {\n        if (arguments.length === 3) {\n          y2 = x2 = y1;\n          y1 = x1;\n        } else {\n          x1 = y1 = Infinity;\n          x2 = y2 = -Infinity;\n          while (++i < n) {\n            p = points[i];\n            if (p.x < x1) x1 = p.x;\n            if (p.y < y1) y1 = p.y;\n            if (p.x > x2) x2 = p.x;\n            if (p.y > y2) y2 = p.y;\n          }\n          var dx = x2 - x1,\n            dy = y2 - y1;\n          if (dx > dy) y2 = y1 + dx;\n          else x2 = x1 + dy;\n        }\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function (p) {\n        insert(root, p, x1, y1, x2, y2);\n      };\n      root.visit = function (f) {\n        d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\n      };\n      points.forEach(root.add);\n      return root;\n    };\n    d3.time = {};\n    var d3_time = Date,\n      d3_time_daySymbols = [\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\",\n      ];\n    d3_time_utc.prototype = {\n      getDate: function () {\n        return this._.getUTCDate();\n      },\n      getDay: function () {\n        return this._.getUTCDay();\n      },\n      getFullYear: function () {\n        return this._.getUTCFullYear();\n      },\n      getHours: function () {\n        return this._.getUTCHours();\n      },\n      getMilliseconds: function () {\n        return this._.getUTCMilliseconds();\n      },\n      getMinutes: function () {\n        return this._.getUTCMinutes();\n      },\n      getMonth: function () {\n        return this._.getUTCMonth();\n      },\n      getSeconds: function () {\n        return this._.getUTCSeconds();\n      },\n      getTime: function () {\n        return this._.getTime();\n      },\n      getTimezoneOffset: function () {\n        return 0;\n      },\n      valueOf: function () {\n        return this._.valueOf();\n      },\n      setDate: function () {\n        d3_time_prototype.setUTCDate.apply(this._, arguments);\n      },\n      setDay: function () {\n        d3_time_prototype.setUTCDay.apply(this._, arguments);\n      },\n      setFullYear: function () {\n        d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n      },\n      setHours: function () {\n        d3_time_prototype.setUTCHours.apply(this._, arguments);\n      },\n      setMilliseconds: function () {\n        d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n      },\n      setMinutes: function () {\n        d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n      },\n      setMonth: function () {\n        d3_time_prototype.setUTCMonth.apply(this._, arguments);\n      },\n      setSeconds: function () {\n        d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n      },\n      setTime: function () {\n        d3_time_prototype.setTime.apply(this._, arguments);\n      },\n    };\n    var d3_time_prototype = Date.prototype;\n    var d3_time_formatDateTime = \"%a %b %e %H:%M:%S %Y\",\n      d3_time_formatDate = \"%m/%d/%y\",\n      d3_time_formatTime = \"%H:%M:%S\";\n    var d3_time_days = d3_time_daySymbols,\n      d3_time_dayAbbreviations = d3_time_days.map(d3_time_formatAbbreviate),\n      d3_time_months = [\n        \"January\",\n        \"February\",\n        \"March\",\n        \"April\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"August\",\n        \"September\",\n        \"October\",\n        \"November\",\n        \"December\",\n      ],\n      d3_time_monthAbbreviations = d3_time_months.map(d3_time_formatAbbreviate);\n    d3.time.format = function (template) {\n      function format(date) {\n        var string = [],\n          i = -1,\n          j = 0,\n          c,\n          f;\n        while (++i < n) {\n          if (template.charCodeAt(i) == 37) {\n            string.push(\n              template.substring(j, i),\n              (f = d3_time_formats[(c = template.charAt(++i))]) ? f(date) : c\n            );\n            j = i + 1;\n          }\n        }\n        string.push(template.substring(j, i));\n        return string.join(\"\");\n      }\n      var n = template.length;\n      format.parse = function (string) {\n        var d = {\n            y: 1900,\n            m: 0,\n            d: 1,\n            H: 0,\n            M: 0,\n            S: 0,\n            L: 0,\n          },\n          i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if (\"p\" in d) d.H = (d.H % 12) + d.p * 12;\n        var date = new d3_time();\n        date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H, d.M, d.S, d.L);\n        return date;\n      };\n      format.toString = function () {\n        return template;\n      };\n      return format;\n    };\n    var d3_time_zfill2 = d3.format(\"02d\"),\n      d3_time_zfill3 = d3.format(\"03d\"),\n      d3_time_zfill4 = d3.format(\"04d\"),\n      d3_time_sfill2 = d3.format(\"2d\");\n    var d3_time_dayRe = d3_time_formatRe(d3_time_days),\n      d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations),\n      d3_time_monthRe = d3_time_formatRe(d3_time_months),\n      d3_time_monthLookup = d3_time_formatLookup(d3_time_months),\n      d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations),\n      d3_time_monthAbbrevLookup = d3_time_formatLookup(\n        d3_time_monthAbbreviations\n      );\n    var d3_time_formats = {\n      a: function (d) {\n        return d3_time_dayAbbreviations[d.getDay()];\n      },\n      A: function (d) {\n        return d3_time_days[d.getDay()];\n      },\n      b: function (d) {\n        return d3_time_monthAbbreviations[d.getMonth()];\n      },\n      B: function (d) {\n        return d3_time_months[d.getMonth()];\n      },\n      c: d3.time.format(d3_time_formatDateTime),\n      d: function (d) {\n        return d3_time_zfill2(d.getDate());\n      },\n      e: function (d) {\n        return d3_time_sfill2(d.getDate());\n      },\n      H: function (d) {\n        return d3_time_zfill2(d.getHours());\n      },\n      I: function (d) {\n        return d3_time_zfill2(d.getHours() % 12 || 12);\n      },\n      j: function (d) {\n        return d3_time_zfill3(1 + d3.time.dayOfYear(d));\n      },\n      L: function (d) {\n        return d3_time_zfill3(d.getMilliseconds());\n      },\n      m: function (d) {\n        return d3_time_zfill2(d.getMonth() + 1);\n      },\n      M: function (d) {\n        return d3_time_zfill2(d.getMinutes());\n      },\n      p: function (d) {\n        return d.getHours() >= 12 ? \"PM\" : \"AM\";\n      },\n      S: function (d) {\n        return d3_time_zfill2(d.getSeconds());\n      },\n      U: function (d) {\n        return d3_time_zfill2(d3.time.sundayOfYear(d));\n      },\n      w: function (d) {\n        return d.getDay();\n      },\n      W: function (d) {\n        return d3_time_zfill2(d3.time.mondayOfYear(d));\n      },\n      x: d3.time.format(d3_time_formatDate),\n      X: d3.time.format(d3_time_formatTime),\n      y: function (d) {\n        return d3_time_zfill2(d.getFullYear() % 100);\n      },\n      Y: function (d) {\n        return d3_time_zfill4(d.getFullYear() % 1e4);\n      },\n      Z: d3_time_zone,\n      \"%\": function (d) {\n        return \"%\";\n      },\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n    };\n    var d3_time_numberRe = /^\\s*\\d+/;\n    var d3_time_amPmLookup = d3.map({\n      am: 0,\n      pm: 1,\n    });\n    d3.time.format.utc = function (template) {\n      function format(date) {\n        try {\n          d3_time = d3_time_utc;\n          var utc = new d3_time();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_time = Date;\n        }\n      }\n      var local = d3.time.format(template);\n      format.parse = function (string) {\n        try {\n          d3_time = d3_time_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_time = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    var d3_time_formatIso = d3.time.format.utc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n    d3.time.format.iso = Date.prototype.toISOString\n      ? d3_time_formatIsoNative\n      : d3_time_formatIso;\n    d3_time_formatIsoNative.parse = function (string) {\n      var date = new Date(string);\n      return isNaN(date) ? null : date;\n    };\n    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n    d3.time.second = d3_time_interval(\n      function (date) {\n        return new d3_time(Math.floor(date / 1e3) * 1e3);\n      },\n      function (date, offset) {\n        date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n      },\n      function (date) {\n        return date.getSeconds();\n      }\n    );\n    d3.time.seconds = d3.time.second.range;\n    d3.time.seconds.utc = d3.time.second.utc.range;\n    d3.time.minute = d3_time_interval(\n      function (date) {\n        return new d3_time(Math.floor(date / 6e4) * 6e4);\n      },\n      function (date, offset) {\n        date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n      },\n      function (date) {\n        return date.getMinutes();\n      }\n    );\n    d3.time.minutes = d3.time.minute.range;\n    d3.time.minutes.utc = d3.time.minute.utc.range;\n    d3.time.hour = d3_time_interval(\n      function (date) {\n        var timezone = date.getTimezoneOffset() / 60;\n        return new d3_time(\n          (Math.floor(date / 36e5 - timezone) + timezone) * 36e5\n        );\n      },\n      function (date, offset) {\n        date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n      },\n      function (date) {\n        return date.getHours();\n      }\n    );\n    d3.time.hours = d3.time.hour.range;\n    d3.time.hours.utc = d3.time.hour.utc.range;\n    d3.time.day = d3_time_interval(\n      function (date) {\n        var day = new d3_time(1970, 0);\n        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n        return day;\n      },\n      function (date, offset) {\n        date.setDate(date.getDate() + offset);\n      },\n      function (date) {\n        return date.getDate() - 1;\n      }\n    );\n    d3.time.days = d3.time.day.range;\n    d3.time.days.utc = d3.time.day.utc.range;\n    d3.time.dayOfYear = function (date) {\n      var year = d3.time.year(date);\n      return Math.floor(\n        (date -\n          year -\n          (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) /\n          864e5\n      );\n    };\n    d3_time_daySymbols.forEach(function (day, i) {\n      day = day.toLowerCase();\n      i = 7 - i;\n      var interval = (d3.time[day] = d3_time_interval(\n        function (date) {\n          (date = d3.time.day(date)).setDate(\n            date.getDate() - ((date.getDay() + i) % 7)\n          );\n          return date;\n        },\n        function (date, offset) {\n          date.setDate(date.getDate() + Math.floor(offset) * 7);\n        },\n        function (date) {\n          var day = d3.time.year(date).getDay();\n          return (\n            Math.floor((d3.time.dayOfYear(date) + ((day + i) % 7)) / 7) -\n            (day !== i)\n          );\n        }\n      ));\n      d3.time[day + \"s\"] = interval.range;\n      d3.time[day + \"s\"].utc = interval.utc.range;\n      d3.time[day + \"OfYear\"] = function (date) {\n        var day = d3.time.year(date).getDay();\n        return Math.floor((d3.time.dayOfYear(date) + ((day + i) % 7)) / 7);\n      };\n    });\n    d3.time.week = d3.time.sunday;\n    d3.time.weeks = d3.time.sunday.range;\n    d3.time.weeks.utc = d3.time.sunday.utc.range;\n    d3.time.weekOfYear = d3.time.sundayOfYear;\n    d3.time.month = d3_time_interval(\n      function (date) {\n        date = d3.time.day(date);\n        date.setDate(1);\n        return date;\n      },\n      function (date, offset) {\n        date.setMonth(date.getMonth() + offset);\n      },\n      function (date) {\n        return date.getMonth();\n      }\n    );\n    d3.time.months = d3.time.month.range;\n    d3.time.months.utc = d3.time.month.utc.range;\n    d3.time.year = d3_time_interval(\n      function (date) {\n        date = d3.time.day(date);\n        date.setMonth(0, 1);\n        return date;\n      },\n      function (date, offset) {\n        date.setFullYear(date.getFullYear() + offset);\n      },\n      function (date) {\n        return date.getFullYear();\n      }\n    );\n    d3.time.years = d3.time.year.range;\n    d3.time.years.utc = d3.time.year.utc.range;\n    var d3_time_scaleSteps = [\n      1e3,\n      5e3,\n      15e3,\n      3e4,\n      6e4,\n      3e5,\n      9e5,\n      18e5,\n      36e5,\n      108e5,\n      216e5,\n      432e5,\n      864e5,\n      1728e5,\n      6048e5,\n      2592e6,\n      7776e6,\n      31536e6,\n    ];\n    var d3_time_scaleLocalMethods = [\n      [d3.time.second, 1],\n      [d3.time.second, 5],\n      [d3.time.second, 15],\n      [d3.time.second, 30],\n      [d3.time.minute, 1],\n      [d3.time.minute, 5],\n      [d3.time.minute, 15],\n      [d3.time.minute, 30],\n      [d3.time.hour, 1],\n      [d3.time.hour, 3],\n      [d3.time.hour, 6],\n      [d3.time.hour, 12],\n      [d3.time.day, 1],\n      [d3.time.day, 2],\n      [d3.time.week, 1],\n      [d3.time.month, 1],\n      [d3.time.month, 3],\n      [d3.time.year, 1],\n    ];\n    var d3_time_scaleLocalFormats = [\n      [\n        d3.time.format(\"%Y\"),\n        function (d) {\n          return true;\n        },\n      ],\n      [\n        d3.time.format(\"%B\"),\n        function (d) {\n          return d.getMonth();\n        },\n      ],\n      [\n        d3.time.format(\"%b %d\"),\n        function (d) {\n          return d.getDate() != 1;\n        },\n      ],\n      [\n        d3.time.format(\"%a %d\"),\n        function (d) {\n          return d.getDay() && d.getDate() != 1;\n        },\n      ],\n      [\n        d3.time.format(\"%I %p\"),\n        function (d) {\n          return d.getHours();\n        },\n      ],\n      [\n        d3.time.format(\"%I:%M\"),\n        function (d) {\n          return d.getMinutes();\n        },\n      ],\n      [\n        d3.time.format(\":%S\"),\n        function (d) {\n          return d.getSeconds();\n        },\n      ],\n      [\n        d3.time.format(\".%L\"),\n        function (d) {\n          return d.getMilliseconds();\n        },\n      ],\n    ];\n    var d3_time_scaleLinear = d3.scale.linear(),\n      d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);\n    d3_time_scaleLocalMethods.year = function (extent, m) {\n      return d3_time_scaleLinear\n        .domain(extent.map(d3_time_scaleGetYear))\n        .ticks(m)\n        .map(d3_time_scaleSetYear);\n    };\n    d3.time.scale = function () {\n      return d3_time_scale(\n        d3.scale.linear(),\n        d3_time_scaleLocalMethods,\n        d3_time_scaleLocalFormat\n      );\n    };\n    var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function (m) {\n      return [m[0].utc, m[1]];\n    });\n    var d3_time_scaleUTCFormats = [\n      [\n        d3.time.format.utc(\"%Y\"),\n        function (d) {\n          return true;\n        },\n      ],\n      [\n        d3.time.format.utc(\"%B\"),\n        function (d) {\n          return d.getUTCMonth();\n        },\n      ],\n      [\n        d3.time.format.utc(\"%b %d\"),\n        function (d) {\n          return d.getUTCDate() != 1;\n        },\n      ],\n      [\n        d3.time.format.utc(\"%a %d\"),\n        function (d) {\n          return d.getUTCDay() && d.getUTCDate() != 1;\n        },\n      ],\n      [\n        d3.time.format.utc(\"%I %p\"),\n        function (d) {\n          return d.getUTCHours();\n        },\n      ],\n      [\n        d3.time.format.utc(\"%I:%M\"),\n        function (d) {\n          return d.getUTCMinutes();\n        },\n      ],\n      [\n        d3.time.format.utc(\":%S\"),\n        function (d) {\n          return d.getUTCSeconds();\n        },\n      ],\n      [\n        d3.time.format.utc(\".%L\"),\n        function (d) {\n          return d.getUTCMilliseconds();\n        },\n      ],\n    ];\n    var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);\n    d3_time_scaleUTCMethods.year = function (extent, m) {\n      return d3_time_scaleLinear\n        .domain(extent.map(d3_time_scaleUTCGetYear))\n        .ticks(m)\n        .map(d3_time_scaleUTCSetYear);\n    };\n    d3.time.scale.utc = function () {\n      return d3_time_scale(\n        d3.scale.linear(),\n        d3_time_scaleUTCMethods,\n        d3_time_scaleUTCFormat\n      );\n    };\n  })();\n</script>\n\n<script>\n  //     Underscore.js 1.12.0\n  //     https://underscorejs.org\n  //     (c) 2009-2020 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n  //     Underscore may be freely distributed under the MIT license.\n  (function (global, factory) {\n    typeof exports === \"object\" && typeof module !== \"undefined\"\n      ? (module.exports = factory())\n      : typeof define === \"function\" && define.amd\n      ? define(\"underscore\", factory)\n      : ((global = global || self),\n        (function () {\n          var current = global._;\n          var exports = (global._ = factory());\n          exports.noConflict = function () {\n            global._ = current;\n            return exports;\n          };\n        })());\n  })(this, function () {\n\n    var VERSION = \"1.12.0\";\n\n    var root =\n      (typeof self == \"object\" && self.self === self && self) ||\n      (typeof global == \"object\" && global.global === global && global) ||\n      Function(\"return this\")() ||\n      {};\n\n    var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype;\n    var SymbolProto = typeof Symbol !== \"undefined\" ? Symbol.prototype : null;\n\n    var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n    var supportsArrayBuffer = typeof ArrayBuffer !== \"undefined\",\n      supportsDataView = typeof DataView !== \"undefined\";\n\n    var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create,\n      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;\n\n    var _isNaN = isNaN,\n      _isFinite = isFinite;\n\n    var hasEnumBug = !{ toString: null }.propertyIsEnumerable(\"toString\");\n    var nonEnumerableProps = [\n      \"valueOf\",\n      \"isPrototypeOf\",\n      \"toString\",\n      \"propertyIsEnumerable\",\n      \"hasOwnProperty\",\n      \"toLocaleString\",\n    ];\n\n    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n    function restArguments(func, startIndex) {\n      startIndex = startIndex == null ? func.length - 1 : +startIndex;\n      return function () {\n        var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n        for (; index < length; index++) {\n          rest[index] = arguments[index + startIndex];\n        }\n        switch (startIndex) {\n          case 0:\n            return func.call(this, rest);\n          case 1:\n            return func.call(this, arguments[0], rest);\n          case 2:\n            return func.call(this, arguments[0], arguments[1], rest);\n        }\n        var args = Array(startIndex + 1);\n        for (index = 0; index < startIndex; index++) {\n          args[index] = arguments[index];\n        }\n        args[startIndex] = rest;\n        return func.apply(this, args);\n      };\n    }\n\n    function isObject(obj) {\n      var type = typeof obj;\n      return type === \"function\" || (type === \"object\" && !!obj);\n    }\n\n    function isNull(obj) {\n      return obj === null;\n    }\n\n    function isUndefined(obj) {\n      return obj === void 0;\n    }\n\n    function isBoolean(obj) {\n      return (\n        obj === true ||\n        obj === false ||\n        toString.call(obj) === \"[object Boolean]\"\n      );\n    }\n\n    function isElement(obj) {\n      return !!(obj && obj.nodeType === 1);\n    }\n\n    function tagTester(name) {\n      var tag = \"[object \" + name + \"]\";\n      return function (obj) {\n        return toString.call(obj) === tag;\n      };\n    }\n\n    var isString = tagTester(\"String\");\n\n    var isNumber = tagTester(\"Number\");\n\n    var isDate = tagTester(\"Date\");\n\n    var isRegExp = tagTester(\"RegExp\");\n\n    var isError = tagTester(\"Error\");\n\n    var isSymbol = tagTester(\"Symbol\");\n\n    var isArrayBuffer = tagTester(\"ArrayBuffer\");\n\n    var isFunction = tagTester(\"Function\");\n\n    var nodelist = root.document && root.document.childNodes;\n    if (\n      typeof /./ != \"function\" &&\n      typeof Int8Array != \"object\" &&\n      typeof nodelist != \"function\"\n    ) {\n      isFunction = function (obj) {\n        return typeof obj == \"function\" || false;\n      };\n    }\n\n    var isFunction$1 = isFunction;\n\n    var hasObjectTag = tagTester(\"Object\");\n\n    var hasStringTagBug =\n        supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))),\n      isIE11 = typeof Map !== \"undefined\" && hasObjectTag(new Map());\n\n    var isDataView = tagTester(\"DataView\");\n\n    function ie10IsDataView(obj) {\n      return (\n        obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer)\n      );\n    }\n\n    var isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;\n\n    var isArray = nativeIsArray || tagTester(\"Array\");\n\n    function has(obj, key) {\n      return obj != null && hasOwnProperty.call(obj, key);\n    }\n\n    var isArguments = tagTester(\"Arguments\");\n\n    (function () {\n      if (!isArguments(arguments)) {\n        isArguments = function (obj) {\n          return has(obj, \"callee\");\n        };\n      }\n    })();\n\n    var isArguments$1 = isArguments;\n\n    function isFinite$1(obj) {\n      return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));\n    }\n\n    function isNaN$1(obj) {\n      return isNumber(obj) && _isNaN(obj);\n    }\n\n    function constant(value) {\n      return function () {\n        return value;\n      };\n    }\n\n    function createSizePropertyCheck(getSizeProperty) {\n      return function (collection) {\n        var sizeProperty = getSizeProperty(collection);\n        return (\n          typeof sizeProperty == \"number\" &&\n          sizeProperty >= 0 &&\n          sizeProperty <= MAX_ARRAY_INDEX\n        );\n      };\n    }\n\n    function shallowProperty(key) {\n      return function (obj) {\n        return obj == null ? void 0 : obj[key];\n      };\n    }\n\n    var getByteLength = shallowProperty(\"byteLength\");\n\n    var isBufferLike = createSizePropertyCheck(getByteLength);\n\n    var typedArrayPattern = /\\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\\]/;\n    function isTypedArray(obj) {\n      return nativeIsView\n        ? nativeIsView(obj) && !isDataView$1(obj)\n        : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));\n    }\n\n    var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);\n\n    var getLength = shallowProperty(\"length\");\n\n    function emulatedSet(keys) {\n      var hash = {};\n      for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;\n      return {\n        contains: function (key) {\n          return hash[key];\n        },\n        push: function (key) {\n          hash[key] = true;\n          return keys.push(key);\n        },\n      };\n    }\n\n    function collectNonEnumProps(obj, keys) {\n      keys = emulatedSet(keys);\n      var nonEnumIdx = nonEnumerableProps.length;\n      var constructor = obj.constructor;\n      var proto =\n        (isFunction$1(constructor) && constructor.prototype) || ObjProto;\n\n      var prop = \"constructor\";\n      if (has(obj, prop) && !keys.contains(prop)) keys.push(prop);\n\n      while (nonEnumIdx--) {\n        prop = nonEnumerableProps[nonEnumIdx];\n        if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {\n          keys.push(prop);\n        }\n      }\n    }\n\n    function keys(obj) {\n      if (!isObject(obj)) return [];\n      if (nativeKeys) return nativeKeys(obj);\n      var keys = [];\n      for (var key in obj) if (has(obj, key)) keys.push(key);\n      if (hasEnumBug) collectNonEnumProps(obj, keys);\n      return keys;\n    }\n\n    function isEmpty(obj) {\n      if (obj == null) return true;\n      var length = getLength(obj);\n      if (\n        typeof length == \"number\" &&\n        (isArray(obj) || isString(obj) || isArguments$1(obj))\n      )\n        return length === 0;\n      return getLength(keys(obj)) === 0;\n    }\n\n    function isMatch(object, attrs) {\n      var _keys = keys(attrs),\n        length = _keys.length;\n      if (object == null) return !length;\n      var obj = Object(object);\n      for (var i = 0; i < length; i++) {\n        var key = _keys[i];\n        if (attrs[key] !== obj[key] || !(key in obj)) return false;\n      }\n      return true;\n    }\n\n    function _(obj) {\n      if (obj instanceof _) return obj;\n      if (!(this instanceof _)) return new _(obj);\n      this._wrapped = obj;\n    }\n\n    _.VERSION = VERSION;\n\n    _.prototype.value = function () {\n      return this._wrapped;\n    };\n\n    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n    _.prototype.toString = function () {\n      return String(this._wrapped);\n    };\n\n    function toBufferView(bufferSource) {\n      return new Uint8Array(\n        bufferSource.buffer || bufferSource,\n        bufferSource.byteOffset || 0,\n        getByteLength(bufferSource)\n      );\n    }\n\n    var tagDataView = \"[object DataView]\";\n\n    function eq(a, b, aStack, bStack) {\n      if (a === b) return a !== 0 || 1 / a === 1 / b;\n      if (a == null || b == null) return false;\n      if (a !== a) return b !== b;\n      var type = typeof a;\n      if (type !== \"function\" && type !== \"object\" && typeof b != \"object\")\n        return false;\n      return deepEq(a, b, aStack, bStack);\n    }\n\n    function deepEq(a, b, aStack, bStack) {\n      if (a instanceof _) a = a._wrapped;\n      if (b instanceof _) b = b._wrapped;\n      var className = toString.call(a);\n      if (className !== toString.call(b)) return false;\n      if (\n        hasStringTagBug &&\n        className == \"[object Object]\" &&\n        isDataView$1(a)\n      ) {\n        if (!isDataView$1(b)) return false;\n        className = tagDataView;\n      }\n      switch (className) {\n        case \"[object RegExp]\":\n        case \"[object String]\":\n          return \"\" + a === \"\" + b;\n        case \"[object Number]\":\n          if (+a !== +a) return +b !== +b;\n          return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case \"[object Date]\":\n        case \"[object Boolean]\":\n          return +a === +b;\n        case \"[object Symbol]\":\n          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n        case \"[object ArrayBuffer]\":\n        case tagDataView:\n          return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);\n      }\n\n      var areArrays = className === \"[object Array]\";\n      if (!areArrays && isTypedArray$1(a)) {\n        var byteLength = getByteLength(a);\n        if (byteLength !== getByteLength(b)) return false;\n        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;\n        areArrays = true;\n      }\n      if (!areArrays) {\n        if (typeof a != \"object\" || typeof b != \"object\") return false;\n\n        var aCtor = a.constructor,\n          bCtor = b.constructor;\n        if (\n          aCtor !== bCtor &&\n          !(\n            isFunction$1(aCtor) &&\n            aCtor instanceof aCtor &&\n            isFunction$1(bCtor) &&\n            bCtor instanceof bCtor\n          ) &&\n          \"constructor\" in a &&\n          \"constructor\" in b\n        ) {\n          return false;\n        }\n      }\n      aStack = aStack || [];\n      bStack = bStack || [];\n      var length = aStack.length;\n      while (length--) {\n        if (aStack[length] === a) return bStack[length] === b;\n      }\n\n      aStack.push(a);\n      bStack.push(b);\n\n      if (areArrays) {\n        length = a.length;\n        if (length !== b.length) return false;\n        while (length--) {\n          if (!eq(a[length], b[length], aStack, bStack)) return false;\n        }\n      } else {\n        var _keys = keys(a),\n          key;\n        length = _keys.length;\n        if (keys(b).length !== length) return false;\n        while (length--) {\n          key = _keys[length];\n          if (!(has(b, key) && eq(a[key], b[key], aStack, bStack)))\n            return false;\n        }\n      }\n      aStack.pop();\n      bStack.pop();\n      return true;\n    }\n\n    function isEqual(a, b) {\n      return eq(a, b);\n    }\n\n    function allKeys(obj) {\n      if (!isObject(obj)) return [];\n      var keys = [];\n      for (var key in obj) keys.push(key);\n      if (hasEnumBug) collectNonEnumProps(obj, keys);\n      return keys;\n    }\n\n    function ie11fingerprint(methods) {\n      var length = getLength(methods);\n      return function (obj) {\n        if (obj == null) return false;\n        var keys = allKeys(obj);\n        if (getLength(keys)) return false;\n        for (var i = 0; i < length; i++) {\n          if (!isFunction$1(obj[methods[i]])) return false;\n        }\n        return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);\n      };\n    }\n\n    var forEachName = \"forEach\",\n      hasName = \"has\",\n      commonInit = [\"clear\", \"delete\"],\n      mapTail = [\"get\", hasName, \"set\"];\n\n    var mapMethods = commonInit.concat(forEachName, mapTail),\n      weakMapMethods = commonInit.concat(mapTail),\n      setMethods = [\"add\"].concat(commonInit, forEachName, hasName);\n\n    var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester(\"Map\");\n\n    var isWeakMap = isIE11\n      ? ie11fingerprint(weakMapMethods)\n      : tagTester(\"WeakMap\");\n\n    var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester(\"Set\");\n\n    var isWeakSet = tagTester(\"WeakSet\");\n\n    function values(obj) {\n      var _keys = keys(obj);\n      var length = _keys.length;\n      var values = Array(length);\n      for (var i = 0; i < length; i++) {\n        values[i] = obj[_keys[i]];\n      }\n      return values;\n    }\n\n    function pairs(obj) {\n      var _keys = keys(obj);\n      var length = _keys.length;\n      var pairs = Array(length);\n      for (var i = 0; i < length; i++) {\n        pairs[i] = [_keys[i], obj[_keys[i]]];\n      }\n      return pairs;\n    }\n\n    function invert(obj) {\n      var result = {};\n      var _keys = keys(obj);\n      for (var i = 0, length = _keys.length; i < length; i++) {\n        result[obj[_keys[i]]] = _keys[i];\n      }\n      return result;\n    }\n\n    function functions(obj) {\n      var names = [];\n      for (var key in obj) {\n        if (isFunction$1(obj[key])) names.push(key);\n      }\n      return names.sort();\n    }\n\n    function createAssigner(keysFunc, defaults) {\n      return function (obj) {\n        var length = arguments.length;\n        if (defaults) obj = Object(obj);\n        if (length < 2 || obj == null) return obj;\n        for (var index = 1; index < length; index++) {\n          var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n          for (var i = 0; i < l; i++) {\n            var key = keys[i];\n            if (!defaults || obj[key] === void 0) obj[key] = source[key];\n          }\n        }\n        return obj;\n      };\n    }\n\n    var extend = createAssigner(allKeys);\n\n    var extendOwn = createAssigner(keys);\n\n    var defaults = createAssigner(allKeys, true);\n\n    function ctor() {\n      return function () {};\n    }\n\n    function baseCreate(prototype) {\n      if (!isObject(prototype)) return {};\n      if (nativeCreate) return nativeCreate(prototype);\n      var Ctor = ctor();\n      Ctor.prototype = prototype;\n      var result = new Ctor();\n      Ctor.prototype = null;\n      return result;\n    }\n\n    function create(prototype, props) {\n      var result = baseCreate(prototype);\n      if (props) extendOwn(result, props);\n      return result;\n    }\n\n    function clone(obj) {\n      if (!isObject(obj)) return obj;\n      return isArray(obj) ? obj.slice() : extend({}, obj);\n    }\n\n    function tap(obj, interceptor) {\n      interceptor(obj);\n      return obj;\n    }\n\n    function toPath(path) {\n      return isArray(path) ? path : [path];\n    }\n    _.toPath = toPath;\n\n    function toPath$1(path) {\n      return _.toPath(path);\n    }\n\n    function deepGet(obj, path) {\n      var length = path.length;\n      for (var i = 0; i < length; i++) {\n        if (obj == null) return void 0;\n        obj = obj[path[i]];\n      }\n      return length ? obj : void 0;\n    }\n\n    function get(object, path, defaultValue) {\n      var value = deepGet(object, toPath$1(path));\n      return isUndefined(value) ? defaultValue : value;\n    }\n\n    function has$1(obj, path) {\n      path = toPath$1(path);\n      var length = path.length;\n      for (var i = 0; i < length; i++) {\n        var key = path[i];\n        if (!has(obj, key)) return false;\n        obj = obj[key];\n      }\n      return !!length;\n    }\n\n    function identity(value) {\n      return value;\n    }\n\n    function matcher(attrs) {\n      attrs = extendOwn({}, attrs);\n      return function (obj) {\n        return isMatch(obj, attrs);\n      };\n    }\n\n    function property(path) {\n      path = toPath$1(path);\n      return function (obj) {\n        return deepGet(obj, path);\n      };\n    }\n\n    function optimizeCb(func, context, argCount) {\n      if (context === void 0) return func;\n      switch (argCount == null ? 3 : argCount) {\n        case 1:\n          return function (value) {\n            return func.call(context, value);\n          };\n        case 3:\n          return function (value, index, collection) {\n            return func.call(context, value, index, collection);\n          };\n        case 4:\n          return function (accumulator, value, index, collection) {\n            return func.call(context, accumulator, value, index, collection);\n          };\n      }\n      return function () {\n        return func.apply(context, arguments);\n      };\n    }\n\n    function baseIteratee(value, context, argCount) {\n      if (value == null) return identity;\n      if (isFunction$1(value)) return optimizeCb(value, context, argCount);\n      if (isObject(value) && !isArray(value)) return matcher(value);\n      return property(value);\n    }\n\n    function iteratee(value, context) {\n      return baseIteratee(value, context, Infinity);\n    }\n    _.iteratee = iteratee;\n\n    function cb(value, context, argCount) {\n      if (_.iteratee !== iteratee) return _.iteratee(value, context);\n      return baseIteratee(value, context, argCount);\n    }\n\n    function mapObject(obj, iteratee, context) {\n      iteratee = cb(iteratee, context);\n      var _keys = keys(obj),\n        length = _keys.length,\n        results = {};\n      for (var index = 0; index < length; index++) {\n        var currentKey = _keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n    }\n\n    function noop() {}\n\n    function propertyOf(obj) {\n      if (obj == null) return noop;\n      return function (path) {\n        return get(obj, path);\n      };\n    }\n\n    function times(n, iteratee, context) {\n      var accum = Array(Math.max(0, n));\n      iteratee = optimizeCb(iteratee, context, 1);\n      for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n      return accum;\n    }\n\n    function random(min, max) {\n      if (max == null) {\n        max = min;\n        min = 0;\n      }\n      return min + Math.floor(Math.random() * (max - min + 1));\n    }\n\n    var now =\n      Date.now ||\n      function () {\n        return new Date().getTime();\n      };\n\n    function createEscaper(map) {\n      var escaper = function (match) {\n        return map[match];\n      };\n      var source = \"(?:\" + keys(map).join(\"|\") + \")\";\n      var testRegexp = RegExp(source);\n      var replaceRegexp = RegExp(source, \"g\");\n      return function (string) {\n        string = string == null ? \"\" : \"\" + string;\n        return testRegexp.test(string)\n          ? string.replace(replaceRegexp, escaper)\n          : string;\n      };\n    }\n\n    var escapeMap = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#x27;\",\n      \"`\": \"&#x60;\",\n    };\n\n    var _escape = createEscaper(escapeMap);\n\n    var unescapeMap = invert(escapeMap);\n\n    var _unescape = createEscaper(unescapeMap);\n\n    var templateSettings = (_.templateSettings = {\n      evaluate: /<%([\\s\\S]+?)%>/g,\n      interpolate: /<%=([\\s\\S]+?)%>/g,\n      escape: /<%-([\\s\\S]+?)%>/g,\n    });\n\n    var noMatch = /(.)^/;\n\n    var escapes = {\n      \"'\": \"'\",\n      \"\\\\\": \"\\\\\",\n      \"\\r\": \"r\",\n      \"\\n\": \"n\",\n      \"\\u2028\": \"u2028\",\n      \"\\u2029\": \"u2029\",\n    };\n\n    var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n    function escapeChar(match) {\n      return \"\\\\\" + escapes[match];\n    }\n\n    function template(text, settings, oldSettings) {\n      if (!settings && oldSettings) settings = oldSettings;\n      settings = defaults({}, settings, _.templateSettings);\n\n      var matcher = RegExp(\n        [\n          (settings.escape || noMatch).source,\n          (settings.interpolate || noMatch).source,\n          (settings.evaluate || noMatch).source,\n        ].join(\"|\") + \"|$\",\n        \"g\"\n      );\n\n      var index = 0;\n      var source = \"__p+='\";\n      text.replace(\n        matcher,\n        function (match, escape, interpolate, evaluate, offset) {\n          source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n          index = offset + match.length;\n\n          if (escape) {\n            source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n          } else if (interpolate) {\n            source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n          } else if (evaluate) {\n            source += \"';\\n\" + evaluate + \"\\n__p+='\";\n          }\n\n          return match;\n        }\n      );\n      source += \"';\\n\";\n\n      if (!settings.variable) source = \"with(obj||{}){\\n\" + source + \"}\\n\";\n\n      source =\n        \"var __t,__p='',__j=Array.prototype.join,\" +\n        \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n        source +\n        \"return __p;\\n\";\n\n      var render;\n      try {\n        render = new Function(settings.variable || \"obj\", \"_\", source);\n      } catch (e) {\n        e.source = source;\n        throw e;\n      }\n\n      var template = function (data) {\n        return render.call(this, data, _);\n      };\n\n      var argument = settings.variable || \"obj\";\n      template.source = \"function(\" + argument + \"){\\n\" + source + \"}\";\n\n      return template;\n    }\n\n    function result(obj, path, fallback) {\n      path = toPath$1(path);\n      var length = path.length;\n      if (!length) {\n        return isFunction$1(fallback) ? fallback.call(obj) : fallback;\n      }\n      for (var i = 0; i < length; i++) {\n        var prop = obj == null ? void 0 : obj[path[i]];\n        if (prop === void 0) {\n          prop = fallback;\n          i = length;\n        }\n        obj = isFunction$1(prop) ? prop.call(obj) : prop;\n      }\n      return obj;\n    }\n\n    var idCounter = 0;\n    function uniqueId(prefix) {\n      var id = ++idCounter + \"\";\n      return prefix ? prefix + id : id;\n    }\n\n    function chain(obj) {\n      var instance = _(obj);\n      instance._chain = true;\n      return instance;\n    }\n\n    function executeBound(\n      sourceFunc,\n      boundFunc,\n      context,\n      callingContext,\n      args\n    ) {\n      if (!(callingContext instanceof boundFunc))\n        return sourceFunc.apply(context, args);\n      var self = baseCreate(sourceFunc.prototype);\n      var result = sourceFunc.apply(self, args);\n      if (isObject(result)) return result;\n      return self;\n    }\n\n    var partial = restArguments(function (func, boundArgs) {\n      var placeholder = partial.placeholder;\n      var bound = function () {\n        var position = 0,\n          length = boundArgs.length;\n        var args = Array(length);\n        for (var i = 0; i < length; i++) {\n          args[i] =\n            boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n        }\n        while (position < arguments.length) args.push(arguments[position++]);\n        return executeBound(func, bound, this, this, args);\n      };\n      return bound;\n    });\n\n    partial.placeholder = _;\n\n    var bind = restArguments(function (func, context, args) {\n      if (!isFunction$1(func))\n        throw new TypeError(\"Bind must be called on a function\");\n      var bound = restArguments(function (callArgs) {\n        return executeBound(func, bound, context, this, args.concat(callArgs));\n      });\n      return bound;\n    });\n\n    var isArrayLike = createSizePropertyCheck(getLength);\n\n    function flatten(input, depth, strict, output) {\n      output = output || [];\n      if (!depth && depth !== 0) {\n        depth = Infinity;\n      } else if (depth <= 0) {\n        return output.concat(input);\n      }\n      var idx = output.length;\n      for (var i = 0, length = getLength(input); i < length; i++) {\n        var value = input[i];\n        if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {\n          if (depth > 1) {\n            flatten(value, depth - 1, strict, output);\n            idx = output.length;\n          } else {\n            var j = 0,\n              len = value.length;\n            while (j < len) output[idx++] = value[j++];\n          }\n        } else if (!strict) {\n          output[idx++] = value;\n        }\n      }\n      return output;\n    }\n\n    var bindAll = restArguments(function (obj, keys) {\n      keys = flatten(keys, false, false);\n      var index = keys.length;\n      if (index < 1) throw new Error(\"bindAll must be passed function names\");\n      while (index--) {\n        var key = keys[index];\n        obj[key] = bind(obj[key], obj);\n      }\n      return obj;\n    });\n\n    function memoize(func, hasher) {\n      var memoize = function (key) {\n        var cache = memoize.cache;\n        var address = \"\" + (hasher ? hasher.apply(this, arguments) : key);\n        if (!has(cache, address)) cache[address] = func.apply(this, arguments);\n        return cache[address];\n      };\n      memoize.cache = {};\n      return memoize;\n    }\n\n    var delay = restArguments(function (func, wait, args) {\n      return setTimeout(function () {\n        return func.apply(null, args);\n      }, wait);\n    });\n\n    var defer = partial(delay, _, 1);\n\n    function throttle(func, wait, options) {\n      var timeout, context, args, result;\n      var previous = 0;\n      if (!options) options = {};\n\n      var later = function () {\n        previous = options.leading === false ? 0 : now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n\n      var throttled = function () {\n        var _now = now();\n        if (!previous && options.leading === false) previous = _now;\n        var remaining = wait - (_now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = _now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) {\n          timeout = setTimeout(later, remaining);\n        }\n        return result;\n      };\n\n      throttled.cancel = function () {\n        clearTimeout(timeout);\n        previous = 0;\n        timeout = context = args = null;\n      };\n\n      return throttled;\n    }\n\n    function debounce(func, wait, immediate) {\n      var timeout, previous, args, result, context;\n\n      var later = function () {\n        var passed = now() - previous;\n        if (wait > passed) {\n          timeout = setTimeout(later, wait - passed);\n        } else {\n          timeout = null;\n          if (!immediate) result = func.apply(context, args);\n          if (!timeout) args = context = null;\n        }\n      };\n\n      var debounced = restArguments(function (_args) {\n        context = this;\n        args = _args;\n        previous = now();\n        if (!timeout) {\n          timeout = setTimeout(later, wait);\n          if (immediate) result = func.apply(context, args);\n        }\n        return result;\n      });\n\n      debounced.cancel = function () {\n        clearTimeout(timeout);\n        timeout = args = context = null;\n      };\n\n      return debounced;\n    }\n\n    function wrap(func, wrapper) {\n      return partial(wrapper, func);\n    }\n\n    function negate(predicate) {\n      return function () {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    function compose() {\n      var args = arguments;\n      var start = args.length - 1;\n      return function () {\n        var i = start;\n        var result = args[start].apply(this, arguments);\n        while (i--) result = args[i].call(this, result);\n        return result;\n      };\n    }\n\n    function after(times, func) {\n      return function () {\n        if (--times < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    function before(times, func) {\n      var memo;\n      return function () {\n        if (--times > 0) {\n          memo = func.apply(this, arguments);\n        }\n        if (times <= 1) func = null;\n        return memo;\n      };\n    }\n\n    var once = partial(before, 2);\n\n    function findKey(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var _keys = keys(obj),\n        key;\n      for (var i = 0, length = _keys.length; i < length; i++) {\n        key = _keys[i];\n        if (predicate(obj[key], key, obj)) return key;\n      }\n    }\n\n    function createPredicateIndexFinder(dir) {\n      return function (array, predicate, context) {\n        predicate = cb(predicate, context);\n        var length = getLength(array);\n        var index = dir > 0 ? 0 : length - 1;\n        for (; index >= 0 && index < length; index += dir) {\n          if (predicate(array[index], index, array)) return index;\n        }\n        return -1;\n      };\n    }\n\n    var findIndex = createPredicateIndexFinder(1);\n\n    var findLastIndex = createPredicateIndexFinder(-1);\n\n    function sortedIndex(array, obj, iteratee, context) {\n      iteratee = cb(iteratee, context, 1);\n      var value = iteratee(obj);\n      var low = 0,\n        high = getLength(array);\n      while (low < high) {\n        var mid = Math.floor((low + high) / 2);\n        if (iteratee(array[mid]) < value) low = mid + 1;\n        else high = mid;\n      }\n      return low;\n    }\n\n    function createIndexFinder(dir, predicateFind, sortedIndex) {\n      return function (array, item, idx) {\n        var i = 0,\n          length = getLength(array);\n        if (typeof idx == \"number\") {\n          if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n          } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n          }\n        } else if (sortedIndex && idx && length) {\n          idx = sortedIndex(array, item);\n          return array[idx] === item ? idx : -1;\n        }\n        if (item !== item) {\n          idx = predicateFind(slice.call(array, i, length), isNaN$1);\n          return idx >= 0 ? idx + i : -1;\n        }\n        for (\n          idx = dir > 0 ? i : length - 1;\n          idx >= 0 && idx < length;\n          idx += dir\n        ) {\n          if (array[idx] === item) return idx;\n        }\n        return -1;\n      };\n    }\n\n    var indexOf = createIndexFinder(1, findIndex, sortedIndex);\n\n    var lastIndexOf = createIndexFinder(-1, findLastIndex);\n\n    function find(obj, predicate, context) {\n      var keyFinder = isArrayLike(obj) ? findIndex : findKey;\n      var key = keyFinder(obj, predicate, context);\n      if (key !== void 0 && key !== -1) return obj[key];\n    }\n\n    function findWhere(obj, attrs) {\n      return find(obj, matcher(attrs));\n    }\n\n    function each(obj, iteratee, context) {\n      iteratee = optimizeCb(iteratee, context);\n      var i, length;\n      if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n          iteratee(obj[i], i, obj);\n        }\n      } else {\n        var _keys = keys(obj);\n        for (i = 0, length = _keys.length; i < length; i++) {\n          iteratee(obj[_keys[i]], _keys[i], obj);\n        }\n      }\n      return obj;\n    }\n\n    function map(obj, iteratee, context) {\n      iteratee = cb(iteratee, context);\n      var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length,\n        results = Array(length);\n      for (var index = 0; index < length; index++) {\n        var currentKey = _keys ? _keys[index] : index;\n        results[index] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n    }\n\n    function createReduce(dir) {\n      var reducer = function (obj, iteratee, memo, initial) {\n        var _keys = !isArrayLike(obj) && keys(obj),\n          length = (_keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n        if (!initial) {\n          memo = obj[_keys ? _keys[index] : index];\n          index += dir;\n        }\n        for (; index >= 0 && index < length; index += dir) {\n          var currentKey = _keys ? _keys[index] : index;\n          memo = iteratee(memo, obj[currentKey], currentKey, obj);\n        }\n        return memo;\n      };\n\n      return function (obj, iteratee, memo, context) {\n        var initial = arguments.length >= 3;\n        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n      };\n    }\n\n    var reduce = createReduce(1);\n\n    var reduceRight = createReduce(-1);\n\n    function filter(obj, predicate, context) {\n      var results = [];\n      predicate = cb(predicate, context);\n      each(obj, function (value, index, list) {\n        if (predicate(value, index, list)) results.push(value);\n      });\n      return results;\n    }\n\n    function reject(obj, predicate, context) {\n      return filter(obj, negate(cb(predicate)), context);\n    }\n\n    function every(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n      for (var index = 0; index < length; index++) {\n        var currentKey = _keys ? _keys[index] : index;\n        if (!predicate(obj[currentKey], currentKey, obj)) return false;\n      }\n      return true;\n    }\n\n    function some(obj, predicate, context) {\n      predicate = cb(predicate, context);\n      var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n      for (var index = 0; index < length; index++) {\n        var currentKey = _keys ? _keys[index] : index;\n        if (predicate(obj[currentKey], currentKey, obj)) return true;\n      }\n      return false;\n    }\n\n    function contains(obj, item, fromIndex, guard) {\n      if (!isArrayLike(obj)) obj = values(obj);\n      if (typeof fromIndex != \"number\" || guard) fromIndex = 0;\n      return indexOf(obj, item, fromIndex) >= 0;\n    }\n\n    var invoke = restArguments(function (obj, path, args) {\n      var contextPath, func;\n      if (isFunction$1(path)) {\n        func = path;\n      } else {\n        path = toPath$1(path);\n        contextPath = path.slice(0, -1);\n        path = path[path.length - 1];\n      }\n      return map(obj, function (context) {\n        var method = func;\n        if (!method) {\n          if (contextPath && contextPath.length) {\n            context = deepGet(context, contextPath);\n          }\n          if (context == null) return void 0;\n          method = context[path];\n        }\n        return method == null ? method : method.apply(context, args);\n      });\n    });\n\n    function pluck(obj, key) {\n      return map(obj, property(key));\n    }\n\n    function where(obj, attrs) {\n      return filter(obj, matcher(attrs));\n    }\n\n    function max(obj, iteratee, context) {\n      var result = -Infinity,\n        lastComputed = -Infinity,\n        value,\n        computed;\n      if (\n        iteratee == null ||\n        (typeof iteratee == \"number\" &&\n          typeof obj[0] != \"object\" &&\n          obj != null)\n      ) {\n        obj = isArrayLike(obj) ? obj : values(obj);\n        for (var i = 0, length = obj.length; i < length; i++) {\n          value = obj[i];\n          if (value != null && value > result) {\n            result = value;\n          }\n        }\n      } else {\n        iteratee = cb(iteratee, context);\n        each(obj, function (v, index, list) {\n          computed = iteratee(v, index, list);\n          if (\n            computed > lastComputed ||\n            (computed === -Infinity && result === -Infinity)\n          ) {\n            result = v;\n            lastComputed = computed;\n          }\n        });\n      }\n      return result;\n    }\n\n    function min(obj, iteratee, context) {\n      var result = Infinity,\n        lastComputed = Infinity,\n        value,\n        computed;\n      if (\n        iteratee == null ||\n        (typeof iteratee == \"number\" &&\n          typeof obj[0] != \"object\" &&\n          obj != null)\n      ) {\n        obj = isArrayLike(obj) ? obj : values(obj);\n        for (var i = 0, length = obj.length; i < length; i++) {\n          value = obj[i];\n          if (value != null && value < result) {\n            result = value;\n          }\n        }\n      } else {\n        iteratee = cb(iteratee, context);\n        each(obj, function (v, index, list) {\n          computed = iteratee(v, index, list);\n          if (\n            computed < lastComputed ||\n            (computed === Infinity && result === Infinity)\n          ) {\n            result = v;\n            lastComputed = computed;\n          }\n        });\n      }\n      return result;\n    }\n\n    function sample(obj, n, guard) {\n      if (n == null || guard) {\n        if (!isArrayLike(obj)) obj = values(obj);\n        return obj[random(obj.length - 1)];\n      }\n      var sample = isArrayLike(obj) ? clone(obj) : values(obj);\n      var length = getLength(sample);\n      n = Math.max(Math.min(n, length), 0);\n      var last = length - 1;\n      for (var index = 0; index < n; index++) {\n        var rand = random(index, last);\n        var temp = sample[index];\n        sample[index] = sample[rand];\n        sample[rand] = temp;\n      }\n      return sample.slice(0, n);\n    }\n\n    function shuffle(obj) {\n      return sample(obj, Infinity);\n    }\n\n    function sortBy(obj, iteratee, context) {\n      var index = 0;\n      iteratee = cb(iteratee, context);\n      return pluck(\n        map(obj, function (value, key, list) {\n          return {\n            value: value,\n            index: index++,\n            criteria: iteratee(value, key, list),\n          };\n        }).sort(function (left, right) {\n          var a = left.criteria;\n          var b = right.criteria;\n          if (a !== b) {\n            if (a > b || a === void 0) return 1;\n            if (a < b || b === void 0) return -1;\n          }\n          return left.index - right.index;\n        }),\n        \"value\"\n      );\n    }\n\n    function group(behavior, partition) {\n      return function (obj, iteratee, context) {\n        var result = partition ? [[], []] : {};\n        iteratee = cb(iteratee, context);\n        each(obj, function (value, index) {\n          var key = iteratee(value, index, obj);\n          behavior(result, value, key);\n        });\n        return result;\n      };\n    }\n\n    var groupBy = group(function (result, value, key) {\n      if (has(result, key)) result[key].push(value);\n      else result[key] = [value];\n    });\n\n    var indexBy = group(function (result, value, key) {\n      result[key] = value;\n    });\n\n    var countBy = group(function (result, value, key) {\n      if (has(result, key)) result[key]++;\n      else result[key] = 1;\n    });\n\n    var partition = group(function (result, value, pass) {\n      result[pass ? 0 : 1].push(value);\n    }, true);\n\n    var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n    function toArray(obj) {\n      if (!obj) return [];\n      if (isArray(obj)) return slice.call(obj);\n      if (isString(obj)) {\n        return obj.match(reStrSymbol);\n      }\n      if (isArrayLike(obj)) return map(obj, identity);\n      return values(obj);\n    }\n\n    function size(obj) {\n      if (obj == null) return 0;\n      return isArrayLike(obj) ? obj.length : keys(obj).length;\n    }\n\n    function keyInObj(value, key, obj) {\n      return key in obj;\n    }\n\n    var pick = restArguments(function (obj, keys) {\n      var result = {},\n        iteratee = keys[0];\n      if (obj == null) return result;\n      if (isFunction$1(iteratee)) {\n        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n        keys = allKeys(obj);\n      } else {\n        iteratee = keyInObj;\n        keys = flatten(keys, false, false);\n        obj = Object(obj);\n      }\n      for (var i = 0, length = keys.length; i < length; i++) {\n        var key = keys[i];\n        var value = obj[key];\n        if (iteratee(value, key, obj)) result[key] = value;\n      }\n      return result;\n    });\n\n    var omit = restArguments(function (obj, keys) {\n      var iteratee = keys[0],\n        context;\n      if (isFunction$1(iteratee)) {\n        iteratee = negate(iteratee);\n        if (keys.length > 1) context = keys[1];\n      } else {\n        keys = map(flatten(keys, false, false), String);\n        iteratee = function (value, key) {\n          return !contains(keys, key);\n        };\n      }\n      return pick(obj, iteratee, context);\n    });\n\n    function initial(array, n, guard) {\n      return slice.call(\n        array,\n        0,\n        Math.max(0, array.length - (n == null || guard ? 1 : n))\n      );\n    }\n\n    function first(array, n, guard) {\n      if (array == null || array.length < 1)\n        return n == null || guard ? void 0 : [];\n      if (n == null || guard) return array[0];\n      return initial(array, array.length - n);\n    }\n\n    function rest(array, n, guard) {\n      return slice.call(array, n == null || guard ? 1 : n);\n    }\n\n    function last(array, n, guard) {\n      if (array == null || array.length < 1)\n        return n == null || guard ? void 0 : [];\n      if (n == null || guard) return array[array.length - 1];\n      return rest(array, Math.max(0, array.length - n));\n    }\n\n    function compact(array) {\n      return filter(array, Boolean);\n    }\n\n    function flatten$1(array, depth) {\n      return flatten(array, depth, false);\n    }\n\n    var difference = restArguments(function (array, rest) {\n      rest = flatten(rest, true, true);\n      return filter(array, function (value) {\n        return !contains(rest, value);\n      });\n    });\n\n    var without = restArguments(function (array, otherArrays) {\n      return difference(array, otherArrays);\n    });\n\n    function uniq(array, isSorted, iteratee, context) {\n      if (!isBoolean(isSorted)) {\n        context = iteratee;\n        iteratee = isSorted;\n        isSorted = false;\n      }\n      if (iteratee != null) iteratee = cb(iteratee, context);\n      var result = [];\n      var seen = [];\n      for (var i = 0, length = getLength(array); i < length; i++) {\n        var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n        if (isSorted && !iteratee) {\n          if (!i || seen !== computed) result.push(value);\n          seen = computed;\n        } else if (iteratee) {\n          if (!contains(seen, computed)) {\n            seen.push(computed);\n            result.push(value);\n          }\n        } else if (!contains(result, value)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    var union = restArguments(function (arrays) {\n      return uniq(flatten(arrays, true, true));\n    });\n\n    function intersection(array) {\n      var result = [];\n      var argsLength = arguments.length;\n      for (var i = 0, length = getLength(array); i < length; i++) {\n        var item = array[i];\n        if (contains(result, item)) continue;\n        var j;\n        for (j = 1; j < argsLength; j++) {\n          if (!contains(arguments[j], item)) break;\n        }\n        if (j === argsLength) result.push(item);\n      }\n      return result;\n    }\n\n    function unzip(array) {\n      var length = (array && max(array, getLength).length) || 0;\n      var result = Array(length);\n\n      for (var index = 0; index < length; index++) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    var zip = restArguments(unzip);\n\n    function object(list, values) {\n      var result = {};\n      for (var i = 0, length = getLength(list); i < length; i++) {\n        if (values) {\n          result[list[i]] = values[i];\n        } else {\n          result[list[i][0]] = list[i][1];\n        }\n      }\n      return result;\n    }\n\n    function range(start, stop, step) {\n      if (stop == null) {\n        stop = start || 0;\n        start = 0;\n      }\n      if (!step) {\n        step = stop < start ? -1 : 1;\n      }\n\n      var length = Math.max(Math.ceil((stop - start) / step), 0);\n      var range = Array(length);\n\n      for (var idx = 0; idx < length; idx++, start += step) {\n        range[idx] = start;\n      }\n\n      return range;\n    }\n\n    function chunk(array, count) {\n      if (count == null || count < 1) return [];\n      var result = [];\n      var i = 0,\n        length = array.length;\n      while (i < length) {\n        result.push(slice.call(array, i, (i += count)));\n      }\n      return result;\n    }\n\n    function chainResult(instance, obj) {\n      return instance._chain ? _(obj).chain() : obj;\n    }\n\n    function mixin(obj) {\n      each(functions(obj), function (name) {\n        var func = (_[name] = obj[name]);\n        _.prototype[name] = function () {\n          var args = [this._wrapped];\n          push.apply(args, arguments);\n          return chainResult(this, func.apply(_, args));\n        };\n      });\n      return _;\n    }\n\n    each(\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"],\n      function (name) {\n        var method = ArrayProto[name];\n        _.prototype[name] = function () {\n          var obj = this._wrapped;\n          if (obj != null) {\n            method.apply(obj, arguments);\n            if ((name === \"shift\" || name === \"splice\") && obj.length === 0) {\n              delete obj[0];\n            }\n          }\n          return chainResult(this, obj);\n        };\n      }\n    );\n\n    each([\"concat\", \"join\", \"slice\"], function (name) {\n      var method = ArrayProto[name];\n      _.prototype[name] = function () {\n        var obj = this._wrapped;\n        if (obj != null) obj = method.apply(obj, arguments);\n        return chainResult(this, obj);\n      };\n    });\n\n    var allExports = {\n      __proto__: null,\n      VERSION: VERSION,\n      restArguments: restArguments,\n      isObject: isObject,\n      isNull: isNull,\n      isUndefined: isUndefined,\n      isBoolean: isBoolean,\n      isElement: isElement,\n      isString: isString,\n      isNumber: isNumber,\n      isDate: isDate,\n      isRegExp: isRegExp,\n      isError: isError,\n      isSymbol: isSymbol,\n      isArrayBuffer: isArrayBuffer,\n      isDataView: isDataView$1,\n      isArray: isArray,\n      isFunction: isFunction$1,\n      isArguments: isArguments$1,\n      isFinite: isFinite$1,\n      isNaN: isNaN$1,\n      isTypedArray: isTypedArray$1,\n      isEmpty: isEmpty,\n      isMatch: isMatch,\n      isEqual: isEqual,\n      isMap: isMap,\n      isWeakMap: isWeakMap,\n      isSet: isSet,\n      isWeakSet: isWeakSet,\n      keys: keys,\n      allKeys: allKeys,\n      values: values,\n      pairs: pairs,\n      invert: invert,\n      functions: functions,\n      methods: functions,\n      extend: extend,\n      extendOwn: extendOwn,\n      assign: extendOwn,\n      defaults: defaults,\n      create: create,\n      clone: clone,\n      tap: tap,\n      get: get,\n      has: has$1,\n      mapObject: mapObject,\n      identity: identity,\n      constant: constant,\n      noop: noop,\n      toPath: toPath,\n      property: property,\n      propertyOf: propertyOf,\n      matcher: matcher,\n      matches: matcher,\n      times: times,\n      random: random,\n      now: now,\n      escape: _escape,\n      unescape: _unescape,\n      templateSettings: templateSettings,\n      template: template,\n      result: result,\n      uniqueId: uniqueId,\n      chain: chain,\n      iteratee: iteratee,\n      partial: partial,\n      bind: bind,\n      bindAll: bindAll,\n      memoize: memoize,\n      delay: delay,\n      defer: defer,\n      throttle: throttle,\n      debounce: debounce,\n      wrap: wrap,\n      negate: negate,\n      compose: compose,\n      after: after,\n      before: before,\n      once: once,\n      findKey: findKey,\n      findIndex: findIndex,\n      findLastIndex: findLastIndex,\n      sortedIndex: sortedIndex,\n      indexOf: indexOf,\n      lastIndexOf: lastIndexOf,\n      find: find,\n      detect: find,\n      findWhere: findWhere,\n      each: each,\n      forEach: each,\n      map: map,\n      collect: map,\n      reduce: reduce,\n      foldl: reduce,\n      inject: reduce,\n      reduceRight: reduceRight,\n      foldr: reduceRight,\n      filter: filter,\n      select: filter,\n      reject: reject,\n      every: every,\n      all: every,\n      some: some,\n      any: some,\n      contains: contains,\n      includes: contains,\n      include: contains,\n      invoke: invoke,\n      pluck: pluck,\n      where: where,\n      max: max,\n      min: min,\n      shuffle: shuffle,\n      sample: sample,\n      sortBy: sortBy,\n      groupBy: groupBy,\n      indexBy: indexBy,\n      countBy: countBy,\n      partition: partition,\n      toArray: toArray,\n      size: size,\n      pick: pick,\n      omit: omit,\n      first: first,\n      head: first,\n      take: first,\n      initial: initial,\n      last: last,\n      rest: rest,\n      tail: rest,\n      drop: rest,\n      compact: compact,\n      flatten: flatten$1,\n      without: without,\n      uniq: uniq,\n      unique: uniq,\n      union: union,\n      intersection: intersection,\n      difference: difference,\n      unzip: unzip,\n      transpose: unzip,\n      zip: zip,\n      object: object,\n      range: range,\n      chunk: chunk,\n      mixin: mixin,\n      default: _,\n    };\n\n    var _$1 = mixin(allExports);\n    _$1._ = _$1;\n\n    return _$1;\n  });\n</script>\n\n<script>\n  // Julia.cs\n  // https://dougx.net/fractals/csharp/\n  // Copyright (c) 2010 DougX.net\n  // Open License https://dougx.net/fractals/license.txt\n  // Modified by Kai Chang, Copyright (c) 2012\n  // Modified by Scott Haynes Stevenson, Copyright (c) 2021\n  function jfractal(x_extent, y_extent) {\n    var jfrac = {};\n    var __ = {\n      realMin: -1.7,\n      realMax: 1.7,\n      imagMin: -1,\n      imagMax: 1,\n      // balanced\n      CR: -0.795,\n      CI: 0.155,\n      maxIter: 5000,\n      minResolution: 40,\n    };\n\n    var events = d3.dispatch.apply(this, [\"done\"].concat(d3.keys(__)));\n\n    jfrac.color = d3.scale\n      .sqrt()\n      .domain([0, __.maxIter])\n      .range([\"black\", \"yellow\"])\n      .interpolate(d3.interpolateLab);\n\n    jfrac.__ = __;\n    getset(jfrac, __, events);\n    d3.rebind(jfrac, events, \"on\");\n\n    var ctx;\n    var _x = 0;\n    var _y = 0;\n    var resolution = __.minResolution;\n    var done = false;\n\n    jfrac.zoom = function (reals, imags) {\n      done = true;\n      __.realMin = reals[0];\n      __.realMax = reals[1];\n      __.imagMin = imags[0];\n      __.imagMax = imags[1];\n      jfrac.resetForRender();\n    };\n\n    jfrac.iterate = function (real, imag) {\n      var zr = real;\n      var zi = imag;\n\n      var iterations = 0;\n\n      while (true) {\n        iterations++;\n        if (iterations > __.maxIter) return 0;\n        zr_next = zr * zr - zi * zi + __.CR;\n        zi_next = 2 * zi * zr + __.CI;\n        zr = zr_next;\n        zi = zi_next;\n        if (zr > 4) return iterations;\n        if (zi > 4) return iterations;\n      }\n      return iterations;\n    };\n\n    jfrac.render = function () {\n      if (done) return;\n\n      if (jfrac.boxes()) return;\n\n      var realSpan = __.realMax - __.realMin;\n      var imagSpan = __.imagMax - __.imagMin;\n      var realMin = __.realMin;\n      var imagMin = __.imagMin;\n      var fast_color = _.memoize(jfrac.color);\n\n      var ll = _x + 6; \n      for (; _x < ll; ++_x) {\n        for (_y = 0; _y < y_extent; ++_y) {\n          var fx = _x / x_extent;\n          var fy = _y / y_extent;\n\n          var real = fx * realSpan + realMin;\n          var imag = fy * imagSpan + imagMin;\n\n          var iterations = jfrac.iterate(real, imag);\n\n          ctx.fillStyle = fast_color(iterations);\n          ctx.fillRect(_x, _y, 1, 1);\n        }\n      }\n\n      if (_x >= x_extent) {\n        done = true;\n        events.done.call(jfrac);\n      }\n    };\n\n    jfrac.boxes = function () {\n      if (resolution <= 3) {\n        return false;\n      }\n\n      var realSpan = __.realMax - __.realMin;\n      var imagSpan = __.imagMax - __.imagMin;\n      var fast_color = _.memoize(jfrac.color);\n\n      for (_x = 0; _x < x_extent; _x += resolution) {\n        for (_y = 0; _y < y_extent; _y += resolution) {\n          var fx = (_x + resolution / 2) / x_extent;\n          var fy = (_y + resolution / 2) / y_extent;\n\n          var real = fx * realSpan + __.realMin;\n          var imag = fy * imagSpan + __.imagMin;\n\n          var iterations = jfrac.iterate(real, imag);\n\n          ctx.fillStyle = fast_color(iterations);\n          ctx.fillRect(_x, _y, resolution, resolution);\n        }\n      }\n\n      resolution -= 3;\n      _x = 0;\n      _y = 0;\n      return true;\n    };\n\n    jfrac.resetForRender = function () {\n      _x = 0;\n      _y = 0;\n      resolution = __.minResolution;\n      done = false;\n    };\n\n    jfrac.context = function (_) {\n      if (!arguments.length) return ctx;\n      ctx = _;\n      return this;\n    };\n\n    jfrac.x_extent = function (_) {\n      if (!arguments.length) return x_extent;\n      x_extent = _;\n      jfrac.resetForRender();\n      return this;\n    };\n\n    jfrac.y_extent = function (_) {\n      if (!arguments.length) return y_extent;\n      y_extent = _;\n      jfrac.resetForRender();\n      return this;\n    };\n\n    jfrac.go = function () {\n      var render = function () {\n        jfrac.render();\n      };\n      d3.timer(render);\n    };\n\n    function getset(obj, state) {\n      d3.keys(state).forEach(function (key) {\n        obj[key] = function (x) {\n          if (!arguments.length) return state[key];\n          var old = state[key];\n          state[key] = typeof (x - 0) == \"number\" ? x - 0 : x;\n          events[key].call(jfrac, { value: state[key], previous: old });\n          obj.resetForRender();\n          return obj;\n        };\n      });\n    }\n\n    return jfrac;\n  }\n</script>\n\n<script>\n  var width = document.body.clientWidth;\n  var height = document.body.clientHeight;\n  var canvas = document.createElement(\"canvas\");\n  var visible_canvas = document.getElementById(\"theCanvas\");\n\n  canvas.width = width;\n  canvas.height = height;\n\n  d3.selectAll(\"canvas\").attr(\"width\", width).attr(\"height\", height);\n\n  var ctx = canvas.getContext(\"2d\");\n  var visible_ctx = visible_canvas.getContext(\"2d\");\n\n  visible_ctx.fillStyle = \"white\";\n  visible_ctx.font = \"10pt sans-serif\";\n  visible_ctx.fillText(\"Be patient, it's alive.\", width / 2, height / 2);\n\n  jfrac = jfractal(width, height)\n    .context(ctx)\n    .minResolution(0)\n    .realMin(-1.7)\n    .realMax(1.7)\n    .imagMin(-1)\n    .imagMax(1);\n  jfrac.render();\n\n  var image_datas = [];\n\n  jfrac.on(\"done\", function () {\n    console.log(\"new iteration\");\n    image_datas.push(ctx.getImageData(0, 0, width, height));\n    jfrac.CI(jfrac.CI() + 0.0002);\n  });\n\n  jfrac.go();\n\n  play();\n\n  var stop = false;\n  function play() {\n    var i = 0;\n    var forwards = true;\n    function renderNext() {\n      if (stop) return true;\n      if (image_datas.length == 0) return;\n      if (i == image_datas.length) {\n        i--;\n        forwards = false;\n        return;\n      }\n      if (i == 0) {\n        visible_ctx.putImageData(image_datas[i], 0, 0);\n        i++;\n        forwards = true;\n        return;\n      }\n      visible_ctx.putImageData(image_datas[i], 0, 0);\n      forwards ? i++ : i--;\n    }\n    d3.timer(renderNext);\n  }\n</script>\n","version":"5.32.0","position":[0.25,4.25,-6.75],"rotation":[0,3.141592653589793,0],"isTrigger":false,"triggerIsAudible":false,"proximityToTrigger":1.77},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"03f939ff-9b4a-43b4-9462-8aa4da057a39","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"opacity":"1.00","stretch":true,"version":"8.3.2","position":[-9.25,1.5,7.75],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"20c1c931-0aa5-4bd7-bdfb-d657d2af2299","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[-9.75,1.5,7.25],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/Qma2ZASSMtpDKnSgGGUas4Gpm7yWxAHjoR9AjUpXJ8dFqE","link":"https://tenfinney.com","type":"image","uuid":"c10ca430-ef8c-456f-a0cc-b7559d567fbc","scale":[3,1.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,4.9,6],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreialccllirj5da73qpbzym5wtqjkai3fxns4xcnngzqhugbyedc7oe","type":"image","uuid":"93f66ed2-f93e-4f2e-85c5-fa0eee76dd3b","scale":[3,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,8.5,0.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreiaexajmztz5p4lqmae7ww7fxtvmysht7mf6dpf5mw6u7247eip7rm","type":"image","uuid":"3d908715-61dd-4e31-84ee-bf1010b426ce","scale":[3,0.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.37.0","position":[-8,5.25,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreiaexajmztz5p4lqmae7ww7fxtvmysht7mf6dpf5mw6u7247eip7rm","type":"image","uuid":"c96855c8-74f5-4cc6-8eb2-152e29f5f16f","scale":[3,0.5,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[8.25,5.25,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreihredx7fuh3ycayvrlnbhybhyame45ld22f2ltxpu3qjatftfvsye","type":"image","uuid":"e8f41f63-217e-4476-a308-e05c99c4cea3","scale":[1.5,0.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"position":[8.95,4.5,7.75],"rotation":[0,3.14159,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false,"version":"27734","opacity":"1.00"},{"url":"https://slate.textile.io/ipfs/bafkreihredx7fuh3ycayvrlnbhybhyame45ld22f2ltxpu3qjatftfvsye","type":"image","uuid":"55b39ede-d374-41f5-bdba-9a8915ece954","scale":[1.5,0.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-7,5.75,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreihredx7fuh3ycayvrlnbhybhyame45ld22f2ltxpu3qjatftfvsye","type":"image","uuid":"90858fae-d586-4d78-a200-e657f131dc4d","scale":[1.5,0.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,5.75,-5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://opensea.io/assets/0x2a46f2ffd99e19a89476e2f62270e0a35bbf0756/18350","type":"nft-image","uuid":"2c6b4629-89cb-410c-b4f8-b85645b3ae98","color":false,"scale":[1,1,0],"hasGui":true,"stretch":false,"version":"8.3.2","hasFrame":true,"inverted":false,"position":[-7.55,2,-7.35],"rotation":[0,0,0],"transparent":false,"hasGuiResizable":false,"emissiveColorIntensity":"0.50"},{"text":"VR Girl","type":"sign","uuid":"8802f80d-8932-4499-b3e7-4675e8ea9e68","color":"#000000","scale":[0.5,0.5,0.5],"fontSize":"20","position":[-8.8,1.85,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"text":"Artist: Katy Arrington","type":"sign","uuid":"c675f1fc-9c6d-4464-bd01-976e37637950","color":"#000000","scale":[0.9796874999999999,0.5,0.5],"fontSize":"18","position":[-9,1.75,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmTSyfsdHtCaxKV1688ApUYaQ8Fs9WRSSBuAwG9fCCUqji","type":"vox-model","uuid":"8cf963e5-4c53-4e45-b4c5-78301bc0101b","flipX":true,"scale":[3.9,2,0.5],"position":[2.6,1.35,-7.4],"rotation":[0,3.14159,0],"animation":{"keyframes":[]},"version":"27734"},{"url":"https://ipfs.infura.io/ipfs/QmTSyfsdHtCaxKV1688ApUYaQ8Fs9WRSSBuAwG9fCCUqji","type":"vox-model","uuid":"f2b0ab2d-ed75-4da7-9324-126b64f9cff3","flipX":true,"scale":[2.2,2.1,0.5],"position":[5.3,1.3,-7.4],"rotation":[0,3.14159,0],"animation":{"keyframes":[]},"version":"27734"},{"url":"https://ipfs.infura.io/ipfs/QmTSyfsdHtCaxKV1688ApUYaQ8Fs9WRSSBuAwG9fCCUqji","type":"vox-model","uuid":"5d375dfb-7755-4d78-8db6-7c3606371483","flipX":true,"scale":[3,2.1,0.5],"position":[4.75,1.33,-6.6],"rotation":[0,0,0],"animation":{"keyframes":[]},"version":"27734"},{"url":"https://ipfs.infura.io/ipfs/QmTSyfsdHtCaxKV1688ApUYaQ8Fs9WRSSBuAwG9fCCUqji","type":"vox-model","uuid":"5dbdcf85-7def-4ad6-a85b-e996577f6c98","flipX":true,"scale":[4.4,2,0.5],"position":[-4.75,1.35,-7.4],"rotation":[0,3.14,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmTSyfsdHtCaxKV1688ApUYaQ8Fs9WRSSBuAwG9fCCUqji","type":"vox-model","uuid":"b02538ff-4c89-4321-a974-e1d8c8e17879","flipX":true,"scale":[2.1,2,0.5],"position":[-7.4,1.35,-7.45],"rotation":[0,3.14,0],"animation":{"keyframes":[]}},{"url":"https://slate.textile.io/ipfs/bafkreieywwayhgdu4yxwqsbd6ub6s4rhj4w62xwrtj7gsni7h6ezjprcam","type":"image","uuid":"c48ec054-d9a6-4c53-8b55-a79d0c65f17a","scale":[3,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-6.5,2.2,-6.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreidyhmseyj4agbtdx3zfygq76p2ojy3rzdm2crwwi7k54tjnpsotqi","type":"image","uuid":"8f9fa39d-dc26-4485-b9fd-09aee789d45b","scale":[2,0.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"17431","position":[8,4,-6.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"b3e10050-de0b-4fc1-8466-0bc80a58ae97","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[10.25,1.25,6.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"dc0db7cc-861c-43c6-b40a-3e010b948c7a","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[9.5,1.25,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"1ac30435-9cd8-4a9e-88e6-d1a8f094ad44","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.25,1.25,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"309d17f8-0898-4e28-91a2-13f60bd344ab","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,1.25,-6.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeibxs2tm4x3jsuy5viik3q3olbl4d7uh7t4unqh6rvh247sclj6ezi.ipfs.infura-ipfs.io/","link":"https://web3emporium.com","type":"image","uuid":"5c7337ab-a070-4a50-bc1e-976758596a26","scale":[1,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-3.5,2,-6.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"80a272a9-eec4-4c78-a040-03a4f41b4d35","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[-9.75,1.5,-6.25],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreicmfthpt66a6tzwbv22zqibg5kugwxkmbgcj6ioz6mrnmv4hokffi","type":"image","uuid":"ffafa10d-8fce-46b8-91c2-0740350bb04c","scale":[1.7,0.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"position":[-9.75,3.5,-1.25],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"e3ed8f91-32ad-41a6-90d4-8b83c5b141cd","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,1.25,7.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreicmfthpt66a6tzwbv22zqibg5kugwxkmbgcj6ioz6mrnmv4hokffi","type":"image","uuid":"a01b74c5-fa54-4682-8e3e-04698d735ac6","scale":[1.7,0.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"position":[-1,4,7.75],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"f916a871-91b9-4c13-aae2-ff38bc8ae6f6","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[9.5,1.5,7.75],"rotation":[0,3.14,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"a3bf0ee9-c06c-4ae4-b334-d13ff00a2713","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.37.0","position":[10.25,1,-6.25],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"7c8ac55a-e3e8-4d0e-af03-34a413945e8e","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[10.25,1.25,-6.25],"rotation":[0,4.71,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreicmfthpt66a6tzwbv22zqibg5kugwxkmbgcj6ioz6mrnmv4hokffi","type":"image","uuid":"ce8cd9f7-a48d-49e9-bfda-8bb0bdffb17b","scale":[1.7,0.3,0],"script":"","uScale":1,"vScale":1,"opacity":"1.00","stretch":true,"version":"17431","position":[10.25,3.5,-1.45],"rotation":[0,4.71239,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"8070a21c-b510-41a8-ba6e-e185d18d9f82","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[10.25,1.5,6.75],"rotation":[0,4.71,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreihuecwzox2qt55dlvqipgpmdat4uqkgymhawqwbywigtlg5jmeeym.ipfs.infura-ipfs.io","type":"image","uuid":"fba1b578-d81f-4d32-989f-ecfc40648497","scale":[0.4,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[1.25,1.5,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreida7ovutlguhbh4akeylc7nykv2j5ioeifldf4pc37fqdp5pljgl4","type":"image","uuid":"42e9026f-6472-4f80-bd41-10ad72c5024f","scale":[0.7,0.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"8.3.2","position":[1.25,1.25,7.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeibxs2tm4x3jsuy5viik3q3olbl4d7uh7t4unqh6rvh247sclj6ezi.ipfs.infura-ipfs.io/","link":"https://web3emporium.com","type":"image","uuid":"a566b935-57ea-49de-adc9-a8851fc2deec","scale":[1,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"position":[1.25,1.25,7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false,"version":"27734"},{"url":"https://bafybeibxs2tm4x3jsuy5viik3q3olbl4d7uh7t4unqh6rvh247sclj6ezi.ipfs.infura-ipfs.io/","link":"https://web3emporium.com","type":"image","uuid":"589f6e48-c287-41a0-9a8e-fe946032bedf","scale":[1,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"position":[-9.25,2.25,-2.75],"rotation":[0,4.71,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreihwyfmvpbtg3nwltygsq234h5v3r4ca4yo7pev3j2dgsm5wz56n6m","type":"image","uuid":"d7541ebd-87c3-4943-b642-9abbdfad4672","scale":[3.4,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,8.5,-4.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://slate.textile.io/ipfs/bafkreiaexajmztz5p4lqmae7ww7fxtvmysht7mf6dpf5mw6u7247eip7rm","type":"image","uuid":"0bb15516-6825-4453-a4f1-640dd111c8ac","scale":[3.5,0.7,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.32.0","position":[-9.75,5.5,-1.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"bb0dfca8-232e-4c74-8071-36c270c33581","flipX":true,"scale":[2,1,2],"position":[-5,13.5,0.4],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"text":"202","type":"sign","uuid":"a45a1340-0a18-4e1d-aa31-68e4867c3780","color":"#1200ff","scale":[0.5,0.5,0.5],"script":"","version":"6.12.8","fontSize":"46","position":[-1.25,8.5,5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPizEuFwTydvPa4tZ6StXF9pqmFp5Gm5LsEhZ4s7TicMJ","type":"vox-model","uuid":"ea0bd7ef-0c86-4f50-83ac-1d6141ea0c23","flipX":true,"scale":[21.8,1,30.6],"position":[0.3,14.25,2],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"0cb14bf7-0483-49a7-95ec-63272f84251c","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[-6.75,3,3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmPrM9gq56ogXVGQGH38isWzQFPnPPJiM4dJrXC1Xf4hSK","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"4ed2303a-74e6-4f7e-99ee-e5a53181fd6d","scale":[1.2,1.7,0],"stretch":false,"position":[-6.75,2,3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmbPhRBP99oUMjCHT8ymbxwxAm15hmC34L1eAQSHnGcFJG","type":"image","uuid":"83fc9b3f-c93d-4233-9b4c-6c9ef5035339","scale":[0.7,0.7,0],"stretch":true,"position":[2,1.5,5.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmNgcVxfYXyRc4rVpY9rsb5GVrnCdqSFAo8Z2cXqTVraEY","type":"image","uuid":"c87b8b1c-201c-4e5b-8324-90078b24c928","scale":[0.5,0.3,0],"stretch":true,"position":[2.25,1.6,5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"text":"A","type":"button","uuid":"5c47a83b-bd8d-429f-a23d-b3ae26418d66","scale":[0.5,0.5,0.5],"position":[2,1.75,5.5],"rotation":[0,1.5707963267948966,0]},{"url":"https://ipfs.infura.io/ipfs/QmWAwyExpEh2ekHU9yXPaZTgbrvM4AoYJ2thYmqC9hWRwe","type":"image","uuid":"7925f3cc-c205-48c7-9694-cc0fd90306e1","scale":[0.5,0.2,0],"stretch":true,"position":[2.25,1.25,5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"link":"https://pay.sablier.finance/stream/653","text":"Click me for details","type":"sign","uuid":"84046683-5f46-426a-a34c-87e7741399ec","color":"#000000","scale":[0.75,0.5,0.5],"fontSize":"16","position":[-6,3,3.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"b6c48509-0cd4-4a12-8a34-2c148feaa392","scale":[1.2,1.7,0],"stretch":true,"position":[-6,2,3.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmNgcVxfYXyRc4rVpY9rsb5GVrnCdqSFAo8Z2cXqTVraEY","type":"image","uuid":"32b5126f-eead-492b-b42f-01c3eda2da27","scale":[0.5,0.3,0],"stretch":true,"position":[1.75,1.6,5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWAwyExpEh2ekHU9yXPaZTgbrvM4AoYJ2thYmqC9hWRwe","type":"image","uuid":"379ddb9c-5ee2-4678-9f3b-a11cbf1d010a","scale":[0.5,0.2,0],"stretch":true,"position":[1.75,1.25,5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmT6SPFEHnCAGyoP78ufPmRa4KGxAvsJZugjrNevu3E5tG","type":"vox-model","uuid":"9a03c932-55c1-438a-b493-dffbbf9b0b8c","flipX":true,"scale":[2.1,14,8],"position":[9.8,9.35,3.8],"rotation":[0,0,0],"animation":{"keyframes":[]}},{"link":"https://www.cryptovoxels.com/play?coords=SE@297E,9U,71S","text":"Top Floor","type":"sign","uuid":"e7917639-c014-442c-81a0-8b60d738df25","color":"#000000","scale":[0.5,0.5,0.5],"fontSize":"16","position":[-1,2.75,5.25],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"link":"https://www.cryptovoxels.com/play?coords=S@297E,69S,4.5U","text":"2nd Floor","type":"sign","uuid":"70210426-5a5c-4251-a20b-810a7aad26ba","color":"#000000","scale":[0.5,0.5,0.5],"script":"","version":"5.32.0","fontSize":"16","position":[-1,2.25,5.25],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"4c907526-9cab-4425-b869-2c3c61bfc121","flipX":true,"scale":[2,1,2],"position":[2.9,13.5,3.15],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"17c024e0-aaf6-425a-9260-cebe33682e1d","flipX":true,"scale":[2,1,2],"position":[-7.55,13.5,0.4],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"80978be8-ed74-4acd-bc2a-00dc75c84fef","flipX":true,"scale":[2,1,2],"position":[5.5,13.5,3.15],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmbPhRBP99oUMjCHT8ymbxwxAm15hmC34L1eAQSHnGcFJG","type":"image","uuid":"a185e20c-8f5a-4bfc-b7cc-e82b8fd93700","scale":[0.7,0.7,0],"stretch":true,"position":[2,1.5,5.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"c65e2344-1caa-4c05-95b7-7efb61e4890b","flipX":true,"scale":[2,1,2],"position":[0.3,13.5,3.2],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmfPqNNJ1bV8UETKhLbBzNnwA3mwxMo77a4jrFBNLdjfmb","type":"image","uuid":"f48123df-507e-46b3-af74-74376d9d40d2","scale":[1.4,1.2,0],"stretch":true,"version":"5.32.0","position":[-9.75,5.5,2.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"e3f5b5a9-1e46-4db1-9c27-7ae896e8c28f","flipX":true,"scale":[2,1,2],"position":[-2.25,13.5,3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"eac946a1-04b6-441a-94f4-354879740f29","flipX":true,"scale":[2,1,2],"position":[8.2,13.5,3.2],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://ipfs.infura.io/ipfs/QmbPhRBP99oUMjCHT8ymbxwxAm15hmC34L1eAQSHnGcFJG","type":"image","uuid":"4e34e0f0-6a65-450b-ae9f-839e669aa080","scale":[0.7,0.7,0],"stretch":true,"position":[-4,1.5,5.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmNgcVxfYXyRc4rVpY9rsb5GVrnCdqSFAo8Z2cXqTVraEY","type":"image","uuid":"7f643fff-32e4-4bec-a398-abd304ea21a5","scale":[0.5,0.3,0],"stretch":true,"position":[-3.75,1.6,5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWAwyExpEh2ekHU9yXPaZTgbrvM4AoYJ2thYmqC9hWRwe","type":"image","uuid":"9251fa5d-3767-4caa-ac0a-722b8997bb42","scale":[0.5,0.2,0],"stretch":true,"position":[-3.75,1.3,5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"text":"A","type":"button","uuid":"487eb55e-e77b-4502-94c3-c62a75e2c82e","scale":[0.5,0.5,0.5],"position":[-4,1.75,5.5],"rotation":[0,1.5707963267948966,0]},{"url":"https://ipfs.infura.io/ipfs/QmNgcVxfYXyRc4rVpY9rsb5GVrnCdqSFAo8Z2cXqTVraEY","type":"image","uuid":"6c73a2fc-6b2e-4890-8795-a32865b254ef","scale":[0.5,0.3,0],"stretch":true,"position":[-4.25,1.6,5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWAwyExpEh2ekHU9yXPaZTgbrvM4AoYJ2thYmqC9hWRwe","type":"image","uuid":"5b6d5a61-f4bb-4ce8-a7b7-89c050c6fff7","scale":[0.5,0.2,0],"stretch":true,"position":[-4.25,1.25,5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmY9AL6rDZhWQaJuAy9wVB6J24eSGk9ASCojeLSvJfw7Y6","link":"https://pay.sablier.finance/stream/653","type":"image","uuid":"61d0a36b-b84c-4e65-9439-80a710ecac64","scale":[0.6,0.7,0],"stretch":true,"version":"6.12.8","position":[1.75,7.25,3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmbPhRBP99oUMjCHT8ymbxwxAm15hmC34L1eAQSHnGcFJG","type":"image","uuid":"51327db5-4a0e-4aa1-a719-672b22ca566d","scale":[0.7,0.7,0],"stretch":true,"position":[-4,1.5,5.75],"rotation":[0,3.141592653589793,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false},{"url":"https://ipfs.infura.io/ipfs/QmWjPZexKCGukPoNTEYmcFwmUiHdaF3pWG82B1CQHUEegh","type":"vox-model","uuid":"377be292-e296-4030-9954-064ef32e5dd5","flipX":true,"scale":[2,1,2],"position":[-5,13.5,3],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]}},{"url":"https://bafybeiepj77apbtaf3f37yxmn2f2thgk57eufjwbity2ile3f33in2327y.ipfs.infura-ipfs.io","type":"image","uuid":"6af932bf-12c4-41c8-8fe1-bfd02a6d8f14","scale":[1.8,1.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,6.35,-5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeiadyvl44u3wtk2ffwo36livi7a7cgmubsqdfjohv4zkki57ju2f5u.ipfs.infura-ipfs.io","type":"image","uuid":"03a5b423-29d7-444c-8874-02c91622c82c","scale":[2,3.3,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[2.25,7.25,3],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeiheim6mc7wdu5acnzapfupokyq6c7zmicmbzud372reimvjqmqysq.ipfs.infura-ipfs.io","type":"image","uuid":"17caa49e-8032-435b-a00f-6c4651c9c4f6","scale":[2,2.8,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[2.25,7,-1],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreidq5zh5laei2xsbw4ehpzzcob6zacdoen2xa6ecqjxgjugyreqm54.ipfs.infura-ipfs.io","type":"image","uuid":"ee56853d-f04d-4dac-99bf-7f42b0f4df06","scale":[4,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[9.75,7.5,1.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreid4abzejr66wg53bxlwlwloot6qhsezpa437afcqr5j46c7oflngu.ipfs.infura-ipfs.io","type":"image","uuid":"6805598d-1eb5-455d-979a-67c919e7cbee","scale":[2.4,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[9.7,7.7,5.25],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeieb3rmye7zsqsi2ueubk65rt3bz7curxoly35ad2onhyhaybbx7ky.ipfs.infura-ipfs.io","type":"image","uuid":"0ccf220a-ce58-4aa0-abb2-146af0e045cd","scale":[1,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,9,5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeieb3rmye7zsqsi2ueubk65rt3bz7curxoly35ad2onhyhaybbx7ky.ipfs.infura-ipfs.io","type":"image","uuid":"a76d8984-2ffd-46e9-acc4-97f6bf0c239d","scale":[1,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,9,1],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeieb3rmye7zsqsi2ueubk65rt3bz7curxoly35ad2onhyhaybbx7ky.ipfs.infura-ipfs.io","type":"image","uuid":"092f6b98-bc7c-4b43-aaf0-14000a564544","scale":[1,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.25,8.95,-3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreiek3nyd3rnbo2ry37dnljh6cowh5dff6a3kwro5iiai3shk2tan7u.ipfs.infura-ipfs.io","type":"image","uuid":"3d093509-2b7b-4419-82a4-e5b445c6230e","scale":[1.5,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,8.5,5.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreiek3nyd3rnbo2ry37dnljh6cowh5dff6a3kwro5iiai3shk2tan7u.ipfs.infura-ipfs.io","type":"image","uuid":"d4fb10f5-b2ce-42a8-a80d-f044c94cba8c","scale":[1.5,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,8.5,1],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafkreiek3nyd3rnbo2ry37dnljh6cowh5dff6a3kwro5iiai3shk2tan7u.ipfs.infura-ipfs.io","type":"image","uuid":"542fc2d9-3deb-4c93-adbb-e024d5c68d59","scale":[1.5,0.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.25,8.5,-3.5],"rotation":[0,1.5707963267948966,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://bafybeibupo4vfs3z62fh24xrhtmsmr6w7g5cocfd6e3ydvdzeel7rfxxbe.ipfs.infura-ipfs.io","type":"image","uuid":"aef9bfb4-2e53-44a9-9cba-4fe2088f03c8","scale":[2.3,1,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"6.12.8","position":[1.75,7.85,-5.5],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"text":"\n\n| Magnifies        | Image    |\n| ----------- |:---------:|\n| Full-size          | 100%      |\n| Sec. 1.          | Right Tail  |\n| Sec. 2          | Southern Tail       |\n| Sec. 3.          | Channel Major       |\n\n","type":"richtext","uuid":"c4bd555c-fe48-49d3-8278-f4ace8f9317c","scale":[1.3,0.8,0],"script":"","version":"5.39.0","inverted":false,"position":[-0.75,2.5,1.5],"rotation":[0,4.71238898038469,0]},{"link":"https://www.cryptovoxels.com/play?coords=S@297E,82S,4.5U","text":"2nd Floor","type":"sign","uuid":"30227ad8-84c9-4e0d-966a-aa881a7c2509","color":"#000000","scale":[0.5,0.5,0.5],"script":"","version":"5.38.1","fontSize":"16","position":[-1,1.75,-4.75],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"link":"https://www.cryptovoxels.com/play?coords=S@297E,82S,4.5U","text":"Loge Level","type":"sign","uuid":"737ab144-a6ef-4c20-bffd-731c4d37f8e3","color":"#000000","scale":[0.5,0.5,0.5],"script":"","version":"5.38.1","fontSize":"16","position":[-1,2.25,-4.75],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","background":"#ffffff"},{"link":"https://www.cryptovoxels.com/play?coords=SE@297E,9U,71S","text":"Top Floor","type":"sign","uuid":"9509f1a5-985e-44da-b358-405b8fd03d11","color":"#000000","scale":[0.5,0.5,0.5],"version":"5.38.1","fontSize":"16","position":[-1,2.75,-4.75],"rotation":[0,0,0],"animation":{"keyframes":[]},"background":"#ffffff"},{"url":"https://opensea.io/assets/0x56cb47517bac9f8ae749b528400355423d24f037/117","type":"nft-image","uuid":"acb478c0-ba1b-4a66-8e47-fc552c26a8af","color":false,"scale":[4,2,0],"script":"","stretch":true,"version":"5.38.1","hasFrame":true,"inverted":false,"position":[9.55,12.1,-0.5],"rotation":[0,1.5707963267948966,0]},{"url":"https://ipfs.infura.io/ipfs/QmbJjAiKBr43gsjF3yf1mW8Qv4UWeZUJRXoUTHJ1SVZVtV","type":"image","uuid":"ef92a611-226c-41f2-8184-73713d62884b","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.25,2.75,-4.75],"rotation":[0,4.71238898038469,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmVGcLbViFz6DVpfp3FSbNYwRAPr8wbM7S6ipHJ4pkh1cc","link":"https://tenfinney.com","type":"image","uuid":"b134b69c-5074-4133-bae2-f5b01d2f6c93","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.8,3,2.5],"rotation":[0,1.57,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"url":"https://ipfs.infura.io/ipfs/QmdeUBRrz9uNEamr4LfHKrGoz9uR3mFK2947CW3CTywEBc","link":"https://tenfinney.com","type":"image","uuid":"c847afe3-3a1c-4c27-a4c5-2c7a23ff54a1","scale":[2,2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"version":"5.38.0","position":[-9.25,3,2.5],"rotation":[0,4.71,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"type":"image","scale":[0.4,0.4,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","position":[10.25,2.25,0],"rotation":[0,4.71239,0],"version":"25766","uuid":"b4ba7289-8585-4bc4-85a5-46f3ba824151","link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S","blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[0.4,0.4,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,3.14159,0],"blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-3,2.5,7.75],"version":"27734","uuid":"cf335925-59ef-47ba-8849-fbacd135a292","link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S"},{"type":"image","scale":[0.7,0.7,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,1.5708,0],"blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-9.75,2.25,-2.75],"version":"25766","uuid":"6e853e50-d0ea-4322-94d1-4d566387099a","link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S"},{"type":"image","scale":[0.7,0.7,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,1.5707963267948966,0],"link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S","blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-9.75,2.25,0.25],"version":"25766","uuid":"23cb5f0c-6950-4124-a9ee-ab85fc99ce94"},{"type":"image","scale":[0.4,0.4,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,0,0],"blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S","position":[1.25,6.25,7.25],"version":"26891","uuid":"d7f81b5b-e60a-4aeb-b378-329ec1c192c9"},{"type":"image","scale":[0.4,0.4,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,3.14159,0],"blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S","position":[-1,6.5,-6.25],"version":"26891","uuid":"c17546e0-3fb3-4734-984f-e2183a1e020c"},{"type":"image","scale":[1,1,0],"url":"","position":[15.25,2.25,-54.25],"rotation":[0,3.14159,0],"version":"27734","uuid":"4e78df33-3698-4d7b-9b23-9a4ee99b8dc1"},{"type":"image","scale":[1,1,0],"url":"","rotation":[0,3.14159,0],"position":[14,2.25,-54.25],"version":"27734","uuid":"6ac8f96d-14c0-4e78-b3d3-b92b30b2392c"},{"type":"image","scale":[1,1,0],"url":"","rotation":[0,3.14159,0],"position":[12.75,2.25,-54.25],"version":"27734","uuid":"e15563eb-575e-490a-961b-990f0d5caafa"},{"type":"image","scale":[1,1,0],"url":"","rotation":[0,0,0],"position":[16.5,2.25,-54.25],"version":"27734","uuid":"995711b1-9013-4600-871b-b176759f5474"},{"type":"image","scale":[1,1,0],"url":"","rotation":[0,3.14159,0],"position":[18.2,2.25,-54.25],"version":"27734","uuid":"1f867dbd-4f10-450d-819e-56a3cf61b318"},{"url":"https://ipfs.infura.io/ipfs/QmbW3UHHMG7opyBBBxnCW2VyHuiP2emFcGNCMpuuDjsbVy","link":"https://tenfinney.com","type":"image","scale":[1.7,2.2,0],"script":"","uScale":1,"vScale":1,"stretch":true,"rotation":[0,3.14159,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false,"position":[2.7,2.35,7.75],"version":"27734","uuid":"d5cf4c1c-0296-40d4-91fb-155c13fdc7d2","opacity":"1.00"},{"type":"image","scale":[1.5,1,0],"url":"https://bafybeidhotqtkvikyo3zovmpfcxevz662oth4hukcf3haydfdxhe255ulm.ipfs.infura-ipfs.io/","rotation":[1.5708,3.14159,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"blendMode":"Combine","position":[7.5,0.75,9.25],"version":"27866","uuid":"44ddcd7f-fbb4-47bc-8f16-d384be60fd04"},{"type":"image","scale":[5,1.5,0],"url":"https://bafybeihv4u4puorrb5upjvs7gv6frevdsypvfulzlyeamjgrsnstv2qt7m.ipfs.infura-ipfs.io/","rotation":[1.5708,3.14159,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"blendMode":"Combine","position":[10.75,0.75,9],"version":"27979","uuid":"f67a4e17-2d24-4df5-ba17-b5a72d7a30e2"},{"type":"image","scale":[0.4,0.4,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,0,0],"blendMode":"Combine","stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S","position":[-3,1.75,7.25],"version":"27734","uuid":"14ee24ab-a8b8-4556-83dd-6f5af11c16fa"},{"type":"image","scale":[1.5,1,0],"url":"https://bafybeidhotqtkvikyo3zovmpfcxevz662oth4hukcf3haydfdxhe255ulm.ipfs.infura-ipfs.io/","rotation":[1.5708,3.14159,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"blendMode":"Combine","position":[7.5,0.75,8.25],"version":"27866","uuid":"310569d4-b89c-4147-922d-a072390c948f"},{"type":"image","scale":[0.4,0.4,0],"url":"https://ipfs.infura.io/ipfs/QmUUK96PwpcAUhPFfyhdF7rmqYZVosbB8rKNrwBe1bms3m","rotation":[0,1.5707963267948966,0],"stretch":false,"transparent":"AlphaBlend","opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"blendMode":"Combine","link":"https://www.cryptovoxels.com/play?coords=SE@263E,6S","position":[9.75,2.0000000186264515,-7],"version":"27875","uuid":"577e5f50-116f-4857-a792-a36662b0fe70"},{"type":"cube","scale":[3,2,0.1],"url":"","rotation":[0,4.71239,0],"color":"#ffffff","position":[6,2,-4],"version":"27875","uuid":"8c310aea-25f9-42f2-839a-8532dbdf4f0e"},{"type":"video","scale":[1.8,1.6,0],"url":"https://ipfs.infura.io/ipfs/QmdRZYbBTbWLxqe62V6uG6RAtzTRZDK2YfmkFRJE1Hohxk","rotation":[0,4.71239,0],"autoplay":false,"loop":true,"startAt":0,"endAt":0,"rolloffFactor":1.2,"volume":0.7,"assetUrl":null,"previewUrl":"https://ipfs.infura.io/ipfs/QmWa6WBeK7yjgX6ShZpHuy7SVgyRmvsathkagAsVS6NgkY","position":[6.05,2,-4.25],"version":"27875","uuid":"8e8f838c-8bdc-478c-af84-4b5baf43bb72"},{"type":"image","scale":[0.5,0.5,0],"url":"https://ipfs.infura.io/ipfs/QmWa6WBeK7yjgX6ShZpHuy7SVgyRmvsathkagAsVS6NgkY","rotation":[0,4.71239,0],"stretch":false,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[6.05,1.35,-2.8],"version":"27875","uuid":"acd57462-348e-42a7-9fdc-9f639b79ce1e"},{"type":"cube","scale":[3,2,0.1],"url":"","rotation":[0,4.71239,0],"color":"#ffffff","position":[6,2,0.5],"version":"27875","uuid":"89abcf78-43c9-49aa-8032-ba0f154b4736"},{"type":"video","scale":[1.8,1.6,0],"url":"https://ipfs.infura.io/ipfs/QmdsXE6R26dMhq3QNGBX3uAa9RX7uRWb65QZ8AwWsAHphk","rotation":[0,4.71239,0],"autoplay":false,"loop":true,"startAt":0,"endAt":0,"rolloffFactor":1.2,"volume":0.7,"assetUrl":null,"previewUrl":"https://ipfs.infura.io/ipfs/QmdY2mQt6rvYsG3VmN7tV5JDK7mzrp3mpBRdhmT6Mxyi4p","position":[6.05,2,0.25],"version":"27875","uuid":"de073faf-c059-4029-88ae-bd30e174c222"},{"type":"image","scale":[0.5,0.5,0],"url":"https://ipfs.infura.io/ipfs/QmdY2mQt6rvYsG3VmN7tV5JDK7mzrp3mpBRdhmT6Mxyi4p","rotation":[0,4.71239,0],"stretch":false,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[6.05,1.35,1.7],"version":"27875","uuid":"45cd8b5b-c4b5-4f60-9510-6e57dc022b65"},{"type":"cube","scale":[4.1,2.5,0.1],"url":"","rotation":[0,4.71239,0],"color":"#ffffff","position":[10,2.85,-5.25],"version":"27875","uuid":"754565e0-0cf2-4b43-b2e5-8979768ca4e1"},{"type":"video","scale":[2.2,1.8,0],"url":"https://ipfs.infura.io/ipfs/QmdS4ckLYqoqwLXLGocZhHEiHV8DZ3Mx8TcGRVBKRn8pyz","rotation":[0,1.5707963267948966,0],"autoplay":false,"loop":true,"startAt":0,"endAt":0,"rolloffFactor":1.2,"volume":0.7,"assetUrl":null,"previewUrl":"https://ipfs.infura.io/ipfs/QmZEX1kFyL9nMhU5nCzC4gbfYYnC9utWnd8C6L2r1fgmQ1","position":[9.95,2.65,-4.75],"version":"27875","uuid":"06c713c5-99ae-4886-bcdb-a3b688cbd364"},{"type":"image","scale":[0.5,0.5,0],"url":"https://bafybeifb3zpj3ykc4e3l4mk434juh2vssi3domkzgop7obgqinwdhofjty.ipfs.infura-ipfs.io/","rotation":[0,1.5707963267948966,0],"stretch":false,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[9.95,1.95,-6.35],"version":"27875","uuid":"658dace5-fbd5-4022-a3b4-3e25f208c2d5"},{"type":"cube","scale":[3,2,0.1],"url":"","rotation":[0,4.71239,0],"color":"#ffffff","position":[6,2,5],"version":"27875","uuid":"3619c83d-fdf7-433f-9354-23765a98fa81"},{"type":"image","scale":[0.5,0.5,0],"url":"https://ipfs.infura.io/ipfs/QmPwLL4eLXbv3XztqWBpWfiWswB3Ct339Stfc9R1aYQ4gQ","rotation":[0,4.71239,0],"stretch":false,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[6.05,1.3,6.2],"version":"27979","uuid":"d4fc5424-6c03-401a-93d5-3e4365ca35a6"},{"type":"cube","scale":[3.5,2.5,0.1],"url":"","rotation":[0,0,0],"color":"#ffffff","position":[7.7,2.1,9.7],"version":"27875","uuid":"6412a19b-90bd-4035-a985-5b06db11975e"},{"type":"video","scale":[2.3,2,0],"url":"https://ipfs.infura.io/ipfs/QmdwL4yC51defpLjU9hhLxAqmS1hJgaywkczdQz4fydJhy","rotation":[0,0,0],"autoplay":true,"loop":true,"startAt":0,"endAt":0,"rolloffFactor":1.2,"volume":0.7,"assetUrl":null,"previewUrl":"https://ipfs.infura.io/ipfs/QmQdFXAM3Z1cjTbqBFMejuYoGT9oeLAZyQfC2jCxLzowiM","position":[7.5,2.1,9.65],"version":"27923","uuid":"97a1d65c-f108-4e79-a514-24b82d932d1d"},{"type":"image","scale":[0.5,0.5,0],"url":"https://ipfs.infura.io/ipfs/QmQdFXAM3Z1cjTbqBFMejuYoGT9oeLAZyQfC2jCxLzowiM","rotation":[0,0,0],"stretch":false,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[9.1,1.3,9.65],"version":"27923","uuid":"522e05a4-96ed-4d6d-8cac-d36488da1e04"},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmdBLjz4rb9Fu8VPzzJt1Ttwz59wSjuBHbc6kNhgpLLQQJ","position":[-1.75,7.75,3.25],"rotation":[0,1.5707963267948966,0],"version":"27875","uuid":"a62883ea-aff1-4719-9d25-06bb96d55228","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmYFhdzCoCTbsEfafnB1DhA4fSexy636xN9heX2jbDppux","rotation":[0,1.5707963267948966,0],"position":[-1.75,6.5,3.25],"version":"27875","uuid":"adc7313b-8024-495a-b12f-94d63f12c0ec","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmSWspguYnzzbFqikkMvfREPAHnUy9GGut3kmn9KJtKoqQ","rotation":[0,1.5707963267948966,0],"position":[-1.75,7.75,1.75],"version":"27875","uuid":"4f7dfd2a-0a61-4fc6-bf17-aeca7b436199","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmXkR1GDaUnaThhUP91bRPHhJ6gdTNbrRJPqsUdZTimQV2","rotation":[0,1.5707963267948966,0],"position":[-1.75,6.5,1.75],"version":"27875","uuid":"68a1c514-c47f-422a-a5e5-6d42d6f8bbb8","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmXHs5vJtcCX242GJmhn1TGC87xXxwezZ9xhsxnEwnVR45","rotation":[0,1.5707963267948966,0],"position":[-1.75,7.75,0.25],"version":"27875","uuid":"74b069fd-a8d8-43cd-9ce2-f884769d4702","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmcFNhvxvBSREZHjuYLfPhq9Z8LHZXSNZ2ZFqrXQsKBcVk","rotation":[0,1.5707963267948966,0],"position":[-1.75,7.75,6.5],"version":"27875","uuid":"8335e7f9-efd9-43d5-87cc-1b1ebeb959c9","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmaiDYL1bkBDEHxpsacteL5bsuX5NF1oTWqj8s88x2CXmL","rotation":[0,1.5707963267948966,0],"position":[-1.75,6.5,6.5],"version":"27875","uuid":"90bb39b8-dee3-45c3-95ee-dea4731a456f","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[1.5,2.3,0],"url":"https://ipfs.infura.io/ipfs/QmWXAYLNL5hLKW6C5GkYyYWps277iu4hWY2pTPzoMhk2wz","rotation":[0,1.5707963267948966,0],"position":[-1.25,7.1,-3.75],"version":"27875","uuid":"24b67336-b16c-47e1-aee1-74a90d529096","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[2.5,3,0],"url":"https://ipfs.infura.io/ipfs/QmVo7gTHtxnJ4TkD2qWysZr5mggnW2eWY4AsQSGfEwB9XE","rotation":[0,3.14159,0],"position":[-4.5,7.25,-6.75],"version":"27875","uuid":"153a8c22-deff-4863-b21a-006b4205f846","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[2.5,1.4,0],"url":"https://ipfs.infura.io/ipfs/QmfW19bK5eCQpDUU27HLXxVdCF28gLk4zopD3H2uMY8GBB","rotation":[0,3.14159,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-7.25,6.45,-6.75],"version":"27875","uuid":"cd364c14-d88e-4db5-a933-b6011dcdf0ce"},{"type":"image","scale":[5,3,0],"url":"https://ipfs.infura.io/ipfs/QmS1LQFeS9kXqHzqPZcyhVycdXLZZwaysRR1RrCc6vArBB","rotation":[0,0,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-5.25,7.75,7.25],"version":"27875","uuid":"c3b17ad7-5fc7-4c02-91b7-a22226f9cd19"},{"url":"https://ipfs.infura.io/ipfs/QmWyg9s2683eSQrW2qPjLHfJqfTXjLH6ZKbDwcbsw7kEXq","type":"image","scale":[1.9,2.4,0],"script":"","uScale":1,"vScale":1,"stretch":true,"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false,"position":[-4.5,7.3,-7.25],"version":"27875","uuid":"7c9ff2d1-0663-498f-b122-b13b2cc7b929","opacity":"1.00"},{"type":"image","scale":[1,1,0],"url":"https://ipfs.infura.io/ipfs/QmcFSEH3psaP4tKq1C8BYhN46TVQs4XHrn79WeYQPTPWBR","rotation":[0,1.5707963267948966,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-1.75,6.5,0.25],"version":"27875","uuid":"b7487cbb-f5e0-477f-be3d-e069b97d0963"},{"type":"image","scale":[3.8,0.7,0],"url":"https://ipfs.infura.io/ipfs/QmSHWMnUHZBsY7yVgGE93KPywiDfA2EFCMduHKG8MPGrW1","position":[-9.25,8.5,-4.75],"rotation":[0,4.71239,0],"version":"27875","uuid":"7d10f39e-ecfe-4471-87dc-f3ef891d6008","stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1},{"type":"image","scale":[3.8,0.7,0],"url":"https://ipfs.infura.io/ipfs/QmZMLkkboxyVxNLbYhQ3Fm3b36hLfUhosRQmc21wNXHTwv","rotation":[0,4.71239,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-9.25,8.75,5.75],"version":"27875","uuid":"e8ed4983-144f-49d0-9327-35e578180dfd"},{"type":"image","scale":[2.5,1.4,0],"url":"https://ipfs.infura.io/ipfs/QmXkR1GDaUnaThhUP91bRPHhJ6gdTNbrRJPqsUdZTimQV2","rotation":[0,4.71239,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-9.25,5.5,0.5],"version":"27875","uuid":"a7421c4a-5f6d-4277-87ee-be0b13427a34"},{"type":"image","scale":[2.2,2,0],"url":"https://ipfs.infura.io/ipfs/QmbwuGWFpiBnF5545R4Es6C1sG56qi6po45EPnXdhQkGVp","rotation":[0,4.71239,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-9.25,7.25,5.5],"version":"27875","uuid":"e20abe1f-9b21-4ff4-a585-e0730281deb7"},{"type":"image","scale":[2.2,2,0],"url":"https://ipfs.infura.io/ipfs/QmYWNye5oQVaqnZ3bzw6M4YBwcyMDjXnyjvknNBqzEH1GZ","rotation":[0,4.71239,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"position":[-9.25,7,-4.5],"version":"27875","uuid":"b8b79196-dfb3-43d7-903c-406d4b5c74dc"},{"type":"image","scale":[4.5,0.9,0],"url":"https://ipfs.infura.io/ipfs/QmZMLkkboxyVxNLbYhQ3Fm3b36hLfUhosRQmc21wNXHTwv","rotation":[0,0,0],"stretch":true,"transparent":false,"opacity":"1.00","updateDaily":false,"uScale":1,"vScale":1,"blendMode":"Combine","position":[7.5,4.3,7.25],"version":"27923","uuid":"d8879775-6046-4a1a-842f-3aa36808c405"},{"url":"https://ipfs.infura.io/ipfs/QmdJJ3zcMLX3cjwe3YUDArvSeyb6yHhqSu52oX13bXRFFD","type":"image","uuid":"2ec6a592-d698-4395-8263-6ef882a2d13b","scale":[2.2,1.3,0],"script":"","stretch":true,"version":"27979","position":[-7.75,6.499999904632569,-7.25],"rotation":[0,0,0],"animation":{"keyframes":[]},"blendMode":"Multiply","transparent":false,"updateDaily":false},{"type":"video","scale":[1.8,1.6,0],"url":"https://ipfs.infura.io/ipfs/QmV6rBNq4pcPk4VZxAaDdrhSYgiFnDSQjmFrvCjk5vJsab","rotation":[0,4.71239,0],"autoplay":false,"loop":true,"startAt":0,"endAt":0,"rolloffFactor":1.2,"volume":0.7,"assetUrl":null,"previewUrl":"https://ipfs.infura.io/ipfs/QmPwLL4eLXbv3XztqWBpWfiWswB3Ct339Stfc9R1aYQ4gQ","position":[6.05,2,3.75],"version":"27979","uuid":"023ec312-9d9d-4ea7-879f-c927b605b3b4"},{"type":"spawn-point","scale":[1,1,1],"position":[-1,0.55,9.75],"rotation":[0,3.14159,0],"version":"27979","uuid":"d0ddeed8-edd6-4d28-8edf-8c3cc5597afb"}],"settings":{"sandbox":false,"hosted_scripts":false},"voxels":"eJztnWFu4yAQRt1G2j+7t4x6j961F1lFqYUx42RgEobB75s/rd1nC4pfMU7Sj++P5vpjqItQy2+kfWV9Lmvt2bQnr8SlY+zZ7dlz+rZnHDbviWfsvg+O2OM+vh8tz+MjR6y8HUfjaN/ez8WTldrwelbXdzr2aqh2W9l8VQx+dW4t9mBv/d7OtsfGttM29tlV92h0t5/Xi/Xr54jsVTU21vNsS/LVZWJf2ZyDr/Ssl68i/i2L6Bx8pQ2+qmE9ffX3u77w1fxs6avSTPjq3n581YfFV3o2onPwlTb4qobFVz1YfFXDzuur+/OEclsrqx1Xr2d1sbBS8FUfFl/VsPhKy+KrXiy+0rMRnYOvpOArfFWTmL6KyOIrbWKOq/bgK33wVS8WX2njNSYtrF+8TImv5mbx1bOsvdsyrixsOga+0gdfzc3iK22YX9UEX/VgYzoHX+GrmVibN3x8xfsHx2d7+OpzGcVXpCb4qgcb0xv4Cl+NFn9frWNt66S88j34ana2r69uHL6KknF8dfl1kvTZSfme8rzb5yX7yvf4sNJaX0xWVxZW8pWWbVm/erWvfoQeLVv/I153Z2Pr4++r1KZ/Rcnb9lfWtp+255DP68FuP38xFruvHuxVYMv5lbSt5fP6mF9Fitda/bKUJtKV5SmsF3u+1wO/9n5QW/hq9uCrHqxffEzp5atFWEXXF74aP/iqB8v8qoY9l69s1xFsHxZf9WHP5Sv+30Qv1usZvd96e6p13b1mvT1fw61bM+/P5uvPEdl519u9fGV5D6CFTcc4l69sf0PTaEuvrioNdrRFbkl+VR5taWelluhYuafez8qzs9ewj8rGSvMrHRvJV9teice2klbW01fSq9dzg0nfR/wdeWXm+8FyfrWEml+twVc17Fi+0r0fJ97vyCvn8tX494PSPF07JsdiNaSNPTpeK4uvxg++wlfvYTUkvsJXdcFX+Oo9rIbEV/iqLvhqLF9JYf2qhsVXeraV9Au+wlfvYVtJfFUTfBWBPZevPK/+dtYrY/jqfp8r+Wm/p/SVdI98tMfGtrXVM/gqgq+IPvgKX43Gevnqy1DNzSVVwVf4ajQWX5GjjOEr1q/eE3yFr+YKvtKzraRf8BXrV3PFchXiq9GDr8b3ldcTPr/POLKwzK/0bCvpF3yFr46Cr+rOqxmT8jjFV9rgK1vpfXUpKrWo3Hf8s/ef33796Dp4zqZz5F9L15Efu61nrNwLLWydcyKWpb2wWvZqqP+vx59C","owner":"0x00a2Ddfa736214563CEa9AEf5100f2e90c402918","lightmap_status":"None","parcel_users":[{"wallet":"0x130093a5aebc07e78e16f0ecef09d1c45afd8178","role":"contributor"},{"wallet":"0x18afcf776a76f90f27ce03e66567068ac0ff1e7e","role":"contributor"},{"wallet":"0x6678816562210a35faf1dac17139bd820f8c13be","role":"contributor"},{"wallet":"0x7b035331967075a168471dfbd23ed977f048f61e","role":"contributor"}],"description":"# Web3Skills Fractal Gallery & Patron's Stage gallery portal collection","name":"@Web3Skills Gallery & Live Stage","label":"","address":"9 Alva Fork","suburb":"Makers","island":"Origin City","x1":287,"y1":0,"z1":-83,"x2":307,"y2":10,"z2":-68,"tileset":"/uploads/atlas/2d93a1813022e983cb2387c9648a58d8118381ab.png","palette":["#ffffff","#888888","#000000","#ff0000","#01cdfe","#05ffa1","#b967ff","#fff700"],"is_common":false,"visible":true,"kind":"plot"}}